Total: 55.65s
ROUTINE ======================== bufio.(*Reader).Peek in /home/isucon/.local/go/src/bufio/bufio.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    127:	if n > len(b.buf) {
         .          .    128:		return nil, ErrBufferFull
         .          .    129:	}
         .          .    130:	// 0 <= n <= len(b.buf)
         .          .    131:	for b.w-b.r < n && b.err == nil {
         .       20ms    132:		b.fill() // b.w-b.r < len(b.buf) => buffer is not full
         .          .    133:	}
         .          .    134:
         .          .    135:	var err error
         .          .    136:	if avail := b.w - b.r; avail < n {
         .          .    137:		// not enough data in buffer
ROUTINE ======================== bufio.(*Reader).Read in /home/isucon/.local/go/src/bufio/bufio.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    202:				b.lastByte = int(p[n-1])
         .          .    203:				b.lastRuneSize = -1
         .          .    204:			}
         .          .    205:			return n, b.readErr()
         .          .    206:		}
         .       10ms    207:		b.fill() // buffer is empty
         .          .    208:		if b.r == b.w {
         .          .    209:			return 0, b.readErr()
         .          .    210:		}
         .          .    211:	}
         .          .    212:
ROUTINE ======================== bufio.(*Reader).ReadLine in /home/isucon/.local/go/src/bufio/bufio.go
         0       70ms (flat, cum)  0.13% of Total
         .          .    352:// No indication or error is given if the input ends without a final line end.
         .          .    353:// Calling UnreadByte after ReadLine will always unread the last byte read
         .          .    354:// (possibly a character belonging to the line end) even if that byte is not
         .          .    355:// part of the line returned by ReadLine.
         .          .    356:func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error) {
         .       70ms    357:	line, err = b.ReadSlice('\n')
         .          .    358:	if err == ErrBufferFull {
         .          .    359:		// Handle the case where "\r\n" straddles the buffer.
         .          .    360:		if len(line) > 0 && line[len(line)-1] == '\r' {
         .          .    361:			// Put the '\r' back on buf and drop it from line.
         .          .    362:			// Let the next call to ReadLine check for "\r\n".
ROUTINE ======================== bufio.(*Reader).ReadSlice in /home/isucon/.local/go/src/bufio/bufio.go
         0       80ms (flat, cum)  0.14% of Total
         .          .    323:			line = b.buf
         .          .    324:			err = ErrBufferFull
         .          .    325:			break
         .          .    326:		}
         .          .    327:
         .       80ms    328:		b.fill() // buffer is not full
         .          .    329:	}
         .          .    330:
         .          .    331:	// Handle last byte, if any.
         .          .    332:	if i := len(line) - 1; i >= 0 {
         .          .    333:		b.lastByte = int(line[i])
ROUTINE ======================== bufio.(*Reader).fill in /home/isucon/.local/go/src/bufio/bufio.go
         0      110ms (flat, cum)   0.2% of Total
         .          .     92:		panic("bufio: tried to fill full buffer")
         .          .     93:	}
         .          .     94:
         .          .     95:	// Read new data: try a limited number of times.
         .          .     96:	for i := maxConsecutiveEmptyReads; i > 0; i-- {
         .      110ms     97:		n, err := b.rd.Read(b.buf[b.w:])
         .          .     98:		if n < 0 {
         .          .     99:			panic(errNegativeRead)
         .          .    100:		}
         .          .    101:		b.w += n
         .          .    102:		if err != nil {
ROUTINE ======================== bufio.(*Writer).Flush in /home/isucon/.local/go/src/bufio/bufio.go
         0       80ms (flat, cum)  0.14% of Total
         .          .    546:	b.wr = w
         .          .    547:}
         .          .    548:
         .          .    549:// Flush writes any buffered data to the underlying io.Writer.
         .          .    550:func (b *Writer) Flush() error {
         .       80ms    551:	err := b.flush()
         .          .    552:	return err
         .          .    553:}
         .          .    554:
         .          .    555:func (b *Writer) flush() error {
         .          .    556:	if b.err != nil {
ROUTINE ======================== bufio.(*Writer).Write in /home/isucon/.local/go/src/bufio/bufio.go
      10ms      740ms (flat, cum)  1.33% of Total
         .          .    584:// Write writes the contents of p into the buffer.
         .          .    585:// It returns the number of bytes written.
         .          .    586:// If nn < len(p), it also returns an error explaining
         .          .    587:// why the write is short.
         .          .    588:func (b *Writer) Write(p []byte) (nn int, err error) {
      10ms       10ms    589:	for len(p) > b.Available() && b.err == nil {
         .          .    590:		var n int
         .          .    591:		if b.Buffered() == 0 {
         .          .    592:			// Large write, empty buffer.
         .          .    593:			// Write directly from p to avoid copy.
         .      550ms    594:			n, b.err = b.wr.Write(p)
         .          .    595:		} else {
         .          .    596:			n = copy(b.buf[b.n:], p)
         .          .    597:			b.n += n
         .      170ms    598:			b.flush()
         .          .    599:		}
         .          .    600:		nn += n
         .          .    601:		p = p[n:]
         .          .    602:	}
         .          .    603:	if b.err != nil {
         .          .    604:		return nn, b.err
         .          .    605:	}
         .       10ms    606:	n := copy(b.buf[b.n:], p)
         .          .    607:	b.n += n
         .          .    608:	nn += n
         .          .    609:	return nn, nil
         .          .    610:}
         .          .    611:
ROUTINE ======================== bufio.(*Writer).WriteString in /home/isucon/.local/go/src/bufio/bufio.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    665:		b.flush()
         .          .    666:	}
         .          .    667:	if b.err != nil {
         .          .    668:		return nn, b.err
         .          .    669:	}
         .       10ms    670:	n := copy(b.buf[b.n:], s)
         .          .    671:	b.n += n
         .          .    672:	nn += n
         .          .    673:	return nn, nil
         .          .    674:}
         .          .    675:
ROUTINE ======================== bufio.(*Writer).flush in /home/isucon/.local/go/src/bufio/bufio.go
      10ms      250ms (flat, cum)  0.45% of Total
         .          .    554:
         .          .    555:func (b *Writer) flush() error {
         .          .    556:	if b.err != nil {
         .          .    557:		return b.err
         .          .    558:	}
      10ms       10ms    559:	if b.n == 0 {
         .          .    560:		return nil
         .          .    561:	}
         .      240ms    562:	n, err := b.wr.Write(b.buf[0:b.n])
         .          .    563:	if n < b.n && err == nil {
         .          .    564:		err = io.ErrShortWrite
         .          .    565:	}
         .          .    566:	if err != nil {
         .          .    567:		if n > 0 && n < b.n {
ROUTINE ======================== bytes.(*Buffer).ReadFrom in /home/isucon/.local/go/src/bytes/buffer.go
         0      210ms (flat, cum)  0.38% of Total
         .          .    165:			// not enough space at end
         .          .    166:			newBuf := b.buf
         .          .    167:			if b.off+free < MinRead {
         .          .    168:				// not enough space using beginning of buffer;
         .          .    169:				// double buffer capacity
         .      150ms    170:				newBuf = makeSlice(2*cap(b.buf) + MinRead)
         .          .    171:			}
         .          .    172:			copy(newBuf, b.buf[b.off:])
         .          .    173:			b.buf = newBuf[:len(b.buf)-b.off]
         .          .    174:			b.off = 0
         .          .    175:		}
         .       60ms    176:		m, e := r.Read(b.buf[len(b.buf):cap(b.buf)])
         .          .    177:		b.buf = b.buf[0 : len(b.buf)+m]
         .          .    178:		n += int64(m)
         .          .    179:		if e == io.EOF {
         .          .    180:			break
         .          .    181:		}
ROUTINE ======================== bytes.(*Buffer).Write in /home/isucon/.local/go/src/bytes/buffer.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    129:// Write appends the contents of p to the buffer, growing the buffer as
         .          .    130:// needed. The return value n is the length of p; err is always nil. If the
         .          .    131:// buffer becomes too large, Write will panic with ErrTooLarge.
         .          .    132:func (b *Buffer) Write(p []byte) (n int, err error) {
         .          .    133:	b.lastRead = opInvalid
         .       20ms    134:	m := b.grow(len(p))
         .          .    135:	return copy(b.buf[m:], p), nil
         .          .    136:}
         .          .    137:
         .          .    138:// WriteString appends the contents of s to the buffer, growing the buffer as
         .          .    139:// needed. The return value n is the length of s; err is always nil. If the
ROUTINE ======================== bytes.(*Buffer).WriteString in /home/isucon/.local/go/src/bytes/buffer.go
         0       60ms (flat, cum)  0.11% of Total
         .          .    138:// WriteString appends the contents of s to the buffer, growing the buffer as
         .          .    139:// needed. The return value n is the length of s; err is always nil. If the
         .          .    140:// buffer becomes too large, WriteString will panic with ErrTooLarge.
         .          .    141:func (b *Buffer) WriteString(s string) (n int, err error) {
         .          .    142:	b.lastRead = opInvalid
         .       30ms    143:	m := b.grow(len(s))
         .       30ms    144:	return copy(b.buf[m:], s), nil
         .          .    145:}
         .          .    146:
         .          .    147:// MinRead is the minimum slice size passed to a Read call by
         .          .    148:// Buffer.ReadFrom.  As long as the Buffer has at least MinRead bytes beyond
         .          .    149:// what is required to hold the contents of r, ReadFrom will not grow the
ROUTINE ======================== bytes.(*Buffer).grow in /home/isucon/.local/go/src/bytes/buffer.go
      10ms       50ms (flat, cum)  0.09% of Total
         .          .    101:			// don't spend all our time copying.
         .          .    102:			copy(b.buf[:], b.buf[b.off:])
         .          .    103:			buf = b.buf[:m]
         .          .    104:		} else {
         .          .    105:			// not enough space anywhere
      10ms       50ms    106:			buf = makeSlice(2*cap(b.buf) + n)
         .          .    107:			copy(buf, b.buf[b.off:])
         .          .    108:		}
         .          .    109:		b.buf = buf
         .          .    110:		b.off = 0
         .          .    111:	}
ROUTINE ======================== bytes.HasPrefix in /home/isucon/.local/go/src/bytes/bytes.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    339:	}
         .          .    340:	return b
         .          .    341:}
         .          .    342:
         .          .    343:// HasPrefix tests whether the byte slice s begins with prefix.
      10ms       10ms    344:func HasPrefix(s, prefix []byte) bool {
         .          .    345:	return len(s) >= len(prefix) && Equal(s[0:len(prefix)], prefix)
         .          .    346:}
         .          .    347:
         .          .    348:// HasSuffix tests whether the byte slice s ends with suffix.
         .          .    349:func HasSuffix(s, suffix []byte) bool {
ROUTINE ======================== bytes.Index in /home/isucon/.local/go/src/bytes/bytes.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     98:	}
         .          .     99:	i := 0
         .          .    100:	t := s[:len(s)-n+1]
         .          .    101:	for i < len(t) {
         .          .    102:		if t[i] != c {
         .       10ms    103:			o := IndexByte(t[i:], c)
         .          .    104:			if o < 0 {
         .          .    105:				break
         .          .    106:			}
         .          .    107:			i += o
         .          .    108:		}
ROUTINE ======================== bytes.makeSlice in /home/isucon/.local/go/src/bytes/buffer.go
         0      190ms (flat, cum)  0.34% of Total
         .          .    193:	defer func() {
         .          .    194:		if recover() != nil {
         .          .    195:			panic(ErrTooLarge)
         .          .    196:		}
         .          .    197:	}()
         .      190ms    198:	return make([]byte, n)
         .          .    199:}
         .          .    200:
         .          .    201:// WriteTo writes data to w until the buffer is drained or an error occurs.
         .          .    202:// The return value n is the number of bytes written; it always fits into an
         .          .    203:// int, but it is int64 to match the io.WriterTo interface. Any error
ROUTINE ======================== crypto/hmac.New in /home/isucon/.local/go/src/crypto/hmac/hmac.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     75:}
         .          .     76:
         .          .     77:// New returns a new HMAC hash using the given hash.Hash type and key.
         .          .     78:func New(h func() hash.Hash, key []byte) hash.Hash {
         .          .     79:	hm := new(hmac)
         .       10ms     80:	hm.outer = h()
         .          .     81:	hm.inner = h()
         .          .     82:	hm.size = hm.inner.Size()
         .          .     83:	hm.blocksize = hm.inner.BlockSize()
         .          .     84:	hm.tmp = make([]byte, hm.blocksize+hm.size)
         .          .     85:	if len(key) > hm.blocksize {
ROUTINE ======================== crypto/rand.(*devReader).Read in /home/isucon/.local/go/src/crypto/rand/rand_unix.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     59:			r.f = f
         .          .     60:		} else {
         .          .     61:			r.f = bufio.NewReader(hideAgainReader{f})
         .          .     62:		}
         .          .     63:	}
         .       10ms     64:	return r.f.Read(b)
         .          .     65:}
         .          .     66:
         .          .     67:var isEAGAIN func(error) bool // set by eagain.go on unix systems
         .          .     68:
         .          .     69:// hideAgainReader masks EAGAIN reads from /dev/urandom.
ROUTINE ======================== crypto/rand.(*hideAgainReader).Read in <autogenerated>
         0       10ms (flat, cum) 0.018% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== crypto/rand.hideAgainReader.Read in /home/isucon/.local/go/src/crypto/rand/rand_unix.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     71:type hideAgainReader struct {
         .          .     72:	r io.Reader
         .          .     73:}
         .          .     74:
         .          .     75:func (hr hideAgainReader) Read(p []byte) (n int, err error) {
         .       10ms     76:	n, err = hr.r.Read(p)
         .          .     77:	if err != nil && isEAGAIN != nil && isEAGAIN(err) {
         .          .     78:		err = nil
         .          .     79:	}
         .          .     80:	return
         .          .     81:}
ROUTINE ======================== crypto/sha256.New in /home/isucon/.local/go/src/crypto/sha256/sha256.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .     77:	d.nx = 0
         .          .     78:	d.len = 0
         .          .     79:}
         .          .     80:
         .          .     81:// New returns a new hash.Hash computing the SHA256 checksum.
      10ms       10ms     82:func New() hash.Hash {
         .          .     83:	d := new(digest)
         .          .     84:	d.Reset()
         .          .     85:	return d
         .          .     86:}
         .          .     87:
ROUTINE ======================== database/sql.(*DB).Exec in /home/isucon/.local/go/src/database/sql/sql.go
         0      110ms (flat, cum)   0.2% of Total
         .          .   1004:// The args are for any placeholder parameters in the query.
         .          .   1005:func (db *DB) Exec(query string, args ...interface{}) (Result, error) {
         .          .   1006:	var res Result
         .          .   1007:	var err error
         .          .   1008:	for i := 0; i < maxBadConnRetries; i++ {
         .      110ms   1009:		res, err = db.exec(query, args, cachedOrNewConn)
         .          .   1010:		if err != driver.ErrBadConn {
         .          .   1011:			break
         .          .   1012:		}
         .          .   1013:	}
         .          .   1014:	if err == driver.ErrBadConn {
ROUTINE ======================== database/sql.(*DB).Query in /home/isucon/.local/go/src/database/sql/sql.go
         0      4.05s (flat, cum)  7.28% of Total
         .          .   1056:// The args are for any placeholder parameters in the query.
         .          .   1057:func (db *DB) Query(query string, args ...interface{}) (*Rows, error) {
         .          .   1058:	var rows *Rows
         .          .   1059:	var err error
         .          .   1060:	for i := 0; i < maxBadConnRetries; i++ {
         .      4.05s   1061:		rows, err = db.query(query, args, cachedOrNewConn)
         .          .   1062:		if err != driver.ErrBadConn {
         .          .   1063:			break
         .          .   1064:		}
         .          .   1065:	}
         .          .   1066:	if err == driver.ErrBadConn {
ROUTINE ======================== database/sql.(*DB).conn in /home/isucon/.local/go/src/database/sql/sql.go
      20ms      870ms (flat, cum)  1.56% of Total
         .          .    782:	}
         .          .    783:	lifetime := db.maxLifetime
         .          .    784:
         .          .    785:	// Prefer a free connection, if possible.
         .          .    786:	numFree := len(db.freeConn)
      10ms       10ms    787:	if strategy == cachedOrNewConn && numFree > 0 {
         .          .    788:		conn := db.freeConn[0]
      10ms       30ms    789:		copy(db.freeConn, db.freeConn[1:])
         .          .    790:		db.freeConn = db.freeConn[:numFree-1]
         .          .    791:		conn.inUse = true
         .          .    792:		db.mu.Unlock()
         .          .    793:		if conn.expired(lifetime) {
         .          .    794:			conn.Close()
         .          .    795:			return nil, driver.ErrBadConn
         .          .    796:		}
         .          .    797:		return conn, nil
         .          .    798:	}
         .          .    799:
         .          .    800:	// Out of free connections or we were asked not to use one.  If we're not
         .          .    801:	// allowed to open any more connections, make a request and wait.
         .          .    802:	if db.maxOpen > 0 && db.numOpen >= db.maxOpen {
         .          .    803:		// Make the connRequest channel. It's buffered so that the
         .          .    804:		// connectionOpener doesn't block while waiting for the req to be read.
         .          .    805:		req := make(chan connRequest, 1)
         .          .    806:		db.connRequests = append(db.connRequests, req)
         .          .    807:		db.mu.Unlock()
         .          .    808:		ret, ok := <-req
         .          .    809:		if !ok {
         .          .    810:			return nil, errDBClosed
         .          .    811:		}
         .          .    812:		if ret.err == nil && ret.conn.expired(lifetime) {
         .          .    813:			ret.conn.Close()
         .          .    814:			return nil, driver.ErrBadConn
         .          .    815:		}
         .          .    816:		return ret.conn, ret.err
         .          .    817:	}
         .          .    818:
         .          .    819:	db.numOpen++ // optimistically
         .          .    820:	db.mu.Unlock()
         .      790ms    821:	ci, err := db.driver.Open(db.dsn)
         .          .    822:	if err != nil {
         .          .    823:		db.mu.Lock()
         .          .    824:		db.numOpen-- // correct for earlier optimism
         .          .    825:		db.maybeOpenNewConnections()
         .          .    826:		db.mu.Unlock()
         .          .    827:		return nil, err
         .          .    828:	}
         .          .    829:	db.mu.Lock()
         .          .    830:	dc := &driverConn{
         .          .    831:		db:        db,
         .          .    832:		createdAt: nowFunc(),
         .       10ms    833:		ci:        ci,
         .          .    834:	}
         .       30ms    835:	db.addDepLocked(dc, dc)
         .          .    836:	dc.inUse = true
         .          .    837:	db.mu.Unlock()
         .          .    838:	return dc, nil
         .          .    839:}
         .          .    840:
ROUTINE ======================== database/sql.(*DB).exec in /home/isucon/.local/go/src/database/sql/sql.go
         0      110ms (flat, cum)   0.2% of Total
         .          .   1016:	}
         .          .   1017:	return res, err
         .          .   1018:}
         .          .   1019:
         .          .   1020:func (db *DB) exec(query string, args []interface{}, strategy connReuseStrategy) (res Result, err error) {
         .       30ms   1021:	dc, err := db.conn(strategy)
         .          .   1022:	if err != nil {
         .          .   1023:		return nil, err
         .          .   1024:	}
         .          .   1025:	defer func() {
         .          .   1026:		db.putConn(dc, err)
         .          .   1027:	}()
         .          .   1028:
         .          .   1029:	if execer, ok := dc.ci.(driver.Execer); ok {
         .          .   1030:		dargs, err := driverArgs(nil, args)
         .          .   1031:		if err != nil {
         .          .   1032:			return nil, err
         .          .   1033:		}
         .          .   1034:		dc.Lock()
         .          .   1035:		resi, err := execer.Exec(query, dargs)
         .          .   1036:		dc.Unlock()
         .          .   1037:		if err != driver.ErrSkip {
         .          .   1038:			if err != nil {
         .          .   1039:				return nil, err
         .          .   1040:			}
         .          .   1041:			return driverResult{dc, resi}, nil
         .          .   1042:		}
         .          .   1043:	}
         .          .   1044:
         .          .   1045:	dc.Lock()
         .          .   1046:	si, err := dc.ci.Prepare(query)
         .          .   1047:	dc.Unlock()
         .          .   1048:	if err != nil {
         .          .   1049:		return nil, err
         .          .   1050:	}
         .          .   1051:	defer withLock(dc, func() { si.Close() })
         .       80ms   1052:	return resultFromStatement(driverStmt{dc, si}, args...)
         .          .   1053:}
         .          .   1054:
         .          .   1055:// Query executes a query that returns rows, typically a SELECT.
         .          .   1056:// The args are for any placeholder parameters in the query.
         .          .   1057:func (db *DB) Query(query string, args ...interface{}) (*Rows, error) {
ROUTINE ======================== database/sql.(*DB).putConn in /home/isucon/.local/go/src/database/sql/sql.go
      10ms       80ms (flat, cum)  0.14% of Total
         .          .    900:		return
         .          .    901:	}
         .          .    902:	if putConnHook != nil {
         .          .    903:		putConnHook(db, dc)
         .          .    904:	}
         .       20ms    905:	added := db.putConnDBLocked(dc, nil)
      10ms       10ms    906:	db.mu.Unlock()
         .          .    907:
         .          .    908:	if !added {
         .       50ms    909:		dc.Close()
         .          .    910:	}
         .          .    911:}
         .          .    912:
         .          .    913:// Satisfy a connRequest or put the driverConn in the idle pool and return true
         .          .    914:// or return false.
ROUTINE ======================== database/sql.(*DB).putConnDBLocked in /home/isucon/.local/go/src/database/sql/sql.go
      20ms       20ms (flat, cum) 0.036% of Total
         .          .    936:		req <- connRequest{
         .          .    937:			conn: dc,
         .          .    938:			err:  err,
         .          .    939:		}
         .          .    940:		return true
      10ms       10ms    941:	} else if err == nil && !db.closed && db.maxIdleConnsLocked() > len(db.freeConn) {
      10ms       10ms    942:		db.freeConn = append(db.freeConn, dc)
         .          .    943:		db.startCleanerLocked()
         .          .    944:		return true
         .          .    945:	}
         .          .    946:	return false
         .          .    947:}
ROUTINE ======================== database/sql.(*DB).query in /home/isucon/.local/go/src/database/sql/sql.go
      10ms      4.05s (flat, cum)  7.28% of Total
         .          .   1068:	}
         .          .   1069:	return rows, err
         .          .   1070:}
         .          .   1071:
         .          .   1072:func (db *DB) query(query string, args []interface{}, strategy connReuseStrategy) (*Rows, error) {
         .      840ms   1073:	ci, err := db.conn(strategy)
         .          .   1074:	if err != nil {
         .          .   1075:		return nil, err
         .          .   1076:	}
         .          .   1077:
      10ms      3.21s   1078:	return db.queryConn(ci, ci.releaseConn, query, args)
         .          .   1079:}
         .          .   1080:
         .          .   1081:// queryConn executes a query on the given connection.
         .          .   1082:// The connection gets released by the releaseConn function.
         .          .   1083:func (db *DB) queryConn(dc *driverConn, releaseConn func(error), query string, args []interface{}) (*Rows, error) {
ROUTINE ======================== database/sql.(*DB).queryConn in /home/isucon/.local/go/src/database/sql/sql.go
      40ms      3.20s (flat, cum)  5.75% of Total
         .          .   1079:}
         .          .   1080:
         .          .   1081:// queryConn executes a query on the given connection.
         .          .   1082:// The connection gets released by the releaseConn function.
         .          .   1083:func (db *DB) queryConn(dc *driverConn, releaseConn func(error), query string, args []interface{}) (*Rows, error) {
         .       10ms   1084:	if queryer, ok := dc.ci.(driver.Queryer); ok {
         .       30ms   1085:		dargs, err := driverArgs(nil, args)
         .          .   1086:		if err != nil {
         .          .   1087:			releaseConn(err)
         .          .   1088:			return nil, err
         .          .   1089:		}
         .          .   1090:		dc.Lock()
         .       70ms   1091:		rowsi, err := queryer.Query(query, dargs)
         .          .   1092:		dc.Unlock()
         .       10ms   1093:		if err != driver.ErrSkip {
         .          .   1094:			if err != nil {
         .          .   1095:				releaseConn(err)
         .          .   1096:				return nil, err
         .          .   1097:			}
         .          .   1098:			// Note: ownership of dc passes to the *Rows, to be freed
         .          .   1099:			// with releaseConn.
         .          .   1100:			rows := &Rows{
         .          .   1101:				dc:          dc,
         .          .   1102:				releaseConn: releaseConn,
         .          .   1103:				rowsi:       rowsi,
         .          .   1104:			}
         .          .   1105:			return rows, nil
         .          .   1106:		}
         .          .   1107:	}
         .          .   1108:
         .          .   1109:	dc.Lock()
      20ms      930ms   1110:	si, err := dc.ci.Prepare(query)
      10ms       20ms   1111:	dc.Unlock()
         .          .   1112:	if err != nil {
         .          .   1113:		releaseConn(err)
         .          .   1114:		return nil, err
         .          .   1115:	}
         .          .   1116:
         .          .   1117:	ds := driverStmt{dc, si}
      10ms      2.10s   1118:	rowsi, err := rowsiFromStatement(ds, args...)
         .          .   1119:	if err != nil {
         .          .   1120:		dc.Lock()
         .          .   1121:		si.Close()
         .          .   1122:		dc.Unlock()
         .          .   1123:		releaseConn(err)
         .          .   1124:		return nil, err
         .          .   1125:	}
         .          .   1126:
         .          .   1127:	// Note: ownership of ci passes to the *Rows, to be freed
         .          .   1128:	// with releaseConn.
         .          .   1129:	rows := &Rows{
         .          .   1130:		dc:          dc,
         .          .   1131:		releaseConn: releaseConn,
         .          .   1132:		rowsi:       rowsi,
         .       30ms   1133:		closeStmt:   si,
         .          .   1134:	}
         .          .   1135:	return rows, nil
         .          .   1136:}
         .          .   1137:
         .          .   1138:// QueryRow executes a query that is expected to return at most one row.
ROUTINE ======================== database/sql.(*Rows).Close in /home/isucon/.local/go/src/database/sql/sql.go
      10ms      890ms (flat, cum)  1.60% of Total
         .          .   1862:func (rs *Rows) Close() error {
         .          .   1863:	if rs.closed {
         .          .   1864:		return nil
         .          .   1865:	}
         .          .   1866:	rs.closed = true
      10ms       40ms   1867:	err := rs.rowsi.Close()
         .          .   1868:	if fn := rowsCloseHook; fn != nil {
         .          .   1869:		fn(rs, &err)
         .          .   1870:	}
         .          .   1871:	if rs.closeStmt != nil {
         .      760ms   1872:		rs.closeStmt.Close()
         .          .   1873:	}
         .       90ms   1874:	rs.releaseConn(err)
         .          .   1875:	return err
         .          .   1876:}
         .          .   1877:
         .          .   1878:// Row is the result of calling QueryRow to select a single row.
         .          .   1879:type Row struct {
ROUTINE ======================== database/sql.(*Rows).Columns in /home/isucon/.local/go/src/database/sql/sql.go
         0       60ms (flat, cum)  0.11% of Total
         .          .   1779:		return nil, errors.New("sql: Rows are closed")
         .          .   1780:	}
         .          .   1781:	if rs.rowsi == nil {
         .          .   1782:		return nil, errors.New("sql: no Rows available")
         .          .   1783:	}
         .       60ms   1784:	return rs.rowsi.Columns(), nil
         .          .   1785:}
         .          .   1786:
         .          .   1787:// Scan copies the columns in the current row into the values pointed
         .          .   1788:// at by dest. The number of values in dest must be the same as the
         .          .   1789:// number of columns in Rows.
ROUTINE ======================== database/sql.(*Rows).Next in /home/isucon/.local/go/src/database/sql/sql.go
     100ms     15.12s (flat, cum) 27.17% of Total
         .          .   1745:// returns true on success, or false if there is no next result row or an error
         .          .   1746:// happened while preparing it.  Err should be consulted to distinguish between
         .          .   1747:// the two cases.
         .          .   1748://
         .          .   1749:// Every call to Scan, even the first one, must be preceded by a call to Next.
      10ms       10ms   1750:func (rs *Rows) Next() bool {
      30ms       30ms   1751:	if rs.closed {
         .          .   1752:		return false
         .          .   1753:	}
      10ms       10ms   1754:	if rs.lastcols == nil {
         .       50ms   1755:		rs.lastcols = make([]driver.Value, len(rs.rowsi.Columns()))
         .          .   1756:	}
      50ms     14.84s   1757:	rs.lasterr = rs.rowsi.Next(rs.lastcols)
         .          .   1758:	if rs.lasterr != nil {
         .      180ms   1759:		rs.Close()
         .          .   1760:		return false
         .          .   1761:	}
         .          .   1762:	return true
         .          .   1763:}
         .          .   1764:
ROUTINE ======================== database/sql.(*Rows).Scan in /home/isucon/.local/go/src/database/sql/sql.go
     330ms      9.54s (flat, cum) 17.14% of Total
         .          .   1834:// *interface{}, *string, *[]byte, or *RawBytes.
         .          .   1835://
         .          .   1836:// For scanning into *bool, the source may be true, false, 1, 0, or
         .          .   1837:// string inputs parseable by strconv.ParseBool.
         .          .   1838:func (rs *Rows) Scan(dest ...interface{}) error {
      10ms       10ms   1839:	if rs.closed {
         .          .   1840:		return errors.New("sql: Rows are closed")
         .          .   1841:	}
         .          .   1842:	if rs.lastcols == nil {
         .          .   1843:		return errors.New("sql: Scan called without calling Next")
         .          .   1844:	}
         .          .   1845:	if len(dest) != len(rs.lastcols) {
         .          .   1846:		return fmt.Errorf("sql: expected %d destination arguments in Scan, not %d", len(rs.lastcols), len(dest))
         .          .   1847:	}
     110ms      110ms   1848:	for i, sv := range rs.lastcols {
     180ms      9.39s   1849:		err := convertAssign(dest[i], sv)
      10ms       10ms   1850:		if err != nil {
         .          .   1851:			return fmt.Errorf("sql: Scan error on column index %d: %v", i, err)
         .          .   1852:		}
         .          .   1853:	}
      20ms       20ms   1854:	return nil
         .          .   1855:}
         .          .   1856:
         .          .   1857:var rowsCloseHook func(*Rows, *error)
         .          .   1858:
         .          .   1859:// Close closes the Rows, preventing further enumeration. If Next returns
ROUTINE ======================== database/sql.(*driverConn).(database/sql.releaseConn)-fm in /home/isucon/.local/go/src/database/sql/sql.go
      10ms       90ms (flat, cum)  0.16% of Total
         .          .   1073:	ci, err := db.conn(strategy)
         .          .   1074:	if err != nil {
         .          .   1075:		return nil, err
         .          .   1076:	}
         .          .   1077:
      10ms       90ms   1078:	return db.queryConn(ci, ci.releaseConn, query, args)
         .          .   1079:}
         .          .   1080:
         .          .   1081:// queryConn executes a query on the given connection.
         .          .   1082:// The connection gets released by the releaseConn function.
         .          .   1083:func (db *DB) queryConn(dc *driverConn, releaseConn func(error), query string, args []interface{}) (*Rows, error) {
ROUTINE ======================== database/sql.(*driverConn).Close in /home/isucon/.local/go/src/database/sql/sql.go
         0       50ms (flat, cum)  0.09% of Total
         .          .    344:	// And now updates that require holding dc.mu.Lock.
         .          .    345:	dc.db.mu.Lock()
         .          .    346:	dc.dbmuClosed = true
         .          .    347:	fn := dc.db.removeDepLocked(dc, dc)
         .          .    348:	dc.db.mu.Unlock()
         .       50ms    349:	return fn()
         .          .    350:}
         .          .    351:
         .          .    352:func (dc *driverConn) finalClose() error {
         .          .    353:	dc.Lock()
         .          .    354:
ROUTINE ======================== database/sql.(*driverConn).Lock in <autogenerated>
      10ms       10ms (flat, cum) 0.018% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== database/sql.(*driverConn).finalClose in /home/isucon/.local/go/src/database/sql/sql.go
         0       50ms (flat, cum)  0.09% of Total
         .          .    355:	for si := range dc.openStmt {
         .          .    356:		si.Close()
         .          .    357:	}
         .          .    358:	dc.openStmt = nil
         .          .    359:
         .       50ms    360:	err := dc.ci.Close()
         .          .    361:	dc.ci = nil
         .          .    362:	dc.finalClosed = true
         .          .    363:	dc.Unlock()
         .          .    364:
         .          .    365:	dc.db.mu.Lock()
ROUTINE ======================== database/sql.(*driverConn).releaseConn in /home/isucon/.local/go/src/database/sql/sql.go
         0       80ms (flat, cum)  0.14% of Total
         .          .    279:	onPut      []func() // code (with db.mu held) run when conn is next returned
         .          .    280:	dbmuClosed bool     // same as closed, but guarded by db.mu, for removeClosedStmtLocked
         .          .    281:}
         .          .    282:
         .          .    283:func (dc *driverConn) releaseConn(err error) {
         .       80ms    284:	dc.db.putConn(dc, err)
         .          .    285:}
         .          .    286:
         .          .    287:func (dc *driverConn) removeOpenStmt(si driver.Stmt) {
         .          .    288:	dc.Lock()
         .          .    289:	defer dc.Unlock()
ROUTINE ======================== database/sql.(finalCloser).(database/sql.finalClose)-fm in /home/isucon/.local/go/src/database/sql/sql.go
         0       50ms (flat, cum)  0.09% of Total
         .          .    444:		// Nothing removed. Shouldn't happen.
         .          .    445:		panic(fmt.Sprintf("unpaired removeDep: no %T dep on %T", dep, x))
         .          .    446:	case 0:
         .          .    447:		// No more dependencies.
         .          .    448:		delete(db.dep, x)
         .       50ms    449:		return x.finalClose
         .          .    450:	default:
         .          .    451:		// Dependencies remain.
         .          .    452:		return func() error { return nil }
         .          .    453:	}
         .          .    454:}
ROUTINE ======================== database/sql.asString in /home/isucon/.local/go/src/database/sql/convert.go
     130ms      1.52s (flat, cum)  2.73% of Total
         .          .    282:		copy(c, b)
         .          .    283:		return c
         .          .    284:	}
         .          .    285:}
         .          .    286:
      40ms       40ms    287:func asString(src interface{}) string {
      80ms      330ms    288:	switch v := src.(type) {
         .          .    289:	case string:
         .          .    290:		return v
         .          .    291:	case []byte:
         .         1s    292:		return string(v)
         .          .    293:	}
         .       30ms    294:	rv := reflect.ValueOf(src)
         .          .    295:	switch rv.Kind() {
         .          .    296:	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
      10ms      120ms    297:		return strconv.FormatInt(rv.Int(), 10)
         .          .    298:	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
         .          .    299:		return strconv.FormatUint(rv.Uint(), 10)
         .          .    300:	case reflect.Float64:
         .          .    301:		return strconv.FormatFloat(rv.Float(), 'g', -1, 64)
         .          .    302:	case reflect.Float32:
ROUTINE ======================== database/sql.convertAssign in /home/isucon/.local/go/src/database/sql/convert.go
     1.76s      9.21s (flat, cum) 16.55% of Total
         .          .     81:}
         .          .     82:
         .          .     83:// convertAssign copies to dest the value in src, converting it if possible.
         .          .     84:// An error is returned if the copy would result in loss of information.
         .          .     85:// dest should be a pointer type.
     200ms      200ms     86:func convertAssign(dest, src interface{}) error {
         .          .     87:	// Common cases, without reflect.
     160ms      880ms     88:	switch s := src.(type) {
         .          .     89:	case string:
         .          .     90:		switch d := dest.(type) {
         .          .     91:		case *string:
         .          .     92:			if d == nil {
         .          .     93:				return errNilPtr
         .          .     94:			}
         .          .     95:			*d = s
         .          .     96:			return nil
         .          .     97:		case *[]byte:
         .          .     98:			if d == nil {
         .          .     99:				return errNilPtr
         .          .    100:			}
         .          .    101:			*d = []byte(s)
         .          .    102:			return nil
         .          .    103:		}
         .          .    104:	case []byte:
     240ms      290ms    105:		switch d := dest.(type) {
         .          .    106:		case *string:
      20ms       20ms    107:			if d == nil {
         .          .    108:				return errNilPtr
         .          .    109:			}
      30ms      1.39s    110:			*d = string(s)
      20ms       20ms    111:			return nil
         .          .    112:		case *interface{}:
         .          .    113:			if d == nil {
         .          .    114:				return errNilPtr
         .          .    115:			}
         .          .    116:			*d = cloneBytes(s)
         .          .    117:			return nil
         .          .    118:		case *[]byte:
         .          .    119:			if d == nil {
         .          .    120:				return errNilPtr
         .          .    121:			}
         .      810ms    122:			*d = cloneBytes(s)
         .          .    123:			return nil
         .          .    124:		case *RawBytes:
         .          .    125:			if d == nil {
         .          .    126:				return errNilPtr
         .          .    127:			}
         .          .    128:			*d = s
         .          .    129:			return nil
         .          .    130:		}
         .          .    131:	case time.Time:
      10ms       40ms    132:		switch d := dest.(type) {
         .          .    133:		case *string:
         .          .    134:			*d = s.Format(time.RFC3339Nano)
         .          .    135:			return nil
         .          .    136:		case *[]byte:
         .          .    137:			if d == nil {
         .          .    138:				return errNilPtr
         .          .    139:			}
         .          .    140:			*d = []byte(s.Format(time.RFC3339Nano))
         .          .    141:			return nil
         .          .    142:		}
         .          .    143:	case nil:
         .          .    144:		switch d := dest.(type) {
         .          .    145:		case *interface{}:
         .          .    146:			if d == nil {
         .          .    147:				return errNilPtr
         .          .    148:			}
         .          .    149:			*d = nil
         .          .    150:			return nil
         .          .    151:		case *[]byte:
         .          .    152:			if d == nil {
         .          .    153:				return errNilPtr
         .          .    154:			}
         .          .    155:			*d = nil
         .          .    156:			return nil
         .          .    157:		case *RawBytes:
         .          .    158:			if d == nil {
         .          .    159:				return errNilPtr
         .          .    160:			}
         .          .    161:			*d = nil
         .          .    162:			return nil
         .          .    163:		}
         .          .    164:	}
         .          .    165:
      20ms       20ms    166:	var sv reflect.Value
         .          .    167:
      50ms       80ms    168:	switch d := dest.(type) {
         .          .    169:	case *string:
         .          .    170:		sv = reflect.ValueOf(src)
         .          .    171:		switch sv.Kind() {
         .          .    172:		case reflect.Bool,
         .          .    173:			reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
         .          .    174:			reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
         .          .    175:			reflect.Float32, reflect.Float64:
         .          .    176:			*d = asString(src)
         .          .    177:			return nil
         .          .    178:		}
         .          .    179:	case *[]byte:
         .          .    180:		sv = reflect.ValueOf(src)
         .          .    181:		if b, ok := asBytes(nil, sv); ok {
         .          .    182:			*d = b
         .          .    183:			return nil
         .          .    184:		}
         .          .    185:	case *RawBytes:
         .          .    186:		sv = reflect.ValueOf(src)
         .          .    187:		if b, ok := asBytes([]byte(*d)[:0], sv); ok {
         .          .    188:			*d = RawBytes(b)
         .          .    189:			return nil
         .          .    190:		}
         .          .    191:	case *bool:
         .          .    192:		bv, err := driver.Bool.ConvertValue(src)
         .          .    193:		if err == nil {
         .          .    194:			*d = bv.(bool)
         .          .    195:		}
         .          .    196:		return err
         .          .    197:	case *interface{}:
         .          .    198:		*d = src
         .          .    199:		return nil
         .          .    200:	}
         .          .    201:
      60ms      500ms    202:	if scanner, ok := dest.(Scanner); ok {
         .          .    203:		return scanner.Scan(src)
         .          .    204:	}
         .          .    205:
      70ms      240ms    206:	dpv := reflect.ValueOf(dest)
      70ms       70ms    207:	if dpv.Kind() != reflect.Ptr {
         .          .    208:		return errors.New("destination not a pointer")
         .          .    209:	}
      50ms      140ms    210:	if dpv.IsNil() {
         .          .    211:		return errNilPtr
         .          .    212:	}
         .          .    213:
      20ms       20ms    214:	if !sv.IsValid() {
      50ms      230ms    215:		sv = reflect.ValueOf(src)
         .          .    216:	}
         .          .    217:
     100ms      340ms    218:	dv := reflect.Indirect(dpv)
     280ms      920ms    219:	if sv.IsValid() && sv.Type().AssignableTo(dv.Type()) {
      20ms      390ms    220:		dv.Set(sv)
      30ms       30ms    221:		return nil
         .          .    222:	}
         .          .    223:
      40ms       40ms    224:	if dv.Kind() == sv.Kind() && sv.Type().ConvertibleTo(dv.Type()) {
         .          .    225:		dv.Set(sv.Convert(dv.Type()))
         .          .    226:		return nil
         .          .    227:	}
         .          .    228:
      20ms       20ms    229:	switch dv.Kind() {
         .          .    230:	case reflect.Ptr:
         .          .    231:		if src == nil {
         .          .    232:			dv.Set(reflect.Zero(dv.Type()))
         .          .    233:			return nil
         .          .    234:		} else {
         .          .    235:			dv.Set(reflect.New(dv.Type().Elem()))
         .          .    236:			return convertAssign(dv.Interface(), src)
         .          .    237:		}
         .          .    238:	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
         .      1.52s    239:		s := asString(src)
     140ms      770ms    240:		i64, err := strconv.ParseInt(s, 10, dv.Type().Bits())
      10ms       10ms    241:		if err != nil {
         .          .    242:			err = strconvErr(err)
         .          .    243:			return fmt.Errorf("converting driver.Value type %T (%q) to a %s: %v", src, s, dv.Kind(), err)
         .          .    244:		}
      30ms      200ms    245:		dv.SetInt(i64)
      20ms       20ms    246:		return nil
         .          .    247:	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
         .          .    248:		s := asString(src)
         .          .    249:		u64, err := strconv.ParseUint(s, 10, dv.Type().Bits())
         .          .    250:		if err != nil {
         .          .    251:			err = strconvErr(err)
ROUTINE ======================== database/sql.driverArgs in /home/isucon/.local/go/src/database/sql/convert.go
      10ms      350ms (flat, cum)  0.63% of Total
         .          .     20:// driverArgs converts arguments from callers of Stmt.Exec and
         .          .     21:// Stmt.Query into driver Values.
         .          .     22://
         .          .     23:// The statement ds may be nil, if no statement is available.
         .          .     24:func driverArgs(ds *driverStmt, args []interface{}) ([]driver.Value, error) {
         .      210ms     25:	dargs := make([]driver.Value, len(args))
         .          .     26:	var si driver.Stmt
         .          .     27:	if ds != nil {
         .          .     28:		si = ds.si
         .          .     29:	}
      10ms       20ms     30:	cc, ok := si.(driver.ColumnConverter)
         .          .     31:
         .          .     32:	// Normal path, for a driver.Stmt that is not a ColumnConverter.
         .          .     33:	if !ok {
         .          .     34:		for n, arg := range args {
         .          .     35:			var err error
         .       20ms     36:			dargs[n], err = driver.DefaultParameterConverter.ConvertValue(arg)
         .          .     37:			if err != nil {
         .          .     38:				return nil, fmt.Errorf("sql: converting Exec argument #%d's type: %v", n, err)
         .          .     39:			}
         .          .     40:		}
         .          .     41:		return dargs, nil
         .          .     42:	}
         .          .     43:
         .          .     44:	// Let the Stmt convert its own arguments.
         .          .     45:	for n, arg := range args {
         .          .     46:		// First, see if the value itself knows how to convert
         .          .     47:		// itself to a driver type.  For example, a NullString
         .          .     48:		// struct changing into a string or nil.
         .       10ms     49:		if svi, ok := arg.(driver.Valuer); ok {
         .          .     50:			sv, err := svi.Value()
         .          .     51:			if err != nil {
         .          .     52:				return nil, fmt.Errorf("sql: argument index %d from Value: %v", n, err)
         .          .     53:			}
         .          .     54:			if !driver.IsValue(sv) {
         .          .     55:				return nil, fmt.Errorf("sql: argument index %d: non-subset type %T returned from Value", n, sv)
         .          .     56:			}
         .          .     57:			arg = sv
         .          .     58:		}
         .          .     59:
         .          .     60:		// Second, ask the column to sanity check itself. For
         .          .     61:		// example, drivers might use this to make sure that
         .          .     62:		// an int64 values being inserted into a 16-bit
         .          .     63:		// integer field is in range (before getting
         .          .     64:		// truncated), or that a nil can't go into a NOT NULL
         .          .     65:		// column before going across the network to get the
         .          .     66:		// same error.
         .          .     67:		var err error
         .       10ms     68:		ds.Lock()
         .       80ms     69:		dargs[n], err = cc.ColumnConverter(n).ConvertValue(arg)
         .          .     70:		ds.Unlock()
         .          .     71:		if err != nil {
         .          .     72:			return nil, fmt.Errorf("sql: converting argument #%d's type: %v", n, err)
         .          .     73:		}
         .          .     74:		if !driver.IsValue(dargs[n]) {
ROUTINE ======================== database/sql.resultFromStatement in /home/isucon/.local/go/src/database/sql/sql.go
         0       80ms (flat, cum)  0.14% of Total
         .          .   1497:		return nil, err
         .          .   1498:	}
         .          .   1499:
         .          .   1500:	ds.Lock()
         .          .   1501:	defer ds.Unlock()
         .       80ms   1502:	resi, err := ds.si.Exec(dargs)
         .          .   1503:	if err != nil {
         .          .   1504:		return nil, err
         .          .   1505:	}
         .          .   1506:	return driverResult{ds.Locker, resi}, nil
         .          .   1507:}
ROUTINE ======================== database/sql.rowsiFromStatement in /home/isucon/.local/go/src/database/sql/sql.go
      10ms      2.09s (flat, cum)  3.76% of Total
         .          .   1632:	}
         .          .   1633:	return nil, driver.ErrBadConn
         .          .   1634:}
         .          .   1635:
         .          .   1636:func rowsiFromStatement(ds driverStmt, args ...interface{}) (driver.Rows, error) {
         .       10ms   1637:	ds.Lock()
         .          .   1638:	want := ds.si.NumInput()
         .          .   1639:	ds.Unlock()
         .          .   1640:
         .          .   1641:	// -1 means the driver doesn't know how to count the number of
         .          .   1642:	// placeholders, so we won't sanity check input here and instead let the
         .          .   1643:	// driver deal with errors.
         .          .   1644:	if want != -1 && len(args) != want {
         .          .   1645:		return nil, fmt.Errorf("sql: statement expects %d inputs; got %d", want, len(args))
         .          .   1646:	}
         .          .   1647:
         .      320ms   1648:	dargs, err := driverArgs(&ds, args)
         .          .   1649:	if err != nil {
         .          .   1650:		return nil, err
         .          .   1651:	}
         .          .   1652:
         .          .   1653:	ds.Lock()
      10ms      1.75s   1654:	rowsi, err := ds.si.Query(dargs)
         .       10ms   1655:	ds.Unlock()
         .          .   1656:	if err != nil {
         .          .   1657:		return nil, err
         .          .   1658:	}
         .          .   1659:	return rowsi, nil
         .          .   1660:}
ROUTINE ======================== database/sql/driver.defaultConverter.ConvertValue in /home/isucon/.local/go/src/database/sql/driver/types.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    229:			return nil, fmt.Errorf("non-Value type %T returned from Value", sv)
         .          .    230:		}
         .          .    231:		return sv, nil
         .          .    232:	}
         .          .    233:
         .       10ms    234:	rv := reflect.ValueOf(v)
         .          .    235:	switch rv.Kind() {
         .          .    236:	case reflect.Ptr:
         .          .    237:		// indirect pointers
         .          .    238:		if rv.IsNil() {
         .          .    239:			return nil, nil
         .          .    240:		} else {
         .          .    241:			return defaultConverter{}.ConvertValue(rv.Elem().Interface())
         .          .    242:		}
         .          .    243:	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
         .       10ms    244:		return rv.Int(), nil
         .          .    245:	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32:
         .          .    246:		return int64(rv.Uint()), nil
         .          .    247:	case reflect.Uint64:
         .          .    248:		u64 := rv.Uint()
         .          .    249:		if u64 >= 1<<63 {
ROUTINE ======================== encoding/gob.(*Decoder).Decode in /home/isucon/.local/go/src/encoding/gob/decoder.go
         0      110ms (flat, cum)   0.2% of Total
         .          .    180:	// get back to the caller.  Make sure it's a pointer.
         .          .    181:	if value.Type().Kind() != reflect.Ptr {
         .          .    182:		dec.err = errors.New("gob: attempt to decode into a non-pointer")
         .          .    183:		return dec.err
         .          .    184:	}
         .      110ms    185:	return dec.DecodeValue(value)
         .          .    186:}
         .          .    187:
         .          .    188:// DecodeValue reads the next value from the input stream.
         .          .    189:// If v is the zero reflect.Value (v.Kind() == Invalid), DecodeValue discards the value.
         .          .    190:// Otherwise, it stores the value into v.  In that case, v must represent
ROUTINE ======================== encoding/gob.(*Decoder).DecodeValue in /home/isucon/.local/go/src/encoding/gob/decoder.go
         0      110ms (flat, cum)   0.2% of Total
         .          .    203:	dec.mutex.Lock()
         .          .    204:	defer dec.mutex.Unlock()
         .          .    205:
         .          .    206:	dec.buf.Reset() // In case data lingers from previous invocation.
         .          .    207:	dec.err = nil
         .       70ms    208:	id := dec.decodeTypeSequence(false)
         .          .    209:	if dec.err == nil {
         .       40ms    210:		dec.decodeValue(id, v)
         .          .    211:	}
         .          .    212:	return dec.err
         .          .    213:}
         .          .    214:
         .          .    215:// If debug.go is compiled into the program , debugFunc prints a human-readable
ROUTINE ======================== encoding/gob.(*Decoder).compatibleType in /home/isucon/.local/go/src/encoding/gob/decode.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .    965:// Structs are considered ok; fields will be checked later.
         .          .    966:func (dec *Decoder) compatibleType(fr reflect.Type, fw typeId, inProgress map[reflect.Type]typeId) bool {
         .          .    967:	if rhs, ok := inProgress[fr]; ok {
         .          .    968:		return rhs == fw
         .          .    969:	}
         .       10ms    970:	inProgress[fr] = fw
         .          .    971:	ut := userType(fr)
         .          .    972:	wire, ok := dec.wireType[fw]
         .          .    973:	// If wire was encoded with an encoding method, fr must have that method.
         .          .    974:	// And if not, it must not.
         .          .    975:	// At most one of the booleans in ut is set.
         .          .    976:	// We could possibly relax this constraint in the future in order to
         .          .    977:	// choose the decoding method using the data in the wireType.
         .          .    978:	// The parentheses look odd but are correct.
         .          .    979:	if (ut.externalDec == xGob) != (ok && wire.GobEncoderT != nil) ||
         .          .    980:		(ut.externalDec == xBinary) != (ok && wire.BinaryMarshalerT != nil) ||
      10ms       10ms    981:		(ut.externalDec == xText) != (ok && wire.TextMarshalerT != nil) {
         .          .    982:		return false
         .          .    983:	}
         .          .    984:	if ut.externalDec != 0 { // This test trumps all others.
         .          .    985:		return true
         .          .    986:	}
ROUTINE ======================== encoding/gob.(*Decoder).compileDec in /home/isucon/.local/go/src/encoding/gob/decode.go
         0      130ms (flat, cum)  0.23% of Total
         .          .   1076:}
         .          .   1077:
         .          .   1078:// compileDec compiles the decoder engine for a value.  If the value is not a struct,
         .          .   1079:// it calls out to compileSingle.
         .          .   1080:func (dec *Decoder) compileDec(remoteId typeId, ut *userTypeInfo) (engine *decEngine, err error) {
         .       20ms   1081:	defer catchError(&err)
         .          .   1082:	rt := ut.base
         .          .   1083:	srt := rt
         .          .   1084:	if srt.Kind() != reflect.Struct || ut.externalDec != 0 {
         .       10ms   1085:		return dec.compileSingle(remoteId, ut)
         .          .   1086:	}
         .          .   1087:	var wireStruct *structType
         .          .   1088:	// Builtin types can come from global pool; the rest must be defined by the decoder.
         .          .   1089:	// Also we know we're decoding a struct now, so the client must have sent one.
         .          .   1090:	if t, ok := builtinIdToType[remoteId]; ok {
         .          .   1091:		wireStruct, _ = t.(*structType)
         .          .   1092:	} else {
         .          .   1093:		wire := dec.wireType[remoteId]
         .          .   1094:		if wire == nil {
         .          .   1095:			error_(errBadType)
         .          .   1096:		}
         .          .   1097:		wireStruct = wire.StructT
         .          .   1098:	}
         .          .   1099:	if wireStruct == nil {
         .          .   1100:		errorf("type mismatch in decoder: want struct type %s; got non-struct", rt)
         .          .   1101:	}
         .       10ms   1102:	engine = new(decEngine)
         .       10ms   1103:	engine.instr = make([]decInstr, len(wireStruct.Field))
         .          .   1104:	seen := make(map[reflect.Type]*decOp)
         .          .   1105:	// Loop over the fields of the wire type.
         .          .   1106:	for fieldnum := 0; fieldnum < len(wireStruct.Field); fieldnum++ {
         .          .   1107:		wireField := wireStruct.Field[fieldnum]
         .          .   1108:		if wireField.Name == "" {
         .          .   1109:			errorf("empty name for remote field of type %s", wireStruct.Name)
         .          .   1110:		}
         .          .   1111:		ovfl := overflow(wireField.Name)
         .          .   1112:		// Find the field of the local type with the same name.
         .          .   1113:		localField, present := srt.FieldByName(wireField.Name)
         .          .   1114:		// TODO(r): anonymous names
         .          .   1115:		if !present || !isExported(wireField.Name) {
         .          .   1116:			op := dec.decIgnoreOpFor(wireField.Id, make(map[typeId]*decOp))
         .          .   1117:			engine.instr[fieldnum] = decInstr{*op, fieldnum, nil, ovfl}
         .          .   1118:			continue
         .          .   1119:		}
         .       10ms   1120:		if !dec.compatibleType(localField.Type, wireField.Id, make(map[reflect.Type]typeId)) {
         .          .   1121:			errorf("wrong type (%s) for received field %s.%s", localField.Type, wireStruct.Name, wireField.Name)
         .          .   1122:		}
         .       70ms   1123:		op := dec.decOpFor(wireField.Id, localField.Type, localField.Name, seen)
         .          .   1124:		engine.instr[fieldnum] = decInstr{*op, fieldnum, localField.Index, ovfl}
         .          .   1125:		engine.numInstr++
         .          .   1126:	}
         .          .   1127:	return
         .          .   1128:}
ROUTINE ======================== encoding/gob.(*Decoder).compileSingle in /home/isucon/.local/go/src/encoding/gob/decode.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   1047:func (dec *Decoder) compileSingle(remoteId typeId, ut *userTypeInfo) (engine *decEngine, err error) {
         .          .   1048:	rt := ut.user
         .          .   1049:	engine = new(decEngine)
         .          .   1050:	engine.instr = make([]decInstr, 1) // one item
         .          .   1051:	name := rt.String()                // best we can do
         .       10ms   1052:	if !dec.compatibleType(rt, remoteId, make(map[reflect.Type]typeId)) {
         .          .   1053:		remoteType := dec.typeString(remoteId)
         .          .   1054:		// Common confusing case: local interface type, remote concrete type.
         .          .   1055:		if ut.base.Kind() == reflect.Interface && remoteId != tInterface {
         .          .   1056:			return nil, errors.New("gob: local interface type " + name + " can only be decoded from remote interface type; received concrete type " + remoteType)
         .          .   1057:		}
ROUTINE ======================== encoding/gob.(*Decoder).decOpFor in /home/isucon/.local/go/src/encoding/gob/decode.go
      10ms      100ms (flat, cum)  0.18% of Total
         .          .    824:			ovfl := overflow(name)
         .          .    825:			op = func(i *decInstr, state *decoderState, value reflect.Value) {
         .          .    826:				state.dec.decodeMap(t, state, value, *keyOp, *elemOp, ovfl)
         .          .    827:			}
         .          .    828:
      10ms       10ms    829:		case reflect.Slice:
         .          .    830:			name = "element of " + name
         .          .    831:			if t.Elem().Kind() == reflect.Uint8 {
         .          .    832:				op = decUint8Slice
         .          .    833:				break
         .          .    834:			}
         .          .    835:			var elemId typeId
         .          .    836:			if tt, ok := builtinIdToType[wireId]; ok {
         .          .    837:				elemId = tt.(*sliceType).Elem
         .          .    838:			} else {
         .          .    839:				elemId = dec.wireType[wireId].SliceT.Elem
         .          .    840:			}
         .       20ms    841:			elemOp := dec.decOpFor(elemId, t.Elem(), name, inProgress)
         .          .    842:			ovfl := overflow(name)
         .          .    843:			helper := decSliceHelper[t.Elem().Kind()]
         .          .    844:			op = func(i *decInstr, state *decoderState, value reflect.Value) {
         .          .    845:				state.dec.decodeSlice(state, value, *elemOp, ovfl, helper)
         .          .    846:			}
         .          .    847:
         .          .    848:		case reflect.Struct:
         .          .    849:			// Generate a closure that calls out to the engine for the nested type.
         .       10ms    850:			ut := userType(typ)
         .       60ms    851:			enginePtr, err := dec.getDecEnginePtr(wireId, ut)
         .          .    852:			if err != nil {
         .          .    853:				error_(err)
         .          .    854:			}
         .          .    855:			op = func(i *decInstr, state *decoderState, value reflect.Value) {
         .          .    856:				// indirect through enginePtr to delay evaluation for recursive structs.
ROUTINE ======================== encoding/gob.(*Decoder).decOpFor.func2 in /home/isucon/.local/go/src/encoding/gob/decode.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    821:			elemId := dec.wireType[wireId].MapT.Elem
         .          .    822:			keyOp := dec.decOpFor(keyId, t.Key(), "key of "+name, inProgress)
         .          .    823:			elemOp := dec.decOpFor(elemId, t.Elem(), "element of "+name, inProgress)
         .          .    824:			ovfl := overflow(name)
         .          .    825:			op = func(i *decInstr, state *decoderState, value reflect.Value) {
         .       10ms    826:				state.dec.decodeMap(t, state, value, *keyOp, *elemOp, ovfl)
         .          .    827:			}
         .          .    828:
         .          .    829:		case reflect.Slice:
         .          .    830:			name = "element of " + name
         .          .    831:			if t.Elem().Kind() == reflect.Uint8 {
ROUTINE ======================== encoding/gob.(*Decoder).decOpFor.func5 in /home/isucon/.local/go/src/encoding/gob/decode.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    856:				// indirect through enginePtr to delay evaluation for recursive structs.
         .          .    857:				dec.decodeStruct(*enginePtr, ut, value)
         .          .    858:			}
         .          .    859:		case reflect.Interface:
         .          .    860:			op = func(i *decInstr, state *decoderState, value reflect.Value) {
         .       10ms    861:				state.dec.decodeInterface(t, state, value)
         .          .    862:			}
         .          .    863:		}
         .          .    864:	}
         .          .    865:	if op == nil {
         .          .    866:		errorf("decode can't handle type %s", rt)
ROUTINE ======================== encoding/gob.(*Decoder).decodeInterface in /home/isucon/.local/go/src/encoding/gob/decode.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    681:	// Tread carefully; it might not satisfy the interface.
         .          .    682:	if !typ.AssignableTo(ityp) {
         .          .    683:		errorf("%s is not assignable to type %s", typ, ityp)
         .          .    684:	}
         .          .    685:	// Copy the interface value to the target.
         .       10ms    686:	value.Set(v)
         .          .    687:}
         .          .    688:
         .          .    689:// ignoreInterface discards the data for an interface value with no destination.
         .          .    690:func (dec *Decoder) ignoreInterface(state *decoderState) {
         .          .    691:	// Read the name of the concrete type.
ROUTINE ======================== encoding/gob.(*Decoder).decodeMap in /home/isucon/.local/go/src/encoding/gob/decode.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    567:	}
         .          .    568:	n := int(state.decodeUint())
         .          .    569:	keyIsPtr := mtyp.Key().Kind() == reflect.Ptr
         .          .    570:	elemIsPtr := mtyp.Elem().Kind() == reflect.Ptr
         .          .    571:	for i := 0; i < n; i++ {
         .       10ms    572:		key := decodeIntoValue(state, keyOp, keyIsPtr, allocValue(mtyp.Key()), ovfl)
         .          .    573:		elem := decodeIntoValue(state, elemOp, elemIsPtr, allocValue(mtyp.Elem()), ovfl)
         .          .    574:		value.SetMapIndex(key, elem)
         .          .    575:	}
         .          .    576:}
         .          .    577:
ROUTINE ======================== encoding/gob.(*Decoder).decodeSingle in /home/isucon/.local/go/src/encoding/gob/decode.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    436:	state.fieldnum = singletonField
         .          .    437:	if state.decodeUint() != 0 {
         .          .    438:		errorf("decode: corrupted data: non-zero delta for singleton")
         .          .    439:	}
         .          .    440:	instr := &engine.instr[singletonField]
         .       10ms    441:	instr.op(instr, state, value)
         .          .    442:}
         .          .    443:
         .          .    444:// decodeStruct decodes a top-level struct and stores it in value.
         .          .    445:// Indir is for the value, not the type.  At the time of the call it may
         .          .    446:// differ from ut.indir, which was computed when the engine was built.
ROUTINE ======================== encoding/gob.(*Decoder).decodeTypeSequence in /home/isucon/.local/go/src/encoding/gob/decoder.go
         0       70ms (flat, cum)  0.13% of Total
         .          .    146:		if id >= 0 {
         .          .    147:			// Value follows.
         .          .    148:			return id
         .          .    149:		}
         .          .    150:		// Type definition for (-id) follows.
         .       70ms    151:		dec.recvType(-id)
         .          .    152:		// When decoding an interface, after a type there may be a
         .          .    153:		// DelimitedValue still in the buffer.  Skip its count.
         .          .    154:		// (Alternatively, the buffer is empty and the byte count
         .          .    155:		// will be absorbed by recvMessage.)
         .          .    156:		if dec.buf.Len() > 0 {
ROUTINE ======================== encoding/gob.(*Decoder).decodeValue in /home/isucon/.local/go/src/encoding/gob/decode.go
         0      110ms (flat, cum)   0.2% of Total
         .          .   1182:	}
         .          .   1183:	// Dereference down to the underlying type.
         .          .   1184:	ut := userType(value.Type())
         .          .   1185:	base := ut.base
         .          .   1186:	var enginePtr **decEngine
         .      100ms   1187:	enginePtr, dec.err = dec.getDecEnginePtr(wireId, ut)
         .          .   1188:	if dec.err != nil {
         .          .   1189:		return
         .          .   1190:	}
         .          .   1191:	value = decAlloc(value)
         .          .   1192:	engine := *enginePtr
         .          .   1193:	if st := base; st.Kind() == reflect.Struct && ut.externalDec == 0 {
         .          .   1194:		wt := dec.wireType[wireId]
         .          .   1195:		if engine.numInstr == 0 && st.NumField() > 0 &&
         .          .   1196:			wt != nil && len(wt.StructT.Field) > 0 {
         .          .   1197:			name := base.Name()
         .          .   1198:			errorf("type mismatch: no fields matched compiling decoder for %s", name)
         .          .   1199:		}
         .          .   1200:		dec.decodeStruct(engine, ut, value)
         .          .   1201:	} else {
         .       10ms   1202:		dec.decodeSingle(engine, ut, value)
         .          .   1203:	}
         .          .   1204:}
         .          .   1205:
         .          .   1206:// decodeIgnoredValue decodes the data stream representing a value of the specified type and discards it.
         .          .   1207:func (dec *Decoder) decodeIgnoredValue(wireId typeId) {
ROUTINE ======================== encoding/gob.(*Decoder).getDecEnginePtr in /home/isucon/.local/go/src/encoding/gob/decode.go
         0      100ms (flat, cum)  0.18% of Total
         .          .   1131:func (dec *Decoder) getDecEnginePtr(remoteId typeId, ut *userTypeInfo) (enginePtr **decEngine, err error) {
         .          .   1132:	rt := ut.user
         .          .   1133:	decoderMap, ok := dec.decoderCache[rt]
         .          .   1134:	if !ok {
         .          .   1135:		decoderMap = make(map[typeId]**decEngine)
         .       20ms   1136:		dec.decoderCache[rt] = decoderMap
         .          .   1137:	}
         .          .   1138:	if enginePtr, ok = decoderMap[remoteId]; !ok {
         .          .   1139:		// To handle recursive types, mark this engine as underway before compiling.
         .          .   1140:		enginePtr = new(*decEngine)
         .          .   1141:		decoderMap[remoteId] = enginePtr
         .       80ms   1142:		*enginePtr, err = dec.compileDec(remoteId, ut)
         .          .   1143:		if err != nil {
         .          .   1144:			delete(decoderMap, remoteId)
         .          .   1145:		}
         .          .   1146:	}
         .          .   1147:	return
ROUTINE ======================== encoding/gob.(*Decoder).recvType in /home/isucon/.local/go/src/encoding/gob/decoder.go
         0       70ms (flat, cum)  0.13% of Total
         .          .     57:		return
         .          .     58:	}
         .          .     59:
         .          .     60:	// Type:
         .          .     61:	wire := new(wireType)
         .       70ms     62:	dec.decodeValue(tWireType, reflect.ValueOf(wire))
         .          .     63:	if dec.err != nil {
         .          .     64:		return
         .          .     65:	}
         .          .     66:	// Remember we've seen this type.
         .          .     67:	dec.wireType[id] = wire
ROUTINE ======================== encoding/gob.(*Encoder).Encode in /home/isucon/.local/go/src/encoding/gob/encoder.go
         0       40ms (flat, cum) 0.072% of Total
         .          .    169:}
         .          .    170:
         .          .    171:// Encode transmits the data item represented by the empty interface value,
         .          .    172:// guaranteeing that all necessary type information has been transmitted first.
         .          .    173:func (enc *Encoder) Encode(e interface{}) error {
         .       40ms    174:	return enc.EncodeValue(reflect.ValueOf(e))
         .          .    175:}
         .          .    176:
         .          .    177:// sendTypeDescriptor makes sure the remote side knows about this type.
         .          .    178:// It will send a descriptor if this is the first time the type has been
         .          .    179:// sent.
ROUTINE ======================== encoding/gob.(*Encoder).EncodeValue in /home/isucon/.local/go/src/encoding/gob/encoder.go
         0       40ms (flat, cum) 0.072% of Total
         .          .    235:	enc.err = nil
         .          .    236:	enc.byteBuf.Reset()
         .          .    237:	enc.byteBuf.Write(spaceForLength)
         .          .    238:	state := enc.newEncoderState(&enc.byteBuf)
         .          .    239:
         .       10ms    240:	enc.sendTypeDescriptor(enc.writer(), state, ut)
         .          .    241:	enc.sendTypeId(state, ut)
         .          .    242:	if enc.err != nil {
         .          .    243:		return enc.err
         .          .    244:	}
         .          .    245:
         .          .    246:	// Encode the object.
         .       30ms    247:	enc.encode(state.b, value, ut)
         .          .    248:	if enc.err == nil {
         .          .    249:		enc.writeMessage(enc.writer(), state.b)
         .          .    250:	}
         .          .    251:
         .          .    252:	enc.freeEncoderState(state)
ROUTINE ======================== encoding/gob.(*Encoder).encode in /home/isucon/.local/go/src/encoding/gob/encode.go
         0       40ms (flat, cum) 0.072% of Total
         .          .    702:	}
         .          .    703:	for i := 0; i < indir; i++ {
         .          .    704:		value = reflect.Indirect(value)
         .          .    705:	}
         .          .    706:	if ut.externalEnc == 0 && value.Type().Kind() == reflect.Struct {
         .       10ms    707:		enc.encodeStruct(b, engine, value)
         .          .    708:	} else {
         .       30ms    709:		enc.encodeSingle(b, engine, value)
         .          .    710:	}
         .          .    711:}
ROUTINE ======================== encoding/gob.(*Encoder).encodeMap in /home/isucon/.local/go/src/encoding/gob/encode.go
      10ms       30ms (flat, cum) 0.054% of Total
         .          .    372:// encodeMap encodes a map as unsigned count followed by key:value pairs.
         .          .    373:func (enc *Encoder) encodeMap(b *encBuffer, mv reflect.Value, keyOp, elemOp encOp, keyIndir, elemIndir int) {
         .          .    374:	state := enc.newEncoderState(b)
         .          .    375:	state.fieldnum = -1
         .          .    376:	state.sendZero = true
      10ms       20ms    377:	keys := mv.MapKeys()
         .          .    378:	state.encodeUint(uint64(len(keys)))
         .          .    379:	for _, key := range keys {
         .       10ms    380:		encodeReflectValue(state, key, keyOp, keyIndir)
         .          .    381:		encodeReflectValue(state, mv.MapIndex(key), elemOp, elemIndir)
         .          .    382:	}
         .          .    383:	enc.freeEncoderState(state)
         .          .    384:}
         .          .    385:
ROUTINE ======================== encoding/gob.(*Encoder).encodeSingle in /home/isucon/.local/go/src/encoding/gob/encode.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    302:	instr := &engine.instr[singletonField]
         .          .    303:	if instr.indir > 0 {
         .          .    304:		value = encIndirect(value, instr.indir)
         .          .    305:	}
         .          .    306:	if valid(value) {
         .       30ms    307:		instr.op(instr, state, value)
         .          .    308:	}
         .          .    309:}
         .          .    310:
         .          .    311:// encodeStruct encodes a single struct value.
         .          .    312:func (enc *Encoder) encodeStruct(b *encBuffer, engine *encEngine, value reflect.Value) {
ROUTINE ======================== encoding/gob.(*Encoder).encodeStruct in /home/isucon/.local/go/src/encoding/gob/encode.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    312:func (enc *Encoder) encodeStruct(b *encBuffer, engine *encEngine, value reflect.Value) {
         .          .    313:	if !valid(value) {
         .          .    314:		return
         .          .    315:	}
         .          .    316:	state := enc.newEncoderState(b)
         .       10ms    317:	defer enc.freeEncoderState(state)
         .          .    318:	state.fieldnum = -1
         .          .    319:	for i := 0; i < len(engine.instr); i++ {
         .          .    320:		instr := &engine.instr[i]
         .          .    321:		if i >= value.NumField() {
         .          .    322:			// encStructTerminator
         .          .    323:			instr.op(instr, state, reflect.Value{})
         .          .    324:			break
         .          .    325:		}
         .          .    326:		field := value.FieldByIndex(instr.index)
         .          .    327:		if instr.indir > 0 {
         .          .    328:			field = encIndirect(field, instr.indir)
         .          .    329:			// TODO: Is field guaranteed valid? If so we could avoid this check.
         .          .    330:			if !valid(field) {
         .          .    331:				continue
         .          .    332:			}
         .          .    333:		}
         .       10ms    334:		instr.op(instr, state, field)
         .          .    335:	}
         .          .    336:}
         .          .    337:
         .          .    338:// encodeArray encodes an array.
         .          .    339:func (enc *Encoder) encodeArray(b *encBuffer, value reflect.Value, op encOp, elemIndir int, length int, helper encHelper) {
ROUTINE ======================== encoding/gob.(*Encoder).sendActualType in /home/isucon/.local/go/src/encoding/gob/encoder.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    100:	}
         .          .    101:	// Send the pair (-id, type)
         .          .    102:	// Id:
         .          .    103:	state.encodeInt(-int64(info.id))
         .          .    104:	// Type:
         .       10ms    105:	enc.encode(state.b, reflect.ValueOf(info.wire), wireTypeUserInfo)
         .          .    106:	enc.writeMessage(w, state.b)
         .          .    107:	if enc.err != nil {
         .          .    108:		return
         .          .    109:	}
         .          .    110:
ROUTINE ======================== encoding/gob.(*Encoder).sendType in /home/isucon/.local/go/src/encoding/gob/encoder.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    163:	case reflect.Chan, reflect.Func:
         .          .    164:		// If we get here, it's a field of a struct; ignore it.
         .          .    165:		return
         .          .    166:	}
         .          .    167:
         .       10ms    168:	return enc.sendActualType(w, state, ut, ut.base)
         .          .    169:}
         .          .    170:
         .          .    171:// Encode transmits the data item represented by the empty interface value,
         .          .    172:// guaranteeing that all necessary type information has been transmitted first.
         .          .    173:func (enc *Encoder) Encode(e interface{}) error {
ROUTINE ======================== encoding/gob.(*Encoder).sendTypeDescriptor in /home/isucon/.local/go/src/encoding/gob/encoder.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    184:	if ut.externalEnc != 0 {
         .          .    185:		rt = ut.user
         .          .    186:	}
         .          .    187:	if _, alreadySent := enc.sent[rt]; !alreadySent {
         .          .    188:		// No, so send it.
         .       10ms    189:		sent := enc.sendType(w, state, rt)
         .          .    190:		if enc.err != nil {
         .          .    191:			return
         .          .    192:		}
         .          .    193:		// If the type info has still not been transmitted, it means we have
         .          .    194:		// a singleton basic type (int, []byte etc.) at top level.  We don't
ROUTINE ======================== encoding/gob.decodeIntoValue in /home/isucon/.local/go/src/encoding/gob/decode.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    550:	instr := &decInstr{op, 0, nil, ovfl}
         .          .    551:	v := value
         .          .    552:	if isPtr {
         .          .    553:		v = decAlloc(value)
         .          .    554:	}
         .       10ms    555:	op(instr, state, v)
         .          .    556:	return value
         .          .    557:}
         .          .    558:
         .          .    559:// decodeMap decodes a map and stores it in value.
         .          .    560:// Maps are encoded as a length followed by key:value pairs.
ROUTINE ======================== encoding/gob.encOpFor.func3 in /home/isucon/.local/go/src/encoding/gob/encode.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    572:				// receiver might want to use the map.  (Maps don't use append.)
         .          .    573:				if !state.sendZero && mv.IsNil() {
         .          .    574:					return
         .          .    575:				}
         .          .    576:				state.update(i)
         .       30ms    577:				state.enc.encodeMap(state.b, mv, *keyOp, *elemOp, keyIndir, elemIndir)
         .          .    578:			}
         .          .    579:		case reflect.Struct:
         .          .    580:			// Generate a closure that calls out to the engine for the nested type.
         .          .    581:			getEncEngine(userType(typ), building)
         .          .    582:			info := mustGetTypeInfo(typ)
ROUTINE ======================== encoding/gob.encOpFor.func4 in /home/isucon/.local/go/src/encoding/gob/encode.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    582:			info := mustGetTypeInfo(typ)
         .          .    583:			op = func(i *encInstr, state *encoderState, sv reflect.Value) {
         .          .    584:				state.update(i)
         .          .    585:				// indirect through info to delay evaluation for recursive structs
         .          .    586:				enc := info.encoder.Load().(*encEngine)
         .       10ms    587:				state.enc.encodeStruct(state.b, enc, sv)
         .          .    588:			}
         .          .    589:		case reflect.Interface:
         .          .    590:			op = func(i *encInstr, state *encoderState, iv reflect.Value) {
         .          .    591:				if !state.sendZero && (!iv.IsValid() || iv.IsNil()) {
         .          .    592:					return
ROUTINE ======================== encoding/gob.encOpFor.func5 in /home/isucon/.local/go/src/encoding/gob/encode.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    589:		case reflect.Interface:
         .          .    590:			op = func(i *encInstr, state *encoderState, iv reflect.Value) {
         .          .    591:				if !state.sendZero && (!iv.IsValid() || iv.IsNil()) {
         .          .    592:					return
         .          .    593:				}
      10ms       10ms    594:				state.update(i)
         .          .    595:				state.enc.encodeInterface(state.b, iv)
         .          .    596:			}
         .          .    597:		}
         .          .    598:	}
         .          .    599:	if op == nil {
ROUTINE ======================== encoding/gob.encodeReflectValue in /home/isucon/.local/go/src/encoding/gob/encode.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    364:		v = reflect.Indirect(v)
         .          .    365:	}
         .          .    366:	if !v.IsValid() {
         .          .    367:		errorf("encodeReflectValue: nil element")
         .          .    368:	}
         .       10ms    369:	op(nil, state, v)
         .          .    370:}
         .          .    371:
         .          .    372:// encodeMap encodes a map as unsigned count followed by key:value pairs.
         .          .    373:func (enc *Encoder) encodeMap(b *encBuffer, mv reflect.Value, keyOp, elemOp encOp, keyIndir, elemIndir int) {
         .          .    374:	state := enc.newEncoderState(b)
ROUTINE ======================== encoding/gob.userType in /home/isucon/.local/go/src/encoding/gob/type.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    157:}
         .          .    158:
         .          .    159:// userType returns, and saves, the information associated with user-provided type rt.
         .          .    160:// If the user type is not valid, it calls error.
         .          .    161:func userType(rt reflect.Type) *userTypeInfo {
         .       10ms    162:	ut, err := validUserType(rt)
         .          .    163:	if err != nil {
         .          .    164:		error_(err)
         .          .    165:	}
         .          .    166:	return ut
         .          .    167:}
ROUTINE ======================== encoding/gob.validUserType in /home/isucon/.local/go/src/encoding/gob/type.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     46:// validType returns, and saves, the information associated with user-provided type rt.
         .          .     47:// If the user type is not valid, err will be non-nil.  To be used when the error handler
         .          .     48:// is not set up.
         .          .     49:func validUserType(rt reflect.Type) (ut *userTypeInfo, err error) {
         .          .     50:	userTypeLock.RLock()
         .       10ms     51:	ut = userTypeCache[rt]
         .          .     52:	userTypeLock.RUnlock()
         .          .     53:	if ut != nil {
         .          .     54:		return
         .          .     55:	}
         .          .     56:	// Now set the value under the write lock.
ROUTINE ======================== fmt.(*fmt).fmt_q in /home/isucon/.local/go/src/fmt/format.go
         0       40ms (flat, cum) 0.072% of Total
         .          .    373:		quoted = "`" + s + "`"
         .          .    374:	} else {
         .          .    375:		if f.plus {
         .          .    376:			quoted = strconv.QuoteToASCII(s)
         .          .    377:		} else {
         .       40ms    378:			quoted = strconv.Quote(s)
         .          .    379:		}
         .          .    380:	}
         .          .    381:	f.padString(quoted)
         .          .    382:}
         .          .    383:
ROUTINE ======================== fmt.(*fmt).fmt_s in /home/isucon/.local/go/src/fmt/format.go
      10ms       30ms (flat, cum) 0.054% of Total
         .          .    317:}
         .          .    318:
         .          .    319:// fmt_s formats a string.
         .          .    320:func (f *fmt) fmt_s(s string) {
         .          .    321:	s = f.truncate(s)
      10ms       30ms    322:	f.padString(s)
         .          .    323:}
         .          .    324:
         .          .    325:// fmt_sbx formats a string or byte slice as a hexadecimal encoding of its bytes.
         .          .    326:func (f *fmt) fmt_sbx(s string, b []byte, digits string) {
         .          .    327:	n := len(b)
ROUTINE ======================== fmt.(*fmt).padString in /home/isucon/.local/go/src/fmt/format.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    125:}
         .          .    126:
         .          .    127:// padString appends s to buf, padded on left (w > 0) or right (w < 0 or f.minus).
         .          .    128:func (f *fmt) padString(s string) {
         .          .    129:	if !f.widPresent || f.wid == 0 {
         .       20ms    130:		f.buf.WriteString(s)
         .          .    131:		return
         .          .    132:	}
         .          .    133:	padding, left, right := f.computePadding(utf8.RuneCountInString(s))
         .          .    134:	if left > 0 {
         .          .    135:		f.writePadding(left, padding)
ROUTINE ======================== fmt.(*pp).doPrint in /home/isucon/.local/go/src/fmt/print.go
         0       20ms (flat, cum) 0.036% of Total
         .          .   1268:			isString := arg != nil && reflect.TypeOf(arg).Kind() == reflect.String
         .          .   1269:			if addspace || !isString && !prevString {
         .          .   1270:				p.buf.WriteByte(' ')
         .          .   1271:			}
         .          .   1272:		}
         .       20ms   1273:		prevString = p.printArg(arg, 'v', 0)
         .          .   1274:	}
         .          .   1275:	if addnewline {
         .          .   1276:		p.buf.WriteByte('\n')
         .          .   1277:	}
         .          .   1278:}
ROUTINE ======================== fmt.(*pp).doPrintf in /home/isucon/.local/go/src/fmt/print.go
      40ms      140ms (flat, cum)  0.25% of Total
         .          .   1104:	afterIndex := false // previous item in format was an index like [3].
         .          .   1105:	p.reordered = false
         .          .   1106:	for i := 0; i < end; {
         .          .   1107:		p.goodArgNum = true
         .          .   1108:		lasti := i
      10ms       10ms   1109:		for i < end && format[i] != '%' {
         .          .   1110:			i++
         .          .   1111:		}
         .          .   1112:		if i > lasti {
         .       10ms   1113:			p.buf.WriteString(format[lasti:i])
         .          .   1114:		}
         .          .   1115:		if i >= end {
         .          .   1116:			// done processing format string
         .          .   1117:			break
         .          .   1118:		}
         .          .   1119:
         .          .   1120:		// Process one verb
         .          .   1121:		i++
         .          .   1122:
         .          .   1123:		// Do we have flags?
         .          .   1124:		p.fmt.clearflags()
         .          .   1125:	F:
         .          .   1126:		for ; i < end; i++ {
         .          .   1127:			switch format[i] {
         .          .   1128:			case '#':
         .          .   1129:				p.fmt.sharp = true
         .          .   1130:			case '0':
         .          .   1131:				p.fmt.zero = true
         .          .   1132:			case '+':
         .          .   1133:				p.fmt.plus = true
         .          .   1134:			case '-':
         .          .   1135:				p.fmt.minus = true
         .          .   1136:			case ' ':
         .          .   1137:				p.fmt.space = true
         .          .   1138:			default:
         .          .   1139:				break F
         .          .   1140:			}
         .          .   1141:		}
         .          .   1142:
         .          .   1143:		// Do we have an explicit argument index?
         .          .   1144:		argNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))
         .          .   1145:
         .          .   1146:		// Do we have width?
         .          .   1147:		if i < end && format[i] == '*' {
         .          .   1148:			i++
         .          .   1149:			p.fmt.wid, p.fmt.widPresent, argNum = intFromArg(a, argNum)
         .          .   1150:
         .          .   1151:			if !p.fmt.widPresent {
         .          .   1152:				p.buf.Write(badWidthBytes)
         .          .   1153:			}
         .          .   1154:
         .          .   1155:			// We have a negative width, so take its value and ensure
         .          .   1156:			// that the minus flag is set
         .          .   1157:			if p.fmt.wid < 0 {
         .          .   1158:				p.fmt.wid = -p.fmt.wid
         .          .   1159:				p.fmt.minus = true
         .          .   1160:			}
         .          .   1161:			afterIndex = false
         .          .   1162:		} else {
         .          .   1163:			p.fmt.wid, p.fmt.widPresent, i = parsenum(format, i, end)
         .          .   1164:			if afterIndex && p.fmt.widPresent { // "%[3]2d"
         .          .   1165:				p.goodArgNum = false
         .          .   1166:			}
         .          .   1167:		}
         .          .   1168:
         .          .   1169:		// Do we have precision?
      30ms       30ms   1170:		if i+1 < end && format[i] == '.' {
         .          .   1171:			i++
         .          .   1172:			if afterIndex { // "%[3].2d"
         .          .   1173:				p.goodArgNum = false
         .          .   1174:			}
         .          .   1175:			argNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))
         .          .   1176:			if i < end && format[i] == '*' {
         .          .   1177:				i++
         .          .   1178:				p.fmt.prec, p.fmt.precPresent, argNum = intFromArg(a, argNum)
         .          .   1179:				// Negative precision arguments don't make sense
         .          .   1180:				if p.fmt.prec < 0 {
         .          .   1181:					p.fmt.prec = 0
         .          .   1182:					p.fmt.precPresent = false
         .          .   1183:				}
         .          .   1184:				if !p.fmt.precPresent {
         .          .   1185:					p.buf.Write(badPrecBytes)
         .          .   1186:				}
         .          .   1187:				afterIndex = false
         .          .   1188:			} else {
         .          .   1189:				p.fmt.prec, p.fmt.precPresent, i = parsenum(format, i, end)
         .          .   1190:				if !p.fmt.precPresent {
         .          .   1191:					p.fmt.prec = 0
         .          .   1192:					p.fmt.precPresent = true
         .          .   1193:				}
         .          .   1194:			}
         .          .   1195:		}
         .          .   1196:
         .          .   1197:		if !afterIndex {
         .          .   1198:			argNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))
         .          .   1199:		}
         .          .   1200:
         .          .   1201:		if i >= end {
         .          .   1202:			p.buf.Write(noVerbBytes)
         .          .   1203:			continue
         .          .   1204:		}
         .          .   1205:		c, w := utf8.DecodeRuneInString(format[i:])
         .          .   1206:		i += w
         .          .   1207:		// percent is special - absorbs no operand
         .          .   1208:		if c == '%' {
         .          .   1209:			p.buf.WriteByte('%') // We ignore width and prec.
         .          .   1210:			continue
         .          .   1211:		}
         .          .   1212:		if !p.goodArgNum {
         .          .   1213:			p.buf.Write(percentBangBytes)
         .          .   1214:			p.add(c)
         .          .   1215:			p.buf.Write(badIndexBytes)
         .          .   1216:			continue
         .          .   1217:		} else if argNum >= len(a) { // out of operands
         .          .   1218:			p.buf.Write(percentBangBytes)
         .          .   1219:			p.add(c)
         .          .   1220:			p.buf.Write(missingBytes)
         .          .   1221:			continue
         .          .   1222:		}
         .          .   1223:		arg := a[argNum]
         .          .   1224:		argNum++
         .          .   1225:
         .          .   1226:		if c == 'v' {
         .          .   1227:			if p.fmt.sharp {
         .          .   1228:				// Go syntax. Set the flag in the fmt and clear the sharp flag.
         .          .   1229:				p.fmt.sharp = false
         .          .   1230:				p.fmt.sharpV = true
         .          .   1231:			}
         .          .   1232:			if p.fmt.plus {
         .          .   1233:				// Struct-field syntax. Set the flag in the fmt and clear the plus flag.
         .          .   1234:				p.fmt.plus = false
         .          .   1235:				p.fmt.plusV = true
         .          .   1236:			}
         .          .   1237:		}
         .       90ms   1238:		p.printArg(arg, c, 0)
         .          .   1239:	}
         .          .   1240:
         .          .   1241:	// Check for extra arguments unless the call accessed the arguments
         .          .   1242:	// out of order, in which case it's too expensive to detect if they've all
         .          .   1243:	// been used and arguably OK if they're not.
ROUTINE ======================== fmt.(*pp).fmtString in /home/isucon/.local/go/src/fmt/print.go
      10ms       80ms (flat, cum)  0.14% of Total
         .          .    507:	default:
         .          .    508:		p.badVerb(verb)
         .          .    509:	}
         .          .    510:}
         .          .    511:
      10ms       10ms    512:func (p *pp) fmtString(v string, verb rune) {
         .          .    513:	switch verb {
         .          .    514:	case 'v':
         .          .    515:		if p.fmt.sharpV {
         .          .    516:			p.fmt.fmt_q(v)
         .          .    517:		} else {
         .       20ms    518:			p.fmt.fmt_s(v)
         .          .    519:		}
         .          .    520:	case 's':
         .       10ms    521:		p.fmt.fmt_s(v)
         .          .    522:	case 'x':
         .          .    523:		p.fmt.fmt_sx(v, ldigits)
         .          .    524:	case 'X':
         .          .    525:		p.fmt.fmt_sx(v, udigits)
         .          .    526:	case 'q':
         .       40ms    527:		p.fmt.fmt_q(v)
         .          .    528:	default:
         .          .    529:		p.badVerb(verb)
         .          .    530:	}
         .          .    531:}
         .          .    532:
ROUTINE ======================== fmt.(*pp).free in /home/isucon/.local/go/src/fmt/print.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    144:		return
         .          .    145:	}
         .          .    146:	p.buf = p.buf[:0]
         .          .    147:	p.arg = nil
         .          .    148:	p.value = reflect.Value{}
         .       10ms    149:	ppFree.Put(p)
         .          .    150:}
         .          .    151:
         .          .    152:func (p *pp) Width() (wid int, ok bool) { return p.fmt.wid, p.fmt.widPresent }
         .          .    153:
         .          .    154:func (p *pp) Precision() (prec int, ok bool) { return p.fmt.prec, p.fmt.precPresent }
ROUTINE ======================== fmt.(*pp).handleMethods in /home/isucon/.local/go/src/fmt/print.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    688:func (p *pp) handleMethods(verb rune, depth int) (handled bool) {
         .          .    689:	if p.erroring {
         .          .    690:		return
         .          .    691:	}
         .          .    692:	// Is it a Formatter?
         .       10ms    693:	if formatter, ok := p.arg.(Formatter); ok {
         .          .    694:		handled = true
         .          .    695:		defer p.restoreSpecialFlags(p.clearSpecialFlags())
         .          .    696:		defer p.catchPanic(p.arg, verb)
         .          .    697:		formatter.Format(p, verb)
         .          .    698:		return
         .          .    699:	}
         .          .    700:
         .          .    701:	// If we're doing Go syntax and the argument knows how to supply it, take care of it now.
         .          .    702:	if p.fmt.sharpV {
         .          .    703:		if stringer, ok := p.arg.(GoStringer); ok {
         .          .    704:			handled = true
         .          .    705:			defer p.catchPanic(p.arg, verb)
         .          .    706:			// Print the result of GoString unadorned.
         .          .    707:			p.fmt.fmt_s(stringer.GoString())
         .          .    708:			return
         .          .    709:		}
         .          .    710:	} else {
         .          .    711:		// If a string is acceptable according to the format, see if
         .          .    712:		// the value satisfies one of the string-valued interfaces.
         .          .    713:		// Println etc. set verb to %v, which is "stringable".
         .          .    714:		switch verb {
         .          .    715:		case 'v', 's', 'x', 'X', 'q':
         .          .    716:			// Is it an error or Stringer?
         .          .    717:			// The duplication in the bodies is necessary:
         .          .    718:			// setting handled and deferring catchPanic
         .          .    719:			// must happen before calling the method.
         .       10ms    720:			switch v := p.arg.(type) {
         .          .    721:			case error:
         .          .    722:				handled = true
         .          .    723:				defer p.catchPanic(p.arg, verb)
         .          .    724:				p.printArg(v.Error(), verb, depth)
         .          .    725:				return
ROUTINE ======================== fmt.(*pp).printArg in /home/isucon/.local/go/src/fmt/print.go
         0      110ms (flat, cum)   0.2% of Total
         .          .    758:		p.fmtPointer(reflect.ValueOf(arg), verb)
         .          .    759:		return false
         .          .    760:	}
         .          .    761:
         .          .    762:	// Some types can be done without reflection.
         .       10ms    763:	switch f := arg.(type) {
         .          .    764:	case bool:
         .          .    765:		p.fmtBool(f, verb)
         .          .    766:	case float32:
         .          .    767:		p.fmtFloat32(f, verb)
         .          .    768:	case float64:
         .          .    769:		p.fmtFloat64(f, verb)
         .          .    770:	case complex64:
         .          .    771:		p.fmtComplex64(f, verb)
         .          .    772:	case complex128:
         .          .    773:		p.fmtComplex128(f, verb)
         .          .    774:	case int:
         .          .    775:		p.fmtInt64(int64(f), verb)
         .          .    776:	case int8:
         .          .    777:		p.fmtInt64(int64(f), verb)
         .          .    778:	case int16:
         .          .    779:		p.fmtInt64(int64(f), verb)
         .          .    780:	case int32:
         .          .    781:		p.fmtInt64(int64(f), verb)
         .          .    782:	case int64:
         .          .    783:		p.fmtInt64(f, verb)
         .          .    784:	case uint:
         .          .    785:		p.fmtUint64(uint64(f), verb)
         .          .    786:	case uint8:
         .          .    787:		p.fmtUint64(uint64(f), verb)
         .          .    788:	case uint16:
         .          .    789:		p.fmtUint64(uint64(f), verb)
         .          .    790:	case uint32:
         .          .    791:		p.fmtUint64(uint64(f), verb)
         .          .    792:	case uint64:
         .          .    793:		p.fmtUint64(f, verb)
         .          .    794:	case uintptr:
         .          .    795:		p.fmtUint64(uint64(f), verb)
         .          .    796:	case string:
         .       80ms    797:		p.fmtString(f, verb)
         .          .    798:		wasString = verb == 's' || verb == 'v'
         .          .    799:	case []byte:
         .          .    800:		p.fmtBytes(f, verb, nil, depth)
         .          .    801:		wasString = verb == 's'
         .          .    802:	case reflect.Value:
         .          .    803:		return p.printReflectValue(f, verb, depth)
         .          .    804:	default:
         .          .    805:		// If the type is not simple, it might have methods.
         .       20ms    806:		if handled := p.handleMethods(verb, depth); handled {
         .          .    807:			return false
         .          .    808:		}
         .          .    809:		// Need to use reflection
         .          .    810:		return p.printReflectValue(reflect.ValueOf(arg), verb, depth)
         .          .    811:	}
ROUTINE ======================== fmt.(*ss).ReadRune in /home/isucon/.local/go/src/fmt/scan.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    192:
         .          .    193:func (s *ss) ReadRune() (r rune, size int, err error) {
         .          .    194:	if s.peekRune >= 0 {
         .          .    195:		s.count++
         .          .    196:		r = s.peekRune
      10ms       10ms    197:		size = utf8.RuneLen(r)
         .          .    198:		s.prevRune = r
         .          .    199:		s.peekRune = -1
         .          .    200:		return
         .          .    201:	}
         .          .    202:	if s.atEOF || s.nlIsEnd && s.prevRune == '\n' || s.count >= s.argLimit {
ROUTINE ======================== fmt.(*ss).accept in /home/isucon/.local/go/src/fmt/scan.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    526:}
         .          .    527:
         .          .    528:// accept checks the next rune in the input.  If it's a byte (sic) in the string, it puts it in the
         .          .    529:// buffer and returns true. Otherwise it return false.
         .          .    530:func (s *ss) accept(ok string) bool {
         .       10ms    531:	return s.consume(ok, true)
         .          .    532:}
         .          .    533:
         .          .    534:// okVerb verifies that the verb is present in the list, setting s.err appropriately if not.
         .          .    535:func (s *ss) okVerb(verb rune, okVerbs, typ string) bool {
         .          .    536:	for _, v := range okVerbs {
ROUTINE ======================== fmt.(*ss).advance in /home/isucon/.local/go/src/fmt/scan.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   1104:			fmtc, w = utf8.DecodeRuneInString(format[i:])
         .          .   1105:		}
         .          .   1106:		if sawSpace {
         .          .   1107:			// There was space in the format, so there should be space
         .          .   1108:			// in the input.
         .       10ms   1109:			inputc := s.getRune()
         .          .   1110:			if inputc == eof {
         .          .   1111:				return
         .          .   1112:			}
         .          .   1113:			if !isSpace(inputc) {
         .          .   1114:				// Space in format but not in input.
ROUTINE ======================== fmt.(*ss).consume in /home/isucon/.local/go/src/fmt/scan.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    494:func (s *ss) consume(ok string, accept bool) bool {
         .          .    495:	r := s.getRune()
         .          .    496:	if r == eof {
         .          .    497:		return false
         .          .    498:	}
         .       10ms    499:	if indexRune(ok, r) >= 0 {
         .          .    500:		if accept {
         .          .    501:			s.buf.WriteRune(r)
         .          .    502:		}
         .          .    503:		return true
         .          .    504:	}
ROUTINE ======================== fmt.(*ss).doScanf in /home/isucon/.local/go/src/fmt/scan.go
         0       20ms (flat, cum) 0.036% of Total
         .          .   1146:func (s *ss) doScanf(format string, a []interface{}) (numProcessed int, err error) {
         .          .   1147:	defer errorHandler(&err)
         .          .   1148:	end := len(format) - 1
         .          .   1149:	// We process one item per non-trivial format
         .          .   1150:	for i := 0; i <= end; {
         .       10ms   1151:		w := s.advance(format[i:])
         .          .   1152:		if w > 0 {
         .          .   1153:			i += w
         .          .   1154:			continue
         .          .   1155:		}
         .          .   1156:		// Either we failed to advance, we have a percent character, or we ran out of input.
         .          .   1157:		if format[i] != '%' {
         .          .   1158:			// Can't advance format.  Why not?
         .          .   1159:			if w < 0 {
         .          .   1160:				s.errorString("input does not match format")
         .          .   1161:			}
         .          .   1162:			// Otherwise at EOF; "too many operands" error handled below
         .          .   1163:			break
         .          .   1164:		}
         .          .   1165:		i++ // % is one byte
         .          .   1166:
         .          .   1167:		// do we have 20 (width)?
         .          .   1168:		var widPresent bool
         .          .   1169:		s.maxWid, widPresent, i = parsenum(format, i, end)
         .          .   1170:		if !widPresent {
         .          .   1171:			s.maxWid = hugeWid
         .          .   1172:		}
         .          .   1173:
         .          .   1174:		c, w := utf8.DecodeRuneInString(format[i:])
         .          .   1175:		i += w
         .          .   1176:
         .          .   1177:		if c != 'c' {
         .          .   1178:			s.SkipSpace()
         .          .   1179:		}
         .          .   1180:		s.argLimit = s.limit
         .          .   1181:		if f := s.count + s.maxWid; f < s.argLimit {
         .          .   1182:			s.argLimit = f
         .          .   1183:		}
         .          .   1184:
         .          .   1185:		if numProcessed >= len(a) { // out of operands
         .          .   1186:			s.errorString("too few operands for format '%" + format[i-w:] + "'")
         .          .   1187:			break
         .          .   1188:		}
         .          .   1189:		arg := a[numProcessed]
         .          .   1190:
         .       10ms   1191:		s.scanOne(c, arg)
         .          .   1192:		numProcessed++
         .          .   1193:		s.argLimit = s.limit
         .          .   1194:	}
         .          .   1195:	if numProcessed < len(a) {
         .          .   1196:		s.errorString("too many operands")
ROUTINE ======================== fmt.(*ss).getRune in /home/isucon/.local/go/src/fmt/scan.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    222:}
         .          .    223:
         .          .    224:// The public method returns an error; this private one panics.
         .          .    225:// If getRune reaches EOF, the return value is EOF (-1).
         .          .    226:func (s *ss) getRune() (r rune) {
         .       10ms    227:	r, _, err := s.ReadRune()
         .          .    228:	if err != nil {
         .          .    229:		if err == io.EOF {
         .          .    230:			return eof
         .          .    231:		}
         .          .    232:		s.error(err)
ROUTINE ======================== fmt.(*ss).scanInt in /home/isucon/.local/go/src/fmt/scan.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    660:		s.accept(sign) // If there's a sign, it will be left in the token buffer.
         .          .    661:		if verb == 'v' {
         .          .    662:			base, digits, haveDigits = s.scanBasePrefix()
         .          .    663:		}
         .          .    664:	}
         .       10ms    665:	tok := s.scanNumber(digits, haveDigits)
         .          .    666:	i, err := strconv.ParseInt(tok, base, 64)
         .          .    667:	if err != nil {
         .          .    668:		s.error(err)
         .          .    669:	}
         .          .    670:	n := uint(bitSize)
ROUTINE ======================== fmt.(*ss).scanNumber in /home/isucon/.local/go/src/fmt/scan.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    605:		s.notEOF()
         .          .    606:		if !s.accept(digits) {
         .          .    607:			s.errorString("expected integer")
         .          .    608:		}
         .          .    609:	}
         .       10ms    610:	for s.accept(digits) {
         .          .    611:	}
         .          .    612:	return string(s.buf)
         .          .    613:}
         .          .    614:
         .          .    615:// scanRune returns the next rune value in the input.
ROUTINE ======================== fmt.(*ss).scanOne in /home/isucon/.local/go/src/fmt/scan.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    948:	case *complex64:
         .          .    949:		*v = complex64(s.scanComplex(verb, 64))
         .          .    950:	case *complex128:
         .          .    951:		*v = s.scanComplex(verb, 128)
         .          .    952:	case *int:
         .       10ms    953:		*v = int(s.scanInt(verb, intBits))
         .          .    954:	case *int8:
         .          .    955:		*v = int8(s.scanInt(verb, 8))
         .          .    956:	case *int16:
         .          .    957:		*v = int16(s.scanInt(verb, 16))
         .          .    958:	case *int32:
ROUTINE ======================== fmt.Fprint in /home/isucon/.local/go/src/fmt/print.go
      10ms      100ms (flat, cum)  0.18% of Total
         .          .    217:// Fprint formats using the default formats for its operands and writes to w.
         .          .    218:// Spaces are added between operands when neither is a string.
         .          .    219:// It returns the number of bytes written and any write error encountered.
         .          .    220:func Fprint(w io.Writer, a ...interface{}) (n int, err error) {
         .          .    221:	p := newPrinter()
         .       20ms    222:	p.doPrint(a, false, false)
      10ms       80ms    223:	n, err = w.Write(p.buf)
         .          .    224:	p.free()
         .          .    225:	return
         .          .    226:}
         .          .    227:
         .          .    228:// Print formats using the default formats for its operands and writes to standard output.
ROUTINE ======================== fmt.Fprintf in /home/isucon/.local/go/src/fmt/print.go
         0      120ms (flat, cum)  0.22% of Total
         .          .    182:// These routines end in 'f' and take a format string.
         .          .    183:
         .          .    184:// Fprintf formats according to a format specifier and writes to w.
         .          .    185:// It returns the number of bytes written and any write error encountered.
         .          .    186:func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {
         .       20ms    187:	p := newPrinter()
         .       80ms    188:	p.doPrintf(format, a)
         .       20ms    189:	n, err = w.Write(p.buf)
         .          .    190:	p.free()
         .          .    191:	return
         .          .    192:}
         .          .    193:
         .          .    194:// Printf formats according to a format specifier and writes to standard output.
ROUTINE ======================== fmt.Fscanf in /home/isucon/.local/go/src/fmt/scan.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    146:// values into successive arguments as determined by the format.  It
         .          .    147:// returns the number of items successfully parsed.
         .          .    148:// Newlines in the input must match newlines in the format.
         .          .    149:func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error) {
         .          .    150:	s, old := newScanState(r, false, false)
         .       20ms    151:	n, err = s.doScanf(format, a)
         .          .    152:	s.free(old)
         .          .    153:	return
         .          .    154:}
         .          .    155:
         .          .    156:// scanError represents an error generated by the scanning software.
ROUTINE ======================== fmt.Sprint in /home/isucon/.local/go/src/fmt/print.go
      10ms       40ms (flat, cum) 0.072% of Total
         .          .    232:	return Fprint(os.Stdout, a...)
         .          .    233:}
         .          .    234:
         .          .    235:// Sprint formats using the default formats for its operands and returns the resulting string.
         .          .    236:// Spaces are added between operands when neither is a string.
      10ms       10ms    237:func Sprint(a ...interface{}) string {
         .          .    238:	p := newPrinter()
         .          .    239:	p.doPrint(a, false, false)
         .       20ms    240:	s := string(p.buf)
         .       10ms    241:	p.free()
         .          .    242:	return s
         .          .    243:}
         .          .    244:
         .          .    245:// These routines end in 'ln', do not take a format string,
         .          .    246:// always add spaces between operands, and add a newline
ROUTINE ======================== fmt.Sprintf in /home/isucon/.local/go/src/fmt/print.go
         0       70ms (flat, cum)  0.13% of Total
         .          .    197:	return Fprintf(os.Stdout, format, a...)
         .          .    198:}
         .          .    199:
         .          .    200:// Sprintf formats according to a format specifier and returns the resulting string.
         .          .    201:func Sprintf(format string, a ...interface{}) string {
         .       10ms    202:	p := newPrinter()
         .       60ms    203:	p.doPrintf(format, a)
         .          .    204:	s := string(p.buf)
         .          .    205:	p.free()
         .          .    206:	return s
         .          .    207:}
         .          .    208:
ROUTINE ======================== fmt.Sscanf in /home/isucon/.local/go/src/fmt/scan.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    116:
         .          .    117:// Sscanf scans the argument string, storing successive space-separated
         .          .    118:// values into successive arguments as determined by the format.  It
         .          .    119:// returns the number of items successfully parsed.
         .          .    120:// Newlines in the input must match newlines in the format.
         .       10ms    121:func Sscanf(str string, format string, a ...interface{}) (n int, err error) {
         .       20ms    122:	return Fscanf((*stringReader)(&str), format, a...)
         .          .    123:}
         .          .    124:
         .          .    125:// Fscan scans text read from r, storing successive space-separated
         .          .    126:// values into successive arguments.  Newlines count as space.  It
         .          .    127:// returns the number of items successfully scanned.  If that is less
ROUTINE ======================== fmt.glob.func1 in /home/isucon/.local/go/src/fmt/print.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    123:	runeBuf    [utf8.UTFMax]byte
         .          .    124:	fmt        fmt
         .          .    125:}
         .          .    126:
         .          .    127:var ppFree = sync.Pool{
         .       20ms    128:	New: func() interface{} { return new(pp) },
         .          .    129:}
         .          .    130:
         .          .    131:// newPrinter allocates a new pp struct or grabs a cached one.
         .          .    132:func newPrinter() *pp {
         .          .    133:	p := ppFree.Get().(*pp)
ROUTINE ======================== fmt.indexRune in /home/isucon/.local/go/src/fmt/scan.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    479:
         .          .    480:var complexError = errors.New("syntax error scanning complex number")
         .          .    481:var boolError = errors.New("syntax error scanning boolean")
         .          .    482:
         .          .    483:func indexRune(s string, r rune) int {
      10ms       10ms    484:	for i, c := range s {
         .          .    485:		if c == r {
         .          .    486:			return i
         .          .    487:		}
         .          .    488:	}
         .          .    489:	return -1
ROUTINE ======================== fmt.newPrinter in /home/isucon/.local/go/src/fmt/print.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    128:	New: func() interface{} { return new(pp) },
         .          .    129:}
         .          .    130:
         .          .    131:// newPrinter allocates a new pp struct or grabs a cached one.
         .          .    132:func newPrinter() *pp {
         .       30ms    133:	p := ppFree.Get().(*pp)
         .          .    134:	p.panicking = false
         .          .    135:	p.erroring = false
         .          .    136:	p.fmt.init(&p.buf)
         .          .    137:	return p
         .          .    138:}
ROUTINE ======================== github.com/bradfitz/gomemcache/memcache.(*Client).Get in /home/isucon/gocode/src/github.com/bradfitz/gomemcache/memcache/memcache.go
         0       90ms (flat, cum)  0.16% of Total
         .          .    297:// Get gets the item for the given key. ErrCacheMiss is returned for a
         .          .    298:// memcache cache miss. The key must be at most 250 bytes in length.
         .          .    299:func (c *Client) Get(key string) (item *Item, err error) {
         .          .    300:	err = c.withKeyAddr(key, func(addr net.Addr) error {
         .          .    301:		return c.getFromAddr(addr, []string{key}, func(it *Item) { item = it })
         .       90ms    302:	})
         .          .    303:	if err == nil && item == nil {
         .          .    304:		err = ErrCacheMiss
         .          .    305:	}
         .          .    306:	return
         .          .    307:}
ROUTINE ======================== github.com/bradfitz/gomemcache/memcache.(*Client).Get.func1 in /home/isucon/gocode/src/github.com/bradfitz/gomemcache/memcache/memcache.go
         0       90ms (flat, cum)  0.16% of Total
         .          .    296:
         .          .    297:// Get gets the item for the given key. ErrCacheMiss is returned for a
         .          .    298:// memcache cache miss. The key must be at most 250 bytes in length.
         .          .    299:func (c *Client) Get(key string) (item *Item, err error) {
         .          .    300:	err = c.withKeyAddr(key, func(addr net.Addr) error {
         .       90ms    301:		return c.getFromAddr(addr, []string{key}, func(it *Item) { item = it })
         .          .    302:	})
         .          .    303:	if err == nil && item == nil {
         .          .    304:		err = ErrCacheMiss
         .          .    305:	}
         .          .    306:	return
ROUTINE ======================== github.com/bradfitz/gomemcache/memcache.(*Client).Set in /home/isucon/gocode/src/github.com/bradfitz/gomemcache/memcache/memcache.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    491:	return size, nil
         .          .    492:}
         .          .    493:
         .          .    494:// Set writes the given item, unconditionally.
         .          .    495:func (c *Client) Set(item *Item) error {
         .       30ms    496:	return c.onItem(item, (*Client).set)
         .          .    497:}
         .          .    498:
         .          .    499:func (c *Client) set(rw *bufio.ReadWriter, item *Item) error {
         .          .    500:	return c.populateOne(rw, "set", item)
         .          .    501:}
ROUTINE ======================== github.com/bradfitz/gomemcache/memcache.(*Client).getFromAddr in /home/isucon/gocode/src/github.com/bradfitz/gomemcache/memcache/memcache.go
         0       90ms (flat, cum)  0.16% of Total
         .          .    352:		}
         .          .    353:		if err := parseGetResponse(rw.Reader, cb); err != nil {
         .          .    354:			return err
         .          .    355:		}
         .          .    356:		return nil
         .       90ms    357:	})
         .          .    358:}
         .          .    359:
         .          .    360:// flushAllFromAddr send the flush_all command to the given addr
         .          .    361:func (c *Client) flushAllFromAddr(addr net.Addr) error {
         .          .    362:	return c.withAddrRw(addr, func(rw *bufio.ReadWriter) error {
ROUTINE ======================== github.com/bradfitz/gomemcache/memcache.(*Client).getFromAddr.func1 in /home/isucon/gocode/src/github.com/bradfitz/gomemcache/memcache/memcache.go
         0       90ms (flat, cum)  0.16% of Total
         .          .    345:func (c *Client) getFromAddr(addr net.Addr, keys []string, cb func(*Item)) error {
         .          .    346:	return c.withAddrRw(addr, func(rw *bufio.ReadWriter) error {
         .          .    347:		if _, err := fmt.Fprintf(rw, "gets %s\r\n", strings.Join(keys, " ")); err != nil {
         .          .    348:			return err
         .          .    349:		}
         .       20ms    350:		if err := rw.Flush(); err != nil {
         .          .    351:			return err
         .          .    352:		}
         .       70ms    353:		if err := parseGetResponse(rw.Reader, cb); err != nil {
         .          .    354:			return err
         .          .    355:		}
         .          .    356:		return nil
         .          .    357:	})
         .          .    358:}
ROUTINE ======================== github.com/bradfitz/gomemcache/memcache.(*Client).onItem in /home/isucon/gocode/src/github.com/bradfitz/gomemcache/memcache/memcache.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    282:	cn, err := c.getConn(addr)
         .          .    283:	if err != nil {
         .          .    284:		return err
         .          .    285:	}
         .          .    286:	defer cn.condRelease(&err)
         .       10ms    287:	if err = fn(c, cn.rw, item); err != nil {
         .          .    288:		return err
         .          .    289:	}
         .       20ms    290:	return nil
         .          .    291:}
         .          .    292:
         .          .    293:func (c *Client) FlushAll() error {
         .          .    294:	return c.selector.Each(c.flushAllFromAddr)
         .          .    295:}
ROUTINE ======================== github.com/bradfitz/gomemcache/memcache.(*Client).populateOne in /home/isucon/gocode/src/github.com/bradfitz/gomemcache/memcache/memcache.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    557:		return err
         .          .    558:	}
         .          .    559:	if err := rw.Flush(); err != nil {
         .          .    560:		return err
         .          .    561:	}
         .       10ms    562:	line, err := rw.ReadSlice('\n')
         .          .    563:	if err != nil {
         .          .    564:		return err
         .          .    565:	}
         .          .    566:	switch {
         .          .    567:	case bytes.Equal(line, resultStored):
ROUTINE ======================== github.com/bradfitz/gomemcache/memcache.(*Client).putFreeConn in /home/isucon/gocode/src/github.com/bradfitz/gomemcache/memcache/memcache.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    193:	c.lk.Lock()
         .          .    194:	defer c.lk.Unlock()
         .          .    195:	if c.freeconn == nil {
         .          .    196:		c.freeconn = make(map[string][]*conn)
         .          .    197:	}
         .       20ms    198:	freelist := c.freeconn[addr.String()]
         .          .    199:	if len(freelist) >= maxIdleConnsPerAddr {
         .          .    200:		cn.nc.Close()
         .          .    201:		return
         .          .    202:	}
         .          .    203:	c.freeconn[addr.String()] = append(freelist, cn)
ROUTINE ======================== github.com/bradfitz/gomemcache/memcache.(*Client).set in /home/isucon/gocode/src/github.com/bradfitz/gomemcache/memcache/memcache.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    495:func (c *Client) Set(item *Item) error {
         .          .    496:	return c.onItem(item, (*Client).set)
         .          .    497:}
         .          .    498:
         .          .    499:func (c *Client) set(rw *bufio.ReadWriter, item *Item) error {
         .       10ms    500:	return c.populateOne(rw, "set", item)
         .          .    501:}
         .          .    502:
         .          .    503:// Add writes the given item, if no value already exists for its
         .          .    504:// key. ErrNotStored is returned if that condition is not met.
         .          .    505:func (c *Client) Add(item *Item) error {
ROUTINE ======================== github.com/bradfitz/gomemcache/memcache.(*Client).withAddrRw in /home/isucon/gocode/src/github.com/bradfitz/gomemcache/memcache/memcache.go
         0       90ms (flat, cum)  0.16% of Total
         .          .    331:	cn, err := c.getConn(addr)
         .          .    332:	if err != nil {
         .          .    333:		return err
         .          .    334:	}
         .          .    335:	defer cn.condRelease(&err)
         .       90ms    336:	return fn(cn.rw)
         .          .    337:}
         .          .    338:
         .          .    339:func (c *Client) withKeyRw(key string, fn func(*bufio.ReadWriter) error) error {
         .          .    340:	return c.withKeyAddr(key, func(addr net.Addr) error {
         .          .    341:		return c.withAddrRw(addr, fn)
ROUTINE ======================== github.com/bradfitz/gomemcache/memcache.(*Client).withKeyAddr in /home/isucon/gocode/src/github.com/bradfitz/gomemcache/memcache/memcache.go
         0       90ms (flat, cum)  0.16% of Total
         .          .    322:	}
         .          .    323:	addr, err := c.selector.PickServer(key)
         .          .    324:	if err != nil {
         .          .    325:		return err
         .          .    326:	}
         .       90ms    327:	return fn(addr)
         .          .    328:}
         .          .    329:
         .          .    330:func (c *Client) withAddrRw(addr net.Addr, fn func(*bufio.ReadWriter) error) (err error) {
         .          .    331:	cn, err := c.getConn(addr)
         .          .    332:	if err != nil {
ROUTINE ======================== github.com/bradfitz/gomemcache/memcache.(*conn).condRelease in /home/isucon/gocode/src/github.com/bradfitz/gomemcache/memcache/memcache.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    181:// is nil (not an error) or is only a protocol level error (e.g. a
         .          .    182:// cache miss).  The purpose is to not recycle TCP connections that
         .          .    183:// are bad.
         .          .    184:func (cn *conn) condRelease(err *error) {
         .          .    185:	if *err == nil || resumableError(*err) {
         .       20ms    186:		cn.release()
         .          .    187:	} else {
         .          .    188:		cn.nc.Close()
         .          .    189:	}
         .          .    190:}
         .          .    191:
ROUTINE ======================== github.com/bradfitz/gomemcache/memcache.(*conn).release in /home/isucon/gocode/src/github.com/bradfitz/gomemcache/memcache/memcache.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    168:	c    *Client
         .          .    169:}
         .          .    170:
         .          .    171:// release returns this connection back to the client's free pool
         .          .    172:func (cn *conn) release() {
         .       20ms    173:	cn.c.putFreeConn(cn.addr, cn)
         .          .    174:}
         .          .    175:
         .          .    176:func (cn *conn) extendDeadline() {
         .          .    177:	cn.nc.SetDeadline(time.Now().Add(cn.c.netTimeout()))
         .          .    178:}
ROUTINE ======================== github.com/bradfitz/gomemcache/memcache.parseGetResponse in /home/isucon/gocode/src/github.com/bradfitz/gomemcache/memcache/memcache.go
         0       70ms (flat, cum)  0.13% of Total
         .          .    456:			return err
         .          .    457:		}
         .          .    458:		if bytes.Equal(line, resultEnd) {
         .          .    459:			return nil
         .          .    460:		}
         .       30ms    461:		it := new(Item)
         .       30ms    462:		size, err := scanGetResponseLine(line, it)
         .          .    463:		if err != nil {
         .          .    464:			return err
         .          .    465:		}
         .       10ms    466:		it.Value, err = ioutil.ReadAll(io.LimitReader(r, int64(size)+2))
         .          .    467:		if err != nil {
         .          .    468:			return err
         .          .    469:		}
         .          .    470:		if !bytes.HasSuffix(it.Value, crlf) {
         .          .    471:			return fmt.Errorf("memcache: corrupt get result read")
ROUTINE ======================== github.com/bradfitz/gomemcache/memcache.scanGetResponseLine in /home/isucon/gocode/src/github.com/bradfitz/gomemcache/memcache/memcache.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    482:	dest := []interface{}{&it.Key, &it.Flags, &size, &it.casid}
         .          .    483:	if bytes.Count(line, space) == 3 {
         .          .    484:		pattern = "VALUE %s %d %d\r\n"
         .          .    485:		dest = dest[:3]
         .          .    486:	}
         .       30ms    487:	n, err := fmt.Sscanf(string(line), pattern, dest...)
         .          .    488:	if err != nil || n != len(dest) {
         .          .    489:		return -1, fmt.Errorf("memcache: unexpected line in get response: %q", line)
         .          .    490:	}
         .          .    491:	return size, nil
         .          .    492:}
ROUTINE ======================== github.com/bradleypeabody/gorilla-sessions-memcache.(*MemcacheStore).Get in /home/isucon/gocode/src/github.com/bradleypeabody/gorilla-sessions-memcache/gsm.go
         0      230ms (flat, cum)  0.41% of Total
         .          .     70:
         .          .     71:// Get returns a session for the given name after adding it to the registry.
         .          .     72://
         .          .     73:// See CookieStore.Get().
         .          .     74:func (s *MemcacheStore) Get(r *http.Request, name string) (*sessions.Session, error) {
         .      230ms     75:	return sessions.GetRegistry(r).Get(s, name)
         .          .     76:}
         .          .     77:
         .          .     78:// New returns a session for the given name without adding it to the registry.
         .          .     79://
         .          .     80:// See CookieStore.New().
ROUTINE ======================== github.com/bradleypeabody/gorilla-sessions-memcache.(*MemcacheStore).New in /home/isucon/gocode/src/github.com/bradleypeabody/gorilla-sessions-memcache/gsm.go
         0      230ms (flat, cum)  0.41% of Total
         .          .     82:	session := sessions.NewSession(s, name)
         .          .     83:	opts := *s.Options
         .          .     84:	session.Options = &opts
         .          .     85:	session.IsNew = true
         .          .     86:	var err error
         .       10ms     87:	if c, errCookie := r.Cookie(name); errCookie == nil {
         .       30ms     88:		err = securecookie.DecodeMulti(name, c.Value, &session.ID, s.Codecs...)
         .          .     89:		if err == nil {
         .      190ms     90:			err = s.load(session)
         .          .     91:			if err == nil {
         .          .     92:				session.IsNew = false
         .          .     93:			}
         .          .     94:		}
         .          .     95:	}
ROUTINE ======================== github.com/bradleypeabody/gorilla-sessions-memcache.(*MemcacheStore).Save in /home/isucon/gocode/src/github.com/bradleypeabody/gorilla-sessions-memcache/gsm.go
         0      100ms (flat, cum)  0.18% of Total
         .          .    102:	if session.ID == "" {
         .          .    103:		// Because the ID is used in the filename, encode it to
         .          .    104:		// use alphanumeric characters only.
         .          .    105:		session.ID = strings.TrimRight(
         .          .    106:			base32.StdEncoding.EncodeToString(
         .       10ms    107:				securecookie.GenerateRandomKey(32)), "=")
         .          .    108:	}
         .       70ms    109:	if err := s.save(session); err != nil {
         .          .    110:		return err
         .          .    111:	}
         .          .    112:	encoded, err := securecookie.EncodeMulti(session.Name(), session.ID,
         .       10ms    113:		s.Codecs...)
         .          .    114:	if err != nil {
         .          .    115:		return err
         .          .    116:	}
         .       10ms    117:	http.SetCookie(w, sessions.NewCookie(session.Name(), encoded, session.Options))
         .          .    118:	return nil
         .          .    119:}
         .          .    120:
         .          .    121:// save writes encoded session.Values using the memcache client
         .          .    122:func (s *MemcacheStore) save(session *sessions.Session) error {
ROUTINE ======================== github.com/bradleypeabody/gorilla-sessions-memcache.(*MemcacheStore).load in /home/isucon/gocode/src/github.com/bradleypeabody/gorilla-sessions-memcache/gsm.go
         0      190ms (flat, cum)  0.34% of Total
         .          .    210:// load reads a file and decodes its content into session.Values.
         .          .    211:func (s *MemcacheStore) load(session *sessions.Session) error {
         .          .    212:
         .          .    213:	key := s.KeyPrefix + session.ID
         .          .    214:
         .       90ms    215:	it, err := s.Client.Get(key)
         .          .    216:	if s.Logging > 0 {
         .          .    217:		if s.StoreMethod == StoreMethodJson {
         .          .    218:			log.Printf("gorilla-sessions-memcache: get (method: %s, session name: %v, memcache key: %v, memcache value: %v, error: %v)", s.StoreMethod, session.Name(), key, string(it.Value), err)
         .          .    219:		} else {
         .          .    220:			log.Printf("gorilla-sessions-memcache: get (method: %s, session name: %v, memcache key: %v, memcache value len: %v, error: %v)", s.StoreMethod, session.Name(), key, len(it.Value), err)
         .          .    221:		}
         .          .    222:	}
         .          .    223:	if err != nil {
         .          .    224:		return err
         .          .    225:	}
         .          .    226:
         .          .    227:	switch s.StoreMethod {
         .          .    228:
         .          .    229:	case StoreMethodSecureCookie:
         .          .    230:
         .          .    231:		if err = securecookie.DecodeMulti(session.Name(), string(it.Value),
         .      100ms    232:			&session.Values, s.Codecs...); err != nil {
         .          .    233:			if s.Logging > 0 {
         .          .    234:				log.Printf("gorilla-sessions-memcache: get (method: securecookie, decoding error: %v)", err)
         .          .    235:			}
         .          .    236:			return err
         .          .    237:		}
ROUTINE ======================== github.com/bradleypeabody/gorilla-sessions-memcache.(*MemcacheStore).save in /home/isucon/gocode/src/github.com/bradleypeabody/gorilla-sessions-memcache/gsm.go
         0       70ms (flat, cum)  0.13% of Total
         .          .    126:	switch s.StoreMethod {
         .          .    127:
         .          .    128:	case StoreMethodSecureCookie:
         .          .    129:
         .          .    130:		encoded, err := securecookie.EncodeMulti(session.Name(), session.Values,
         .       40ms    131:			s.Codecs...)
         .          .    132:		if err != nil {
         .          .    133:			if s.Logging > 0 {
         .          .    134:				log.Printf("gorilla-sessions-memcache: set (method: securecookie, encoding error: %v)", err)
         .          .    135:			}
         .          .    136:			return err
         .          .    137:		}
         .          .    138:
         .       30ms    139:		err = s.Client.Set(&memcache.Item{Key: key, Value: []byte(encoded)})
         .          .    140:		if s.Logging > 0 {
         .          .    141:			log.Printf("gorilla-sessions-memcache: set (method: securecookie, session name: %v, memcache key: %v, memcache value: %v, error: %v)", session.Name(), key, encoded, err)
         .          .    142:		}
         .          .    143:		if err != nil {
         .          .    144:			return err
ROUTINE ======================== github.com/go-sql-driver/mysql.(*MySQLDriver).Open in <autogenerated>
         0      790ms (flat, cum)  1.42% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== github.com/go-sql-driver/mysql.(*binaryRows).Next in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/rows.go
         0      1.49s (flat, cum)  2.68% of Total
         .          .     80:		if mc.netConn == nil {
         .          .     81:			return ErrInvalidConn
         .          .     82:		}
         .          .     83:
         .          .     84:		// Fetch next row from stream
         .      1.49s     85:		return rows.readRow(dest)
         .          .     86:	}
         .          .     87:	return io.EOF
         .          .     88:}
         .          .     89:
         .          .     90:func (rows *textRows) Next(dest []driver.Value) error {
ROUTINE ======================== github.com/go-sql-driver/mysql.(*binaryRows).readRow in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/packets.go
     120ms      1.49s (flat, cum)  2.68% of Total
         .          .   1063:	}
         .          .   1064:	return nil
         .          .   1065:}
         .          .   1066:
         .          .   1067:// http://dev.mysql.com/doc/internals/en/binary-protocol-resultset-row.html
      10ms       10ms   1068:func (rows *binaryRows) readRow(dest []driver.Value) error {
         .      920ms   1069:	data, err := rows.mc.readPacket()
         .          .   1070:	if err != nil {
         .          .   1071:		return err
         .          .   1072:	}
         .          .   1073:
         .          .   1074:	// packet indicator [1 byte]
         .          .   1075:	if data[0] != iOK {
         .          .   1076:		// EOF Packet
         .          .   1077:		if data[0] == iEOF && len(data) == 5 {
         .          .   1078:			rows.mc.status = readStatus(data[3:])
         .          .   1079:			if err := rows.mc.discardResults(); err != nil {
         .          .   1080:				return err
         .          .   1081:			}
         .          .   1082:			rows.mc = nil
         .          .   1083:			return io.EOF
         .          .   1084:		}
         .          .   1085:		rows.mc = nil
         .          .   1086:
         .          .   1087:		// Error otherwise
         .          .   1088:		return rows.mc.handleErrorPacket(data)
         .          .   1089:	}
         .          .   1090:
         .          .   1091:	// NULL-bitmap,  [(column-count + 7 + 2) / 8 bytes]
         .          .   1092:	pos := 1 + (len(dest)+7+2)>>3
         .          .   1093:	nullMask := data[1:pos]
         .          .   1094:
      20ms       20ms   1095:	for i := range dest {
         .          .   1096:		// Field is NULL
         .          .   1097:		// (byte >> bit-pos) % 2 == 1
      20ms       20ms   1098:		if ((nullMask[(i+2)>>3] >> uint((i+2)&7)) & 1) == 1 {
         .          .   1099:			dest[i] = nil
         .          .   1100:			continue
         .          .   1101:		}
         .          .   1102:
         .          .   1103:		// Convert to byte-coded string
      20ms       20ms   1104:		switch rows.columns[i].fieldType {
         .          .   1105:		case fieldTypeNULL:
         .          .   1106:			dest[i] = nil
         .          .   1107:			continue
         .          .   1108:
         .          .   1109:		// Numeric Types
         .          .   1110:		case fieldTypeTiny:
         .          .   1111:			if rows.columns[i].flags&flagUnsigned != 0 {
         .          .   1112:				dest[i] = int64(data[pos])
         .          .   1113:			} else {
         .       10ms   1114:				dest[i] = int64(int8(data[pos]))
         .          .   1115:			}
         .          .   1116:			pos++
         .          .   1117:			continue
         .          .   1118:
         .          .   1119:		case fieldTypeShort, fieldTypeYear:
         .          .   1120:			if rows.columns[i].flags&flagUnsigned != 0 {
         .          .   1121:				dest[i] = int64(binary.LittleEndian.Uint16(data[pos : pos+2]))
         .          .   1122:			} else {
         .          .   1123:				dest[i] = int64(int16(binary.LittleEndian.Uint16(data[pos : pos+2])))
         .          .   1124:			}
         .          .   1125:			pos += 2
         .          .   1126:			continue
         .          .   1127:
         .          .   1128:		case fieldTypeInt24, fieldTypeLong:
         .          .   1129:			if rows.columns[i].flags&flagUnsigned != 0 {
         .          .   1130:				dest[i] = int64(binary.LittleEndian.Uint32(data[pos : pos+4]))
         .          .   1131:			} else {
      20ms      170ms   1132:				dest[i] = int64(int32(binary.LittleEndian.Uint32(data[pos : pos+4])))
         .          .   1133:			}
         .          .   1134:			pos += 4
         .          .   1135:			continue
         .          .   1136:
         .          .   1137:		case fieldTypeLongLong:
         .          .   1138:			if rows.columns[i].flags&flagUnsigned != 0 {
         .          .   1139:				val := binary.LittleEndian.Uint64(data[pos : pos+8])
         .          .   1140:				if val > math.MaxInt64 {
         .          .   1141:					dest[i] = uint64ToString(val)
         .          .   1142:				} else {
         .          .   1143:					dest[i] = int64(val)
         .          .   1144:				}
         .          .   1145:			} else {
         .       10ms   1146:				dest[i] = int64(binary.LittleEndian.Uint64(data[pos : pos+8]))
         .          .   1147:			}
         .          .   1148:			pos += 8
         .          .   1149:			continue
         .          .   1150:
         .          .   1151:		case fieldTypeFloat:
         .          .   1152:			dest[i] = float32(math.Float32frombits(binary.LittleEndian.Uint32(data[pos : pos+4])))
         .          .   1153:			pos += 4
         .          .   1154:			continue
         .          .   1155:
         .          .   1156:		case fieldTypeDouble:
         .          .   1157:			dest[i] = math.Float64frombits(binary.LittleEndian.Uint64(data[pos : pos+8]))
         .          .   1158:			pos += 8
         .          .   1159:			continue
         .          .   1160:
         .          .   1161:		// Length coded Binary Strings
         .          .   1162:		case fieldTypeDecimal, fieldTypeNewDecimal, fieldTypeVarChar,
         .          .   1163:			fieldTypeBit, fieldTypeEnum, fieldTypeSet, fieldTypeTinyBLOB,
         .          .   1164:			fieldTypeMediumBLOB, fieldTypeLongBLOB, fieldTypeBLOB,
         .          .   1165:			fieldTypeVarString, fieldTypeString, fieldTypeGeometry, fieldTypeJSON:
         .          .   1166:			var isNull bool
         .          .   1167:			var n int
      10ms      190ms   1168:			dest[i], isNull, n, err = readLengthEncodedString(data[pos:])
      10ms       10ms   1169:			pos += n
         .          .   1170:			if err == nil {
         .          .   1171:				if !isNull {
         .          .   1172:					continue
         .          .   1173:				} else {
         .          .   1174:					dest[i] = nil
         .          .   1175:					continue
         .          .   1176:				}
         .          .   1177:			}
         .          .   1178:			return err
         .          .   1179:
         .          .   1180:		case
         .          .   1181:			fieldTypeDate, fieldTypeNewDate, // Date YYYY-MM-DD
         .          .   1182:			fieldTypeTime,                         // Time [-][H]HH:MM:SS[.fractal]
         .          .   1183:			fieldTypeTimestamp, fieldTypeDateTime: // Timestamp YYYY-MM-DD HH:MM:SS[.fractal]
         .          .   1184:
         .          .   1185:			num, isNull, n := readLengthEncodedInteger(data[pos:])
         .          .   1186:			pos += n
         .          .   1187:
         .          .   1188:			switch {
         .          .   1189:			case isNull:
         .          .   1190:				dest[i] = nil
         .          .   1191:				continue
         .          .   1192:			case rows.columns[i].fieldType == fieldTypeTime:
         .          .   1193:				// database/sql does not support an equivalent to TIME, return a string
         .          .   1194:				var dstlen uint8
         .          .   1195:				switch decimals := rows.columns[i].decimals; decimals {
         .          .   1196:				case 0x00, 0x1f:
         .          .   1197:					dstlen = 8
         .          .   1198:				case 1, 2, 3, 4, 5, 6:
         .          .   1199:					dstlen = 8 + 1 + decimals
         .          .   1200:				default:
         .          .   1201:					return fmt.Errorf(
         .          .   1202:						"protocol error, illegal decimals value %d",
         .          .   1203:						rows.columns[i].decimals,
         .          .   1204:					)
         .          .   1205:				}
         .          .   1206:				dest[i], err = formatBinaryDateTime(data[pos:pos+int(num)], dstlen, true)
         .          .   1207:			case rows.mc.parseTime:
      10ms      110ms   1208:				dest[i], err = parseBinaryDateTime(num, data[pos:], rows.mc.cfg.Loc)
         .          .   1209:			default:
         .          .   1210:				var dstlen uint8
         .          .   1211:				if rows.columns[i].fieldType == fieldTypeDate {
         .          .   1212:					dstlen = 10
         .          .   1213:				} else {
ROUTINE ======================== github.com/go-sql-driver/mysql.(*buffer).fill in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/buffer.go
      40ms      1.73s (flat, cum)  3.11% of Total
         .          .     41:func (b *buffer) fill(need int) error {
         .          .     42:	n := b.length
         .          .     43:
         .          .     44:	// move existing data to the beginning
         .          .     45:	if n > 0 && b.idx > 0 {
         .       20ms     46:		copy(b.buf[0:n], b.buf[b.idx:])
         .          .     47:	}
         .          .     48:
         .          .     49:	// grow buffer if necessary
         .          .     50:	// TODO: let the buffer shrink again at some point
         .          .     51:	//       Maybe keep the org buf slice and swap back?
         .          .     52:	if need > len(b.buf) {
         .          .     53:		// Round up to the next multiple of the default size
         .      650ms     54:		newBuf := make([]byte, ((need/defaultBufSize)+1)*defaultBufSize)
         .       10ms     55:		copy(newBuf, b.buf)
         .          .     56:		b.buf = newBuf
         .          .     57:	}
         .          .     58:
         .          .     59:	b.idx = 0
         .          .     60:
         .          .     61:	for {
      10ms       10ms     62:		if b.timeout > 0 {
         .          .     63:			if err := b.nc.SetReadDeadline(time.Now().Add(b.timeout)); err != nil {
         .          .     64:				return err
         .          .     65:			}
         .          .     66:		}
         .          .     67:
      10ms      1.02s     68:		nn, err := b.nc.Read(b.buf[n:])
         .          .     69:		n += nn
         .          .     70:
      10ms       10ms     71:		switch err {
         .          .     72:		case nil:
         .          .     73:			if n < need {
         .          .     74:				continue
         .          .     75:			}
      10ms       10ms     76:			b.length = n
         .          .     77:			return nil
         .          .     78:
         .          .     79:		case io.EOF:
         .          .     80:			if n >= need {
         .          .     81:				b.length = n
ROUTINE ======================== github.com/go-sql-driver/mysql.(*buffer).readNext in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/buffer.go
     150ms      1.88s (flat, cum)  3.38% of Total
         .          .     89:	}
         .          .     90:}
         .          .     91:
         .          .     92:// returns next N bytes from buffer.
         .          .     93:// The returned slice is only guaranteed to be valid until the next read
      60ms       60ms     94:func (b *buffer) readNext(need int) ([]byte, error) {
         .          .     95:	if b.length < need {
         .          .     96:		// refill
         .      1.73s     97:		if err := b.fill(need); err != nil {
         .          .     98:			return nil, err
         .          .     99:		}
         .          .    100:	}
         .          .    101:
         .          .    102:	offset := b.idx
      30ms       30ms    103:	b.idx += need
         .          .    104:	b.length -= need
      60ms       60ms    105:	return b.buf[offset:b.idx], nil
         .          .    106:}
         .          .    107:
         .          .    108:// returns a buffer with the requested size.
         .          .    109:// If possible, a slice from the existing buffer is returned.
         .          .    110:// Otherwise a bigger buffer is made.
ROUTINE ======================== github.com/go-sql-driver/mysql.(*converter).ConvertValue in <autogenerated>
         0       40ms (flat, cum) 0.072% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlConn).Close in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/connection.go
         0       50ms (flat, cum)  0.09% of Total
         .          .     76:}
         .          .     77:
         .          .     78:func (mc *mysqlConn) Close() (err error) {
         .          .     79:	// Makes Close idempotent
         .          .     80:	if mc.netConn != nil {
         .       10ms     81:		err = mc.writeCommandPacket(comQuit)
         .          .     82:	}
         .          .     83:
         .       40ms     84:	mc.cleanup()
         .          .     85:
         .          .     86:	return
         .          .     87:}
         .          .     88:
         .          .     89:// Closes the network connection and unsets internal variables. Do not call this
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlConn).Prepare in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/connection.go
      20ms      910ms (flat, cum)  1.64% of Total
         .          .    100:	}
         .          .    101:	mc.cfg = nil
         .          .    102:	mc.buf.nc = nil
         .          .    103:}
         .          .    104:
      20ms       20ms    105:func (mc *mysqlConn) Prepare(query string) (driver.Stmt, error) {
         .          .    106:	if mc.netConn == nil {
         .          .    107:		errLog.Print(ErrInvalidConn)
         .          .    108:		return nil, driver.ErrBadConn
         .          .    109:	}
         .          .    110:	// Send command
         .      640ms    111:	err := mc.writeCommandPacketStr(comStmtPrepare, query)
         .          .    112:	if err != nil {
         .          .    113:		return nil, err
         .          .    114:	}
         .          .    115:
         .          .    116:	stmt := &mysqlStmt{
         .       10ms    117:		mc: mc,
         .          .    118:	}
         .          .    119:
         .          .    120:	// Read Result
         .      190ms    121:	columnCount, err := stmt.readPrepareResultPacket()
         .          .    122:	if err == nil {
         .          .    123:		if stmt.paramCount > 0 {
         .       20ms    124:			if err = mc.readUntilEOF(); err != nil {
         .          .    125:				return nil, err
         .          .    126:			}
         .          .    127:		}
         .          .    128:
         .          .    129:		if columnCount > 0 {
         .       30ms    130:			err = mc.readUntilEOF()
         .          .    131:		}
         .          .    132:	}
         .          .    133:
         .          .    134:	return stmt, err
         .          .    135:}
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlConn).Query in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/connection.go
      10ms       70ms (flat, cum)  0.13% of Total
         .          .    300:	}
         .          .    301:
         .          .    302:	return err
         .          .    303:}
         .          .    304:
      10ms       10ms    305:func (mc *mysqlConn) Query(query string, args []driver.Value) (driver.Rows, error) {
         .          .    306:	if mc.netConn == nil {
         .          .    307:		errLog.Print(ErrInvalidConn)
         .          .    308:		return nil, driver.ErrBadConn
         .          .    309:	}
         .          .    310:	if len(args) != 0 {
         .          .    311:		if !mc.cfg.InterpolateParams {
         .          .    312:			return nil, driver.ErrSkip
         .          .    313:		}
         .          .    314:		// try client-side prepare to reduce roundtrip
         .          .    315:		prepared, err := mc.interpolateParams(query, args)
         .          .    316:		if err != nil {
         .          .    317:			return nil, err
         .          .    318:		}
         .          .    319:		query = prepared
         .          .    320:		args = nil
         .          .    321:	}
         .          .    322:	// Send command
         .          .    323:	err := mc.writeCommandPacketStr(comQuery, query)
         .          .    324:	if err == nil {
         .          .    325:		// Read Result
         .          .    326:		var resLen int
         .       30ms    327:		resLen, err = mc.readResultSetHeaderPacket()
         .          .    328:		if err == nil {
         .       30ms    329:			rows := new(textRows)
         .          .    330:			rows.mc = mc
         .          .    331:
         .          .    332:			if resLen == 0 {
         .          .    333:				// no columns, no more data
         .          .    334:				return emptyRows{}, nil
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlConn).cleanup in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/connection.go
         0       40ms (flat, cum) 0.072% of Total
         .          .     91:// is called before auth or on auth failure because MySQL will have already
         .          .     92:// closed the network connection.
         .          .     93:func (mc *mysqlConn) cleanup() {
         .          .     94:	// Makes cleanup idempotent
         .          .     95:	if mc.netConn != nil {
         .       40ms     96:		if err := mc.netConn.Close(); err != nil {
         .          .     97:			errLog.Print(err)
         .          .     98:		}
         .          .     99:		mc.netConn = nil
         .          .    100:	}
         .          .    101:	mc.cfg = nil
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlConn).exec in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/connection.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    282:}
         .          .    283:
         .          .    284:// Internal function to execute commands
         .          .    285:func (mc *mysqlConn) exec(query string) error {
         .          .    286:	// Send command
         .       30ms    287:	err := mc.writeCommandPacketStr(comQuery, query)
         .          .    288:	if err != nil {
         .          .    289:		return err
         .          .    290:	}
         .          .    291:
         .          .    292:	// Read Result
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlConn).getSystemVar in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/connection.go
         0       50ms (flat, cum)  0.09% of Total
         .          .    343:
         .          .    344:// Gets the value of the given MySQL System Variable
         .          .    345:// The returned byte slice is only valid until the next read
         .          .    346:func (mc *mysqlConn) getSystemVar(name string) ([]byte, error) {
         .          .    347:	// Send command
         .       30ms    348:	if err := mc.writeCommandPacketStr(comQuery, "SELECT @@"+name); err != nil {
         .          .    349:		return nil, err
         .          .    350:	}
         .          .    351:
         .          .    352:	// Read Result
         .          .    353:	resLen, err := mc.readResultSetHeaderPacket()
         .          .    354:	if err == nil {
         .          .    355:		rows := new(textRows)
         .          .    356:		rows.mc = mc
         .       10ms    357:		rows.columns = []mysqlField{{fieldType: fieldTypeVarChar}}
         .          .    358:
         .          .    359:		if resLen > 0 {
         .          .    360:			// Columns
         .          .    361:			if err := mc.readUntilEOF(); err != nil {
         .          .    362:				return nil, err
         .          .    363:			}
         .          .    364:		}
         .          .    365:
         .          .    366:		dest := make([]driver.Value, resLen)
         .       10ms    367:		if err = rows.readRow(dest); err == nil {
         .          .    368:			return dest[0].([]byte), mc.readUntilEOF()
         .          .    369:		}
         .          .    370:	}
         .          .    371:	return nil, err
         .          .    372:}
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlConn).handleParams in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/connection.go
         0       30ms (flat, cum) 0.054% of Total
         .          .     39:		// Charset
         .          .     40:		case "charset":
         .          .     41:			charsets := strings.Split(val, ",")
         .          .     42:			for i := range charsets {
         .          .     43:				// ignore errors here - a charset may not exist
         .       30ms     44:				err = mc.exec("SET NAMES " + charsets[i])
         .          .     45:				if err == nil {
         .          .     46:					break
         .          .     47:				}
         .          .     48:			}
         .          .     49:			if err != nil {
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlConn).readColumns in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/packets.go
      40ms      230ms (flat, cum)  0.41% of Total
         .          .    568:}
         .          .    569:
         .          .    570:// Read Packets as Field Packets until EOF-Packet or an Error appears
         .          .    571:// http://dev.mysql.com/doc/internals/en/com-query-response.html#packet-Protocol::ColumnDefinition41
         .          .    572:func (mc *mysqlConn) readColumns(count int) ([]mysqlField, error) {
         .      140ms    573:	columns := make([]mysqlField, count)
         .          .    574:
         .          .    575:	for i := 0; ; i++ {
         .       10ms    576:		data, err := mc.readPacket()
         .          .    577:		if err != nil {
         .          .    578:			return nil, err
         .          .    579:		}
         .          .    580:
         .          .    581:		// EOF Packet
      10ms       10ms    582:		if data[0] == iEOF && (len(data) == 5 || len(data) == 1) {
         .          .    583:			if i == count {
         .          .    584:				return columns, nil
         .          .    585:			}
         .          .    586:			return nil, fmt.Errorf("column count mismatch n:%d len:%d", count, len(columns))
         .          .    587:		}
         .          .    588:
         .          .    589:		// Catalog
         .          .    590:		pos, err := skipLengthEncodedString(data)
         .          .    591:		if err != nil {
         .          .    592:			return nil, err
         .          .    593:		}
         .          .    594:
         .          .    595:		// Database [len coded string]
      10ms       10ms    596:		n, err := skipLengthEncodedString(data[pos:])
         .          .    597:		if err != nil {
         .          .    598:			return nil, err
         .          .    599:		}
         .          .    600:		pos += n
         .          .    601:
         .          .    602:		// Table [len coded string]
      10ms       10ms    603:		if mc.cfg.ColumnsWithAlias {
         .          .    604:			tableName, _, n, err := readLengthEncodedString(data[pos:])
         .          .    605:			if err != nil {
         .          .    606:				return nil, err
         .          .    607:			}
         .          .    608:			pos += n
         .          .    609:			columns[i].tableName = string(tableName)
         .          .    610:		} else {
         .          .    611:			n, err = skipLengthEncodedString(data[pos:])
         .          .    612:			if err != nil {
         .          .    613:				return nil, err
         .          .    614:			}
         .          .    615:			pos += n
         .          .    616:		}
         .          .    617:
         .          .    618:		// Original table [len coded string]
         .          .    619:		n, err = skipLengthEncodedString(data[pos:])
         .          .    620:		if err != nil {
         .          .    621:			return nil, err
         .          .    622:		}
         .          .    623:		pos += n
         .          .    624:
         .          .    625:		// Name [len coded string]
         .          .    626:		name, _, n, err := readLengthEncodedString(data[pos:])
         .          .    627:		if err != nil {
         .          .    628:			return nil, err
         .          .    629:		}
         .       40ms    630:		columns[i].name = string(name)
         .          .    631:		pos += n
         .          .    632:
         .          .    633:		// Original name [len coded string]
         .          .    634:		n, err = skipLengthEncodedString(data[pos:])
         .          .    635:		if err != nil {
         .          .    636:			return nil, err
         .          .    637:		}
         .          .    638:
         .          .    639:		// Filler [uint8]
         .          .    640:		// Charset [charset, collation uint8]
         .          .    641:		// Length [uint32]
         .          .    642:		pos += n + 1 + 2 + 4
         .          .    643:
         .          .    644:		// Field type [uint8]
         .          .    645:		columns[i].fieldType = data[pos]
         .          .    646:		pos++
         .          .    647:
         .          .    648:		// Flags [uint16]
      10ms       10ms    649:		columns[i].flags = fieldFlag(binary.LittleEndian.Uint16(data[pos : pos+2]))
         .          .    650:		pos += 2
         .          .    651:
         .          .    652:		// Decimals [uint8]
         .          .    653:		columns[i].decimals = data[pos]
         .          .    654:		//pos++
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlConn).readPacket in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/packets.go
     250ms      2.13s (flat, cum)  3.83% of Total
         .          .     22:
         .          .     23:// Packets documentation:
         .          .     24:// http://dev.mysql.com/doc/internals/en/client-server-protocol.html
         .          .     25:
         .          .     26:// Read packet to buffer 'data'
      60ms       60ms     27:func (mc *mysqlConn) readPacket() ([]byte, error) {
      10ms       10ms     28:	var payload []byte
         .          .     29:	for {
         .          .     30:		// Read packet header
      30ms      730ms     31:		data, err := mc.buf.readNext(4)
      10ms       10ms     32:		if err != nil {
         .          .     33:			errLog.Print(err)
         .          .     34:			mc.Close()
         .          .     35:			return nil, driver.ErrBadConn
         .          .     36:		}
         .          .     37:
         .          .     38:		// Packet Length [24 bit]
      70ms       70ms     39:		pktLen := int(uint32(data[0]) | uint32(data[1])<<8 | uint32(data[2])<<16)
         .          .     40:
         .          .     41:		if pktLen < 1 {
         .          .     42:			errLog.Print(ErrMalformPkt)
         .          .     43:			mc.Close()
         .          .     44:			return nil, driver.ErrBadConn
         .          .     45:		}
         .          .     46:
         .          .     47:		// Check Packet Sync [8 bit]
      10ms       10ms     48:		if data[3] != mc.sequence {
         .          .     49:			if data[3] > mc.sequence {
         .          .     50:				return nil, ErrPktSyncMul
         .          .     51:			}
         .          .     52:			return nil, ErrPktSync
         .          .     53:		}
         .          .     54:		mc.sequence++
         .          .     55:
         .          .     56:		// Read packet body [pktLen bytes]
      40ms      1.22s     57:		data, err = mc.buf.readNext(pktLen)
         .          .     58:		if err != nil {
         .          .     59:			errLog.Print(err)
         .          .     60:			mc.Close()
         .          .     61:			return nil, driver.ErrBadConn
         .          .     62:		}
         .          .     63:
         .          .     64:		isLastPacket := (pktLen < maxPacketSize)
         .          .     65:
         .          .     66:		// Zero allocations for non-splitting packets
         .          .     67:		if isLastPacket && payload == nil {
      20ms       20ms     68:			return data, nil
         .          .     69:		}
         .          .     70:
         .          .     71:		payload = append(payload, data...)
         .          .     72:
         .          .     73:		if isLastPacket {
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlConn).readResultSetHeaderPacket in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/packets.go
         0      470ms (flat, cum)  0.84% of Total
         .          .    478:}
         .          .    479:
         .          .    480:// Result Set Header Packet
         .          .    481:// http://dev.mysql.com/doc/internals/en/com-query-response.html#packet-ProtocolText::Resultset
         .          .    482:func (mc *mysqlConn) readResultSetHeaderPacket() (int, error) {
         .      470ms    483:	data, err := mc.readPacket()
         .          .    484:	if err == nil {
         .          .    485:		switch data[0] {
         .          .    486:
         .          .    487:		case iOK:
         .          .    488:			return 0, mc.handleOkPacket(data)
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlConn).readUntilEOF in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/packets.go
      20ms       70ms (flat, cum)  0.13% of Total
         .          .    724:
         .          .    725:	return nil
         .          .    726:}
         .          .    727:
         .          .    728:// Reads Packets until EOF-Packet or an Error appears. Returns count of Packets read
      10ms       10ms    729:func (mc *mysqlConn) readUntilEOF() error {
         .          .    730:	for {
         .       50ms    731:		data, err := mc.readPacket()
         .          .    732:
         .          .    733:		// No Err and no EOF Packet
         .          .    734:		if err == nil && data[0] != iEOF {
         .          .    735:			continue
         .          .    736:		}
         .          .    737:		if err == nil && data[0] == iEOF && len(data) == 5 {
      10ms       10ms    738:			mc.status = readStatus(data[3:])
         .          .    739:		}
         .          .    740:
         .          .    741:		return err // Err or EOF
         .          .    742:	}
         .          .    743:}
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlConn).writeAuthPacket in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/packets.go
         0       40ms (flat, cum) 0.072% of Total
         .          .    326:	// Assume native client during response
         .          .    327:	pos += copy(data[pos:], "mysql_native_password")
         .          .    328:	data[pos] = 0x00
         .          .    329:
         .          .    330:	// Send Auth packet
         .       40ms    331:	return mc.writePacket(data)
         .          .    332:}
         .          .    333:
         .          .    334://  Client old authentication packet
         .          .    335:// http://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::AuthSwitchResponse
         .          .    336:func (mc *mysqlConn) writeOldAuthPacket(cipher []byte) error {
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlConn).writeCommandPacket in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/packets.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    389:
         .          .    390:	// Add command byte
         .          .    391:	data[4] = command
         .          .    392:
         .          .    393:	// Send CMD packet
         .       10ms    394:	return mc.writePacket(data)
         .          .    395:}
         .          .    396:
         .          .    397:func (mc *mysqlConn) writeCommandPacketStr(command byte, arg string) error {
         .          .    398:	// Reset Packet Sequence
         .          .    399:	mc.sequence = 0
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlConn).writeCommandPacketStr in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/packets.go
         0      700ms (flat, cum)  1.26% of Total
         .          .    408:
         .          .    409:	// Add command byte
         .          .    410:	data[4] = command
         .          .    411:
         .          .    412:	// Add arg
         .       10ms    413:	copy(data[5:], arg)
         .          .    414:
         .          .    415:	// Send CMD packet
         .      690ms    416:	return mc.writePacket(data)
         .          .    417:}
         .          .    418:
         .          .    419:func (mc *mysqlConn) writeCommandPacketUint32(command byte, arg uint32) error {
         .          .    420:	// Reset Packet Sequence
         .          .    421:	mc.sequence = 0
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlConn).writeCommandPacketUint32 in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/packets.go
         0      730ms (flat, cum)  1.31% of Total
         .          .    435:	data[6] = byte(arg >> 8)
         .          .    436:	data[7] = byte(arg >> 16)
         .          .    437:	data[8] = byte(arg >> 24)
         .          .    438:
         .          .    439:	// Send CMD packet
         .      730ms    440:	return mc.writePacket(data)
         .          .    441:}
         .          .    442:
         .          .    443:/******************************************************************************
         .          .    444:*                              Result Packets                                 *
         .          .    445:******************************************************************************/
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlConn).writePacket in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/packets.go
      40ms      2.18s (flat, cum)  3.92% of Total
         .          .     95:			data[0] = byte(pktLen)
         .          .     96:			data[1] = byte(pktLen >> 8)
         .          .     97:			data[2] = byte(pktLen >> 16)
         .          .     98:			size = pktLen
         .          .     99:		}
      10ms       10ms    100:		data[3] = mc.sequence
         .          .    101:
         .          .    102:		// Write packet
         .          .    103:		if mc.writeTimeout > 0 {
         .          .    104:			if err := mc.netConn.SetWriteDeadline(time.Now().Add(mc.writeTimeout)); err != nil {
         .          .    105:				return err
         .          .    106:			}
         .          .    107:		}
         .          .    108:
      20ms      2.16s    109:		n, err := mc.netConn.Write(data[:4+size])
         .          .    110:		if err == nil && n == 4+size {
      10ms       10ms    111:			mc.sequence++
         .          .    112:			if size != maxPacketSize {
         .          .    113:				return nil
         .          .    114:			}
         .          .    115:			pktLen -= size
         .          .    116:			data = data[size:]
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlRows).Close in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/rows.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     62:	if mc.netConn == nil {
         .          .     63:		return ErrInvalidConn
         .          .     64:	}
         .          .     65:
         .          .     66:	// Remove unread packets from stream
         .       20ms     67:	err := mc.readUntilEOF()
         .          .     68:	if err == nil {
         .          .     69:		if err = mc.discardResults(); err != nil {
         .          .     70:			return err
         .          .     71:		}
         .          .     72:	}
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlRows).Columns in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/rows.go
         0       90ms (flat, cum)  0.16% of Total
         .          .     35:}
         .          .     36:
         .          .     37:type emptyRows struct{}
         .          .     38:
         .          .     39:func (rows *mysqlRows) Columns() []string {
         .       80ms     40:	columns := make([]string, len(rows.columns))
         .          .     41:	if rows.mc != nil && rows.mc.cfg.ColumnsWithAlias {
         .          .     42:		for i := range columns {
         .          .     43:			if tableName := rows.columns[i].tableName; len(tableName) > 0 {
         .          .     44:				columns[i] = tableName + "." + rows.columns[i].name
         .          .     45:			} else {
         .          .     46:				columns[i] = rows.columns[i].name
         .          .     47:			}
         .          .     48:		}
         .          .     49:	} else {
         .          .     50:		for i := range columns {
         .       10ms     51:			columns[i] = rows.columns[i].name
         .          .     52:		}
         .          .     53:	}
         .          .     54:	return columns
         .          .     55:}
         .          .     56:
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlStmt).Close in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/statement.go
      30ms      760ms (flat, cum)  1.37% of Total
         .          .     26:	if stmt.mc == nil || stmt.mc.netConn == nil {
         .          .     27:		errLog.Print(ErrInvalidConn)
         .          .     28:		return driver.ErrBadConn
         .          .     29:	}
         .          .     30:
      30ms      760ms     31:	err := stmt.mc.writeCommandPacketUint32(comStmtClose, stmt.id)
         .          .     32:	stmt.mc = nil
         .          .     33:	return err
         .          .     34:}
         .          .     35:
         .          .     36:func (stmt *mysqlStmt) NumInput() int {
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlStmt).ColumnConverter in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/statement.go
         0       40ms (flat, cum) 0.072% of Total
         .          .     36:func (stmt *mysqlStmt) NumInput() int {
         .          .     37:	return stmt.paramCount
         .          .     38:}
         .          .     39:
         .          .     40:func (stmt *mysqlStmt) ColumnConverter(idx int) driver.ValueConverter {
         .       40ms     41:	return converter{}
         .          .     42:}
         .          .     43:
         .          .     44:func (stmt *mysqlStmt) Exec(args []driver.Value) (driver.Result, error) {
         .          .     45:	if stmt.mc.netConn == nil {
         .          .     46:		errLog.Print(ErrInvalidConn)
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlStmt).Exec in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/statement.go
         0       80ms (flat, cum)  0.14% of Total
         .          .     45:	if stmt.mc.netConn == nil {
         .          .     46:		errLog.Print(ErrInvalidConn)
         .          .     47:		return nil, driver.ErrBadConn
         .          .     48:	}
         .          .     49:	// Send command
         .       50ms     50:	err := stmt.writeExecutePacket(args)
         .          .     51:	if err != nil {
         .          .     52:		return nil, err
         .          .     53:	}
         .          .     54:
         .          .     55:	mc := stmt.mc
         .          .     56:
         .          .     57:	mc.affectedRows = 0
         .          .     58:	mc.insertId = 0
         .          .     59:
         .          .     60:	// Read Result
         .          .     61:	resLen, err := mc.readResultSetHeaderPacket()
         .          .     62:	if err == nil {
         .          .     63:		if resLen > 0 {
         .          .     64:			// Columns
         .          .     65:			err = mc.readUntilEOF()
         .          .     66:			if err != nil {
         .          .     67:				return nil, err
         .          .     68:			}
         .          .     69:
         .          .     70:			// Rows
         .          .     71:			err = mc.readUntilEOF()
         .          .     72:		}
         .          .     73:		if err == nil {
         .          .     74:			return &mysqlResult{
         .          .     75:				affectedRows: int64(mc.affectedRows),
         .       30ms     76:				insertId:     int64(mc.insertId),
         .          .     77:			}, nil
         .          .     78:		}
         .          .     79:	}
         .          .     80:
         .          .     81:	return nil, err
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlStmt).Query in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/statement.go
      20ms      1.74s (flat, cum)  3.13% of Total
         .          .     85:	if stmt.mc.netConn == nil {
         .          .     86:		errLog.Print(ErrInvalidConn)
         .          .     87:		return nil, driver.ErrBadConn
         .          .     88:	}
         .          .     89:	// Send command
      10ms      740ms     90:	err := stmt.writeExecutePacket(args)
         .          .     91:	if err != nil {
         .          .     92:		return nil, err
         .          .     93:	}
         .          .     94:
         .          .     95:	mc := stmt.mc
         .          .     96:
         .          .     97:	// Read Result
      10ms      450ms     98:	resLen, err := mc.readResultSetHeaderPacket()
         .          .     99:	if err != nil {
         .          .    100:		return nil, err
         .          .    101:	}
         .          .    102:
         .      310ms    103:	rows := new(binaryRows)
         .          .    104:
         .          .    105:	if resLen > 0 {
         .          .    106:		rows.mc = mc
         .          .    107:		// Columns
         .          .    108:		// If not cached, read them and cache them
         .          .    109:		if stmt.columns == nil {
         .      230ms    110:			rows.columns, err = mc.readColumns(resLen)
         .       10ms    111:			stmt.columns = rows.columns
         .          .    112:		} else {
         .          .    113:			rows.columns = stmt.columns
         .          .    114:			err = mc.readUntilEOF()
         .          .    115:		}
         .          .    116:	}
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlStmt).readPrepareResultPacket in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/packets.go
      10ms      190ms (flat, cum)  0.34% of Total
         .          .    747:******************************************************************************/
         .          .    748:
         .          .    749:// Prepare Result Packets
         .          .    750:// http://dev.mysql.com/doc/internals/en/com-stmt-prepare-response.html
         .          .    751:func (stmt *mysqlStmt) readPrepareResultPacket() (uint16, error) {
         .      180ms    752:	data, err := stmt.mc.readPacket()
         .          .    753:	if err == nil {
         .          .    754:		// packet indicator [1 byte]
         .          .    755:		if data[0] != iOK {
         .          .    756:			return 0, stmt.mc.handleErrorPacket(data)
         .          .    757:		}
         .          .    758:
         .          .    759:		// statement id [4 bytes]
         .          .    760:		stmt.id = binary.LittleEndian.Uint32(data[1:5])
         .          .    761:
         .          .    762:		// Column count [16 bit uint]
         .          .    763:		columnCount := binary.LittleEndian.Uint16(data[5:7])
         .          .    764:
         .          .    765:		// Param count [16 bit uint]
      10ms       10ms    766:		stmt.paramCount = int(binary.LittleEndian.Uint16(data[7:9]))
         .          .    767:
         .          .    768:		// Reserved [8 bit]
         .          .    769:
         .          .    770:		// Warning count [16 bit uint]
         .          .    771:		if !stmt.mc.strict {
ROUTINE ======================== github.com/go-sql-driver/mysql.(*mysqlStmt).writeExecutePacket in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/packets.go
      40ms      780ms (flat, cum)  1.40% of Total
         .          .    867:	data[4] = comStmtExecute
         .          .    868:
         .          .    869:	// statement_id [4 bytes]
         .          .    870:	data[5] = byte(stmt.id)
         .          .    871:	data[6] = byte(stmt.id >> 8)
      10ms       10ms    872:	data[7] = byte(stmt.id >> 16)
         .          .    873:	data[8] = byte(stmt.id >> 24)
         .          .    874:
         .          .    875:	// flags (0: CURSOR_TYPE_NO_CURSOR) [1 byte]
         .          .    876:	data[9] = 0x00
         .          .    877:
         .          .    878:	// iteration_count (uint32(1)) [4 bytes]
         .          .    879:	data[10] = 0x01
         .          .    880:	data[11] = 0x00
         .          .    881:	data[12] = 0x00
         .          .    882:	data[13] = 0x00
         .          .    883:
         .          .    884:	if len(args) > 0 {
         .          .    885:		pos := minPktLen
         .          .    886:
      10ms       10ms    887:		var nullMask []byte
         .          .    888:		if maskLen, typesLen := (len(args)+7)/8, 1+2*len(args); pos+maskLen+typesLen >= len(data) {
         .          .    889:			// buffer has to be extended but we don't know by how much so
         .          .    890:			// we depend on append after all data with known sizes fit.
         .          .    891:			// We stop at that because we deal with a lot of columns here
         .          .    892:			// which makes the required allocation size hard to guess.
         .          .    893:			tmp := make([]byte, pos+maskLen+typesLen)
         .          .    894:			copy(tmp[:pos], data[:pos])
         .          .    895:			data = tmp
         .          .    896:			nullMask = data[pos : pos+maskLen]
         .          .    897:			pos += maskLen
         .          .    898:		} else {
         .          .    899:			nullMask = data[pos : pos+maskLen]
         .          .    900:			for i := 0; i < maskLen; i++ {
         .          .    901:				nullMask[i] = 0
         .          .    902:			}
         .          .    903:			pos += maskLen
         .          .    904:		}
         .          .    905:
         .          .    906:		// newParameterBoundFlag 1 [1 byte]
         .          .    907:		data[pos] = 0x01
         .          .    908:		pos++
         .          .    909:
         .          .    910:		// type of each parameter [len(args)*2 bytes]
         .          .    911:		paramTypes := data[pos:]
         .          .    912:		pos += len(args) * 2
         .          .    913:
         .          .    914:		// value of each parameter [n bytes]
         .          .    915:		paramValues := data[pos:pos]
         .          .    916:		valuesCap := cap(paramValues)
         .          .    917:
         .          .    918:		for i, arg := range args {
         .          .    919:			// build NULL-bitmap
         .          .    920:			if arg == nil {
         .          .    921:				nullMask[i/8] |= 1 << (uint(i) & 7)
         .          .    922:				paramTypes[i+i] = fieldTypeNULL
         .          .    923:				paramTypes[i+i+1] = 0x00
         .          .    924:				continue
         .          .    925:			}
         .          .    926:
         .          .    927:			// cache types and values
         .          .    928:			switch v := arg.(type) {
         .          .    929:			case int64:
         .          .    930:				paramTypes[i+i] = fieldTypeLongLong
         .          .    931:				paramTypes[i+i+1] = 0x00
         .          .    932:
      10ms       10ms    933:				if cap(paramValues)-len(paramValues)-8 >= 0 {
         .          .    934:					paramValues = paramValues[:len(paramValues)+8]
         .          .    935:					binary.LittleEndian.PutUint64(
         .          .    936:						paramValues[len(paramValues)-8:],
         .          .    937:						uint64(v),
         .          .    938:					)
         .          .    939:				} else {
         .          .    940:					paramValues = append(paramValues,
         .          .    941:						uint64ToBytes(uint64(v))...,
         .          .    942:					)
         .          .    943:				}
         .          .    944:
         .          .    945:			case float64:
         .          .    946:				paramTypes[i+i] = fieldTypeDouble
         .          .    947:				paramTypes[i+i+1] = 0x00
         .          .    948:
         .          .    949:				if cap(paramValues)-len(paramValues)-8 >= 0 {
         .          .    950:					paramValues = paramValues[:len(paramValues)+8]
         .          .    951:					binary.LittleEndian.PutUint64(
         .          .    952:						paramValues[len(paramValues)-8:],
         .          .    953:						math.Float64bits(v),
         .          .    954:					)
         .          .    955:				} else {
         .          .    956:					paramValues = append(paramValues,
         .          .    957:						uint64ToBytes(math.Float64bits(v))...,
         .          .    958:					)
         .          .    959:				}
         .          .    960:
         .          .    961:			case bool:
         .          .    962:				paramTypes[i+i] = fieldTypeTiny
         .          .    963:				paramTypes[i+i+1] = 0x00
         .          .    964:
         .          .    965:				if v {
         .          .    966:					paramValues = append(paramValues, 0x01)
         .          .    967:				} else {
         .          .    968:					paramValues = append(paramValues, 0x00)
         .          .    969:				}
         .          .    970:
         .          .    971:			case []byte:
         .          .    972:				// Common case (non-nil value) first
         .          .    973:				if v != nil {
         .          .    974:					paramTypes[i+i] = fieldTypeString
         .          .    975:					paramTypes[i+i+1] = 0x00
         .          .    976:
         .          .    977:					if len(v) < mc.maxPacketAllowed-pos-len(paramValues)-(len(args)-(i+1))*64 {
         .          .    978:						paramValues = appendLengthEncodedInteger(paramValues,
         .          .    979:							uint64(len(v)),
         .          .    980:						)
         .          .    981:						paramValues = append(paramValues, v...)
         .          .    982:					} else {
         .          .    983:						if err := stmt.writeCommandLongData(i, v); err != nil {
         .          .    984:							return err
         .          .    985:						}
         .          .    986:					}
         .          .    987:					continue
         .          .    988:				}
         .          .    989:
         .          .    990:				// Handle []byte(nil) as a NULL value
         .          .    991:				nullMask[i/8] |= 1 << (uint(i) & 7)
         .          .    992:				paramTypes[i+i] = fieldTypeNULL
         .          .    993:				paramTypes[i+i+1] = 0x00
         .          .    994:
         .          .    995:			case string:
         .          .    996:				paramTypes[i+i] = fieldTypeString
         .          .    997:				paramTypes[i+i+1] = 0x00
         .          .    998:
         .          .    999:				if len(v) < mc.maxPacketAllowed-pos-len(paramValues)-(len(args)-(i+1))*64 {
         .          .   1000:					paramValues = appendLengthEncodedInteger(paramValues,
         .          .   1001:						uint64(len(v)),
         .          .   1002:					)
         .          .   1003:					paramValues = append(paramValues, v...)
         .          .   1004:				} else {
         .          .   1005:					if err := stmt.writeCommandLongData(i, []byte(v)); err != nil {
         .          .   1006:						return err
         .          .   1007:					}
         .          .   1008:				}
         .          .   1009:
         .          .   1010:			case time.Time:
         .          .   1011:				paramTypes[i+i] = fieldTypeString
         .          .   1012:				paramTypes[i+i+1] = 0x00
         .          .   1013:
         .          .   1014:				var val []byte
         .          .   1015:				if v.IsZero() {
         .          .   1016:					val = []byte("0000-00-00")
         .          .   1017:				} else {
         .          .   1018:					val = []byte(v.In(mc.cfg.Loc).Format(timeFormat))
         .          .   1019:				}
         .          .   1020:
         .          .   1021:				paramValues = appendLengthEncodedInteger(paramValues,
         .          .   1022:					uint64(len(val)),
         .          .   1023:				)
         .          .   1024:				paramValues = append(paramValues, val...)
         .          .   1025:
         .          .   1026:			default:
         .          .   1027:				return fmt.Errorf("can not convert type: %T", arg)
         .          .   1028:			}
         .          .   1029:		}
         .          .   1030:
         .          .   1031:		// Check if param values exceeded the available buffer
         .          .   1032:		// In that case we must build the data packet with the new values buffer
         .          .   1033:		if valuesCap != cap(paramValues) {
         .       30ms   1034:			data = append(data[:pos], paramValues...)
         .          .   1035:			mc.buf.buf = data
         .          .   1036:		}
         .          .   1037:
         .          .   1038:		pos += len(paramValues)
         .          .   1039:		data = data[:pos]
         .          .   1040:	}
         .          .   1041:
      10ms      720ms   1042:	return mc.writePacket(data)
         .          .   1043:}
         .          .   1044:
         .          .   1045:func (mc *mysqlConn) discardResults() error {
         .          .   1046:	for mc.status&statusMoreResultsExists != 0 {
         .          .   1047:		resLen, err := mc.readResultSetHeaderPacket()
ROUTINE ======================== github.com/go-sql-driver/mysql.(*textRows).Next in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/rows.go
      90ms     13.30s (flat, cum) 23.90% of Total
         .          .     85:		return rows.readRow(dest)
         .          .     86:	}
         .          .     87:	return io.EOF
         .          .     88:}
         .          .     89:
      20ms       20ms     90:func (rows *textRows) Next(dest []driver.Value) error {
      20ms       20ms     91:	if mc := rows.mc; mc != nil {
      10ms       10ms     92:		if mc.netConn == nil {
         .          .     93:			return ErrInvalidConn
         .          .     94:		}
         .          .     95:
         .          .     96:		// Fetch next row from stream
      40ms     13.25s     97:		return rows.readRow(dest)
         .          .     98:	}
         .          .     99:	return io.EOF
         .          .    100:}
         .          .    101:
         .          .    102:func (rows emptyRows) Columns() []string {
ROUTINE ======================== github.com/go-sql-driver/mysql.(*textRows).readRow in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/packets.go
     990ms     13.22s (flat, cum) 23.76% of Total
         .          .    660:	}
         .          .    661:}
         .          .    662:
         .          .    663:// Read Packets as Field Packets until EOF-Packet or an Error appears
         .          .    664:// http://dev.mysql.com/doc/internals/en/com-query-response.html#packet-ProtocolText::ResultsetRow
      20ms       20ms    665:func (rows *textRows) readRow(dest []driver.Value) error {
         .          .    666:	mc := rows.mc
         .          .    667:
         .      500ms    668:	data, err := mc.readPacket()
         .          .    669:	if err != nil {
         .          .    670:		return err
         .          .    671:	}
         .          .    672:
         .          .    673:	// EOF Packet
      20ms       20ms    674:	if data[0] == iEOF && len(data) == 5 {
         .          .    675:		// server_status [2 bytes]
         .          .    676:		rows.mc.status = readStatus(data[3:])
         .          .    677:		if err := rows.mc.discardResults(); err != nil {
         .          .    678:			return err
         .          .    679:		}
         .          .    680:		rows.mc = nil
         .          .    681:		return io.EOF
         .          .    682:	}
      40ms       40ms    683:	if data[0] == iERR {
         .          .    684:		rows.mc = nil
         .          .    685:		return mc.handleErrorPacket(data)
         .          .    686:	}
         .          .    687:
         .          .    688:	// RowSet Packet
         .          .    689:	var n int
         .          .    690:	var isNull bool
         .          .    691:	pos := 0
         .          .    692:
     120ms      120ms    693:	for i := range dest {
         .          .    694:		// Read bytes and convert to string
     370ms      5.17s    695:		dest[i], isNull, n, err = readLengthEncodedString(data[pos:])
      10ms       10ms    696:		pos += n
         .          .    697:		if err == nil {
         .          .    698:			if !isNull {
      10ms       10ms    699:				if !mc.parseTime {
         .          .    700:					continue
         .          .    701:				} else {
     170ms      170ms    702:					switch rows.columns[i].fieldType {
         .          .    703:					case fieldTypeTimestamp, fieldTypeDateTime,
     110ms      110ms    704:						fieldTypeDate, fieldTypeNewDate:
         .          .    705:						dest[i], err = parseDateTime(
      30ms      140ms    706:							string(dest[i].([]byte)),
         .          .    707:							mc.cfg.Loc,
      90ms      6.91s    708:						)
         .          .    709:						if err == nil {
         .          .    710:							continue
         .          .    711:						}
         .          .    712:					default:
         .          .    713:						continue
ROUTINE ======================== github.com/go-sql-driver/mysql.MySQLDriver.Open in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/driver.go
         0      790ms (flat, cum)  1.42% of Total
         .          .     51:	// New mysqlConn
         .          .     52:	mc := &mysqlConn{
         .          .     53:		maxPacketAllowed: maxPacketSize,
         .          .     54:		maxWriteSize:     maxPacketSize - 1,
         .          .     55:	}
         .       20ms     56:	mc.cfg, err = ParseDSN(dsn)
         .          .     57:	if err != nil {
         .          .     58:		return nil, err
         .          .     59:	}
         .          .     60:	mc.parseTime = mc.cfg.ParseTime
         .          .     61:	mc.strict = mc.cfg.Strict
         .          .     62:
         .          .     63:	// Connect to Server
         .          .     64:	if dial, ok := dials[mc.cfg.Net]; ok {
         .          .     65:		mc.netConn, err = dial(mc.cfg.Addr)
         .          .     66:	} else {
         .          .     67:		nd := net.Dialer{Timeout: mc.cfg.Timeout}
         .      620ms     68:		mc.netConn, err = nd.Dial(mc.cfg.Net, mc.cfg.Addr)
         .          .     69:	}
         .          .     70:	if err != nil {
         .          .     71:		return nil, err
         .          .     72:	}
         .          .     73:
         .          .     74:	// Enable TCP Keepalives on TCP connections
         .          .     75:	if tc, ok := mc.netConn.(*net.TCPConn); ok {
         .       10ms     76:		if err := tc.SetKeepAlive(true); err != nil {
         .          .     77:			// Don't send COM_QUIT before handshake.
         .          .     78:			mc.netConn.Close()
         .          .     79:			mc.netConn = nil
         .          .     80:			return nil, err
         .          .     81:		}
         .          .     82:	}
         .          .     83:
         .       20ms     84:	mc.buf = newBuffer(mc.netConn)
         .          .     85:
         .          .     86:	// Set I/O timeouts
         .          .     87:	mc.buf.timeout = mc.cfg.ReadTimeout
         .          .     88:	mc.writeTimeout = mc.cfg.WriteTimeout
         .          .     89:
         .          .     90:	// Reading Handshake Initialization Packet
         .          .     91:	cipher, err := mc.readInitPacket()
         .          .     92:	if err != nil {
         .          .     93:		mc.cleanup()
         .          .     94:		return nil, err
         .          .     95:	}
         .          .     96:
         .          .     97:	// Send Client Authentication Packet
         .       40ms     98:	if err = mc.writeAuthPacket(cipher); err != nil {
         .          .     99:		mc.cleanup()
         .          .    100:		return nil, err
         .          .    101:	}
         .          .    102:
         .          .    103:	// Handle response to auth packet, switch methods if possible
         .          .    104:	if err = handleAuthResult(mc, cipher); err != nil {
         .          .    105:		// Authentication failed and MySQL has already closed the connection
         .          .    106:		// (https://dev.mysql.com/doc/internals/en/authentication-fails.html).
         .          .    107:		// Do not send COM_QUIT, just cleanup and return the error.
         .          .    108:		mc.cleanup()
         .          .    109:		return nil, err
         .          .    110:	}
         .          .    111:
         .          .    112:	// Get max allowed packet size
         .       50ms    113:	maxap, err := mc.getSystemVar("max_allowed_packet")
         .          .    114:	if err != nil {
         .          .    115:		mc.Close()
         .          .    116:		return nil, err
         .          .    117:	}
         .          .    118:	mc.maxPacketAllowed = stringToInt(maxap) - 1
         .          .    119:	if mc.maxPacketAllowed < maxPacketSize {
         .          .    120:		mc.maxWriteSize = mc.maxPacketAllowed
         .          .    121:	}
         .          .    122:
         .          .    123:	// Handle DSN Params
         .       30ms    124:	err = mc.handleParams()
         .          .    125:	if err != nil {
         .          .    126:		mc.Close()
         .          .    127:		return nil, err
         .          .    128:	}
         .          .    129:
ROUTINE ======================== github.com/go-sql-driver/mysql.ParseDSN in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/dsn.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    297:
         .          .    298:			// dbname[?param1=value1&...&paramN=valueN]
         .          .    299:			// Find the first '?' in dsn[i+1:]
         .          .    300:			for j = i + 1; j < len(dsn); j++ {
         .          .    301:				if dsn[j] == '?' {
         .       20ms    302:					if err = parseDSNParams(cfg, dsn[j+1:]); err != nil {
         .          .    303:						return
         .          .    304:					}
         .          .    305:					break
         .          .    306:				}
         .          .    307:			}
ROUTINE ======================== github.com/go-sql-driver/mysql.converter.ConvertValue in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/statement.go
         0       40ms (flat, cum) 0.072% of Total
         .          .    123:func (c converter) ConvertValue(v interface{}) (driver.Value, error) {
         .          .    124:	if driver.IsValue(v) {
         .          .    125:		return v, nil
         .          .    126:	}
         .          .    127:
         .       10ms    128:	rv := reflect.ValueOf(v)
         .          .    129:	switch rv.Kind() {
         .          .    130:	case reflect.Ptr:
         .          .    131:		// indirect pointers
         .          .    132:		if rv.IsNil() {
         .          .    133:			return nil, nil
         .          .    134:		}
         .          .    135:		return c.ConvertValue(rv.Elem().Interface())
         .          .    136:	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
         .       30ms    137:		return rv.Int(), nil
         .          .    138:	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32:
         .          .    139:		return int64(rv.Uint()), nil
         .          .    140:	case reflect.Uint64:
         .          .    141:		u64 := rv.Uint()
         .          .    142:		if u64 >= 1<<63 {
ROUTINE ======================== github.com/go-sql-driver/mysql.parseBinaryDateTime in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/utils.go
      10ms      100ms (flat, cum)  0.18% of Total
         .          .    286:			0, 0, 0, 0,
         .          .    287:			loc,
         .          .    288:		), nil
         .          .    289:	case 7:
         .          .    290:		return time.Date(
      10ms       10ms    291:			int(binary.LittleEndian.Uint16(data[:2])), // year
         .          .    292:			time.Month(data[2]),                       // month
         .          .    293:			int(data[3]),                              // day
         .          .    294:			int(data[4]),                              // hour
         .          .    295:			int(data[5]),                              // minutes
         .          .    296:			int(data[6]),                              // seconds
         .          .    297:			0,
         .          .    298:			loc,
         .       90ms    299:		), nil
         .          .    300:	case 11:
         .          .    301:		return time.Date(
         .          .    302:			int(binary.LittleEndian.Uint16(data[:2])), // year
         .          .    303:			time.Month(data[2]),                       // month
         .          .    304:			int(data[3]),                              // day
ROUTINE ======================== github.com/go-sql-driver/mysql.parseDSNParams in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/dsn.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    341:}
         .          .    342:
         .          .    343:// parseDSNParams parses the DSN "query string"
         .          .    344:// Values must be url.QueryEscape'ed
         .          .    345:func parseDSNParams(cfg *Config, params string) (err error) {
         .       10ms    346:	for _, v := range strings.Split(params, "&") {
         .       10ms    347:		param := strings.SplitN(v, "=", 2)
         .          .    348:		if len(param) != 2 {
         .          .    349:			continue
         .          .    350:		}
         .          .    351:
         .          .    352:		// cfg params
ROUTINE ======================== github.com/go-sql-driver/mysql.parseDateTime in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/utils.go
     160ms      5.70s (flat, cum) 10.24% of Total
         .          .    249:		return nil, nil
         .          .    250:	}
         .          .    251:	return nt.Time, nil
         .          .    252:}
         .          .    253:
      10ms       10ms    254:func parseDateTime(str string, loc *time.Location) (t time.Time, err error) {
         .          .    255:	base := "0000-00-00 00:00:00.0000000"
         .          .    256:	switch len(str) {
      10ms       10ms    257:	case 10, 19, 21, 22, 23, 24, 25, 26: // up to "YYYY-MM-DD HH:MM:SS.MMMMMM"
      30ms       70ms    258:		if str == base[:len(str)] {
         .          .    259:			return
         .          .    260:		}
      60ms      4.58s    261:		t, err = time.Parse(timeFormat[:len(str)], str)
         .          .    262:	default:
         .          .    263:		err = fmt.Errorf("invalid time string: %s", str)
         .          .    264:		return
         .          .    265:	}
         .          .    266:
         .          .    267:	// Adjust location
      10ms       10ms    268:	if err == nil && loc != time.UTC {
         .      390ms    269:		y, mo, d := t.Date()
      10ms      120ms    270:		h, mi, s := t.Clock()
      30ms      510ms    271:		t, err = time.Date(y, mo, d, h, mi, s, t.Nanosecond(), loc), nil
         .          .    272:	}
         .          .    273:
         .          .    274:	return
         .          .    275:}
         .          .    276:
ROUTINE ======================== github.com/go-sql-driver/mysql.readLengthEncodedInteger in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/utils.go
     270ms      270ms (flat, cum)  0.49% of Total
         .          .    541:	}
         .          .    542:	return n, io.EOF
         .          .    543:}
         .          .    544:
         .          .    545:// returns the number read, whether the value is NULL and the number of bytes read
      30ms       30ms    546:func readLengthEncodedInteger(b []byte) (uint64, bool, int) {
         .          .    547:	// See issue #349
         .          .    548:	if len(b) == 0 {
         .          .    549:		return 0, true, 1
         .          .    550:	}
     170ms      170ms    551:	switch b[0] {
         .          .    552:
         .          .    553:	// 251: NULL
      10ms       10ms    554:	case 0xfb:
         .          .    555:		return 0, true, 1
         .          .    556:
         .          .    557:	// 252: value of following 2
      20ms       20ms    558:	case 0xfc:
         .          .    559:		return uint64(b[1]) | uint64(b[2])<<8, false, 3
         .          .    560:
         .          .    561:	// 253: value of following 3
         .          .    562:	case 0xfd:
         .          .    563:		return uint64(b[1]) | uint64(b[2])<<8 | uint64(b[3])<<16, false, 4
         .          .    564:
         .          .    565:	// 254: value of following 8
         .          .    566:	case 0xfe:
         .          .    567:		return uint64(b[1]) | uint64(b[2])<<8 | uint64(b[3])<<16 |
         .          .    568:				uint64(b[4])<<24 | uint64(b[5])<<32 | uint64(b[6])<<40 |
         .          .    569:				uint64(b[7])<<48 | uint64(b[8])<<56,
         .          .    570:			false, 9
         .          .    571:	}
         .          .    572:
         .          .    573:	// 0-250: value of first byte
      40ms       40ms    574:	return uint64(b[0]), false, 1
         .          .    575:}
         .          .    576:
         .          .    577:// encodes a uint64 value and appends it to the given bytes slice
         .          .    578:func appendLengthEncodedInteger(b []byte, n uint64) []byte {
         .          .    579:	switch {
ROUTINE ======================== github.com/go-sql-driver/mysql.readLengthEncodedString in /home/isucon/gocode/src/github.com/go-sql-driver/mysql/utils.go
     290ms      560ms (flat, cum)  1.01% of Total
         .          .    506:}
         .          .    507:
         .          .    508:// returns the string read as a bytes slice, wheter the value is NULL,
         .          .    509:// the number of bytes read and an error, in case the string is longer than
         .          .    510:// the input slice
      90ms       90ms    511:func readLengthEncodedString(b []byte) ([]byte, bool, int, error) {
         .          .    512:	// Get length
      60ms      330ms    513:	num, isNull, n := readLengthEncodedInteger(b)
         .          .    514:	if num < 1 {
         .          .    515:		return b[n:n], isNull, n, nil
         .          .    516:	}
         .          .    517:
      10ms       10ms    518:	n += int(num)
         .          .    519:
         .          .    520:	// Check data length
      10ms       10ms    521:	if len(b) >= n {
     120ms      120ms    522:		return b[n-int(num) : n], false, n, nil
         .          .    523:	}
         .          .    524:	return nil, false, n, io.EOF
         .          .    525:}
         .          .    526:
         .          .    527:// returns the number of bytes skipped and an error, in case the string is
ROUTINE ======================== github.com/gorilla/securecookie.(*GobEncoder).Deserialize in <autogenerated>
         0      110ms (flat, cum)   0.2% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== github.com/gorilla/securecookie.(*GobEncoder).Serialize in <autogenerated>
         0       40ms (flat, cum) 0.072% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== github.com/gorilla/securecookie.(*SecureCookie).Decode in /home/isucon/gocode/src/github.com/gorilla/securecookie/securecookie.go
      10ms      130ms (flat, cum)  0.23% of Total
         .          .    319:	// 3. Verify MAC. Value is "date|value|mac".
         .          .    320:	parts := bytes.SplitN(b, []byte("|"), 3)
         .          .    321:	if len(parts) != 3 {
         .          .    322:		return ErrMacInvalid
         .          .    323:	}
         .       10ms    324:	h := hmac.New(s.hashFunc, s.hashKey)
         .          .    325:	b = append([]byte(name+"|"), b[:len(b)-len(parts[2])-1]...)
         .          .    326:	if err = verifyMac(h, b, parts[2]); err != nil {
         .          .    327:		return err
         .          .    328:	}
         .          .    329:	// 4. Verify date ranges.
         .          .    330:	var t1 int64
         .          .    331:	if t1, err = strconv.ParseInt(string(parts[0]), 10, 64); err != nil {
         .          .    332:		return errTimestampInvalid
         .          .    333:	}
         .          .    334:	t2 := s.timestamp()
         .          .    335:	if s.minAge != 0 && t1 > t2-s.minAge {
         .          .    336:		return errTimestampTooNew
         .          .    337:	}
         .          .    338:	if s.maxAge != 0 && t1 < t2-s.maxAge {
         .          .    339:		return errTimestampExpired
         .          .    340:	}
         .          .    341:	// 5. Decrypt (optional).
         .          .    342:	b, err = decode(parts[1])
         .          .    343:	if err != nil {
         .          .    344:		return err
         .          .    345:	}
         .          .    346:	if s.block != nil {
         .          .    347:		if b, err = decrypt(s.block, b); err != nil {
         .          .    348:			return err
         .          .    349:		}
         .          .    350:	}
         .          .    351:	// 6. Deserialize.
      10ms      120ms    352:	if err = s.sz.Deserialize(b, dst); err != nil {
         .          .    353:		return cookieError{cause: err, typ: decodeError}
         .          .    354:	}
         .          .    355:	// Done.
         .          .    356:	return nil
         .          .    357:}
ROUTINE ======================== github.com/gorilla/securecookie.(*SecureCookie).Encode in /home/isucon/gocode/src/github.com/gorilla/securecookie/securecookie.go
         0       40ms (flat, cum) 0.072% of Total
         .          .    264:		return "", s.err
         .          .    265:	}
         .          .    266:	var err error
         .          .    267:	var b []byte
         .          .    268:	// 1. Serialize.
         .       40ms    269:	if b, err = s.sz.Serialize(value); err != nil {
         .          .    270:		return "", cookieError{cause: err, typ: usageError}
         .          .    271:	}
         .          .    272:	// 2. Encrypt (optional).
         .          .    273:	if s.block != nil {
         .          .    274:		if b, err = encrypt(s.block, b); err != nil {
ROUTINE ======================== github.com/gorilla/securecookie.DecodeMulti in /home/isucon/gocode/src/github.com/gorilla/securecookie/securecookie.go
         0      130ms (flat, cum)  0.23% of Total
         .          .    586:		return errNoCodecs
         .          .    587:	}
         .          .    588:
         .          .    589:	var errors MultiError
         .          .    590:	for _, codec := range codecs {
         .      130ms    591:		err := codec.Decode(name, value, dst)
         .          .    592:		if err == nil {
         .          .    593:			return nil
         .          .    594:		}
         .          .    595:		errors = append(errors, err)
         .          .    596:	}
ROUTINE ======================== github.com/gorilla/securecookie.EncodeMulti in /home/isucon/gocode/src/github.com/gorilla/securecookie/securecookie.go
         0       40ms (flat, cum) 0.072% of Total
         .          .    564:		return "", errNoCodecs
         .          .    565:	}
         .          .    566:
         .          .    567:	var errors MultiError
         .          .    568:	for _, codec := range codecs {
         .       40ms    569:		encoded, err := codec.Encode(name, value)
         .          .    570:		if err == nil {
         .          .    571:			return encoded, nil
         .          .    572:		}
         .          .    573:		errors = append(errors, err)
         .          .    574:	}
ROUTINE ======================== github.com/gorilla/securecookie.GenerateRandomKey in /home/isucon/gocode/src/github.com/gorilla/securecookie/securecookie.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    508://
         .          .    509:// Callers should explicitly check for the possibility of a nil return, treat
         .          .    510:// it as a failure of the system random number generator, and not continue.
         .          .    511:func GenerateRandomKey(length int) []byte {
         .          .    512:	k := make([]byte, length)
         .       10ms    513:	if _, err := io.ReadFull(rand.Reader, k); err != nil {
         .          .    514:		return nil
         .          .    515:	}
         .          .    516:	return k
         .          .    517:}
         .          .    518:
ROUTINE ======================== github.com/gorilla/securecookie.GobEncoder.Deserialize in /home/isucon/gocode/src/github.com/gorilla/securecookie/securecookie.go
         0      110ms (flat, cum)   0.2% of Total
         .          .    436:}
         .          .    437:
         .          .    438:// Deserialize decodes a value using gob.
         .          .    439:func (e GobEncoder) Deserialize(src []byte, dst interface{}) error {
         .          .    440:	dec := gob.NewDecoder(bytes.NewBuffer(src))
         .      110ms    441:	if err := dec.Decode(dst); err != nil {
         .          .    442:		return cookieError{cause: err, typ: decodeError}
         .          .    443:	}
         .          .    444:	return nil
         .          .    445:}
         .          .    446:
ROUTINE ======================== github.com/gorilla/securecookie.GobEncoder.Serialize in /home/isucon/gocode/src/github.com/gorilla/securecookie/securecookie.go
         0       40ms (flat, cum) 0.072% of Total
         .          .    427:
         .          .    428:// Serialize encodes a value using gob.
         .          .    429:func (e GobEncoder) Serialize(src interface{}) ([]byte, error) {
         .          .    430:	buf := new(bytes.Buffer)
         .          .    431:	enc := gob.NewEncoder(buf)
         .       40ms    432:	if err := enc.Encode(src); err != nil {
         .          .    433:		return nil, cookieError{cause: err, typ: usageError}
         .          .    434:	}
         .          .    435:	return buf.Bytes(), nil
         .          .    436:}
         .          .    437:
ROUTINE ======================== github.com/gorilla/sessions.(*Registry).Get in /home/isucon/gocode/src/github.com/gorilla/sessions/sessions.go
         0      230ms (flat, cum)  0.41% of Total
         .          .    146:		return nil, fmt.Errorf("sessions: invalid character in cookie name: %s", name)
         .          .    147:	}
         .          .    148:	if info, ok := s.sessions[name]; ok {
         .          .    149:		session, err = info.s, info.e
         .          .    150:	} else {
         .      230ms    151:		session, err = store.New(s.request, name)
         .          .    152:		session.name = name
         .          .    153:		s.sessions[name] = sessionInfo{s: session, e: err}
         .          .    154:	}
         .          .    155:	session.store = store
         .          .    156:	return
ROUTINE ======================== github.com/gorilla/sessions.(*Session).Save in /home/isucon/gocode/src/github.com/gorilla/sessions/sessions.go
         0      100ms (flat, cum)  0.18% of Total
         .          .     89:
         .          .     90:// Save is a convenience method to save this session. It is the same as calling
         .          .     91:// store.Save(request, response, session). You should call Save before writing to
         .          .     92:// the response or returning from the handler.
         .          .     93:func (s *Session) Save(r *http.Request, w http.ResponseWriter) error {
         .      100ms     94:	return s.store.Save(r, w, s)
         .          .     95:}
         .          .     96:
         .          .     97:// Name returns the name used to register the session.
         .          .     98:func (s *Session) Name() string {
         .          .     99:	return s.name
ROUTINE ======================== github.com/jmoiron/sqlx.(*DB).Get in /home/isucon/gocode/src/github.com/jmoiron/sqlx/sqlx.go
      10ms      6.42s (flat, cum) 11.54% of Total
         .          .    303:	return Select(db, dest, query, args...)
         .          .    304:}
         .          .    305:
         .          .    306:// Get using this DB.
         .          .    307:func (db *DB) Get(dest interface{}, query string, args ...interface{}) error {
      10ms      6.42s    308:	return Get(db, dest, query, args...)
         .          .    309:}
         .          .    310:
         .          .    311:// MustBegin starts a transaction, and panics on error.  Returns an *sqlx.Tx instead
         .          .    312:// of an *sql.Tx.
         .          .    313:func (db *DB) MustBegin() *Tx {
ROUTINE ======================== github.com/jmoiron/sqlx.(*DB).QueryRowx in /home/isucon/gocode/src/github.com/jmoiron/sqlx/sqlx.go
         0      3.31s (flat, cum)  5.95% of Total
         .          .    336:	return &Rows{Rows: r, unsafe: db.unsafe, Mapper: db.Mapper}, err
         .          .    337:}
         .          .    338:
         .          .    339:// QueryRowx queries the database and returns an *sqlx.Row.
         .          .    340:func (db *DB) QueryRowx(query string, args ...interface{}) *Row {
         .      3.29s    341:	rows, err := db.DB.Query(query, args...)
         .       20ms    342:	return &Row{rows: rows, err: err, unsafe: db.unsafe, Mapper: db.Mapper}
         .          .    343:}
         .          .    344:
         .          .    345:// MustExec (panic) runs MustExec using this database.
         .          .    346:func (db *DB) MustExec(query string, args ...interface{}) sql.Result {
         .          .    347:	return MustExec(db, query, args...)
ROUTINE ======================== github.com/jmoiron/sqlx.(*DB).Queryx in /home/isucon/gocode/src/github.com/jmoiron/sqlx/sqlx.go
         0      760ms (flat, cum)  1.37% of Total
         .          .    327:	return &Tx{Tx: tx, driverName: db.driverName, unsafe: db.unsafe, Mapper: db.Mapper}, err
         .          .    328:}
         .          .    329:
         .          .    330:// Queryx queries the database and returns an *sqlx.Rows.
         .          .    331:func (db *DB) Queryx(query string, args ...interface{}) (*Rows, error) {
         .      760ms    332:	r, err := db.DB.Query(query, args...)
         .          .    333:	if err != nil {
         .          .    334:		return nil, err
         .          .    335:	}
         .          .    336:	return &Rows{Rows: r, unsafe: db.unsafe, Mapper: db.Mapper}, err
         .          .    337:}
ROUTINE ======================== github.com/jmoiron/sqlx.(*DB).Select in /home/isucon/gocode/src/github.com/jmoiron/sqlx/sqlx.go
         0     35.57s (flat, cum) 63.92% of Total
         .          .    298:	return NamedExec(db, query, arg)
         .          .    299:}
         .          .    300:
         .          .    301:// Select using this DB.
         .          .    302:func (db *DB) Select(dest interface{}, query string, args ...interface{}) error {
         .     35.57s    303:	return Select(db, dest, query, args...)
         .          .    304:}
         .          .    305:
         .          .    306:// Get using this DB.
         .          .    307:func (db *DB) Get(dest interface{}, query string, args ...interface{}) error {
         .          .    308:	return Get(db, dest, query, args...)
ROUTINE ======================== github.com/jmoiron/sqlx.(*Row).Columns in /home/isucon/gocode/src/github.com/jmoiron/sqlx/sqlx.go
         0       50ms (flat, cum)  0.09% of Total
         .          .    216:// returned by Row.Scan()
         .          .    217:func (r *Row) Columns() ([]string, error) {
         .          .    218:	if r.err != nil {
         .          .    219:		return []string{}, r.err
         .          .    220:	}
         .       50ms    221:	return r.rows.Columns()
         .          .    222:}
         .          .    223:
         .          .    224:// Err returns the error encountered while scanning.
         .          .    225:func (r *Row) Err() error {
         .          .    226:	return r.err
ROUTINE ======================== github.com/jmoiron/sqlx.(*Row).Scan in /home/isucon/gocode/src/github.com/jmoiron/sqlx/sqlx.go
         0      2.84s (flat, cum)  5.10% of Total
         .          .    186:	// should provide an optional interface for drivers to
         .          .    187:	// implement to say, "don't worry, the []bytes that I return
         .          .    188:	// from Next will not be modified again." (for instance, if
         .          .    189:	// they were obtained from the network anyway) But for now we
         .          .    190:	// don't care.
         .       10ms    191:	defer r.rows.Close()
         .          .    192:	for _, dp := range dest {
         .          .    193:		if _, ok := dp.(*sql.RawBytes); ok {
         .          .    194:			return errors.New("sql: RawBytes isn't allowed on Row.Scan")
         .          .    195:		}
         .          .    196:	}
         .          .    197:
         .      1.06s    198:	if !r.rows.Next() {
         .          .    199:		if err := r.rows.Err(); err != nil {
         .          .    200:			return err
         .          .    201:		}
         .          .    202:		return sql.ErrNoRows
         .          .    203:	}
         .      1.05s    204:	err := r.rows.Scan(dest...)
         .          .    205:	if err != nil {
         .          .    206:		return err
         .          .    207:	}
         .          .    208:	// Make sure the query can be processed to completion with no errors.
         .      710ms    209:	if err := r.rows.Close(); err != nil {
         .          .    210:		return err
         .          .    211:	}
         .       10ms    212:	return nil
         .          .    213:}
         .          .    214:
         .          .    215:// Columns returns the underlying sql.Rows.Columns(), or the deferred error usually
         .          .    216:// returned by Row.Scan()
         .          .    217:func (r *Row) Columns() ([]string, error) {
ROUTINE ======================== github.com/jmoiron/sqlx.(*Row).scanAny in /home/isucon/gocode/src/github.com/jmoiron/sqlx/sqlx.go
      20ms      3.10s (flat, cum)  5.57% of Total
         .          .    691:	if r.err != nil {
         .          .    692:		return r.err
         .          .    693:	}
         .          .    694:	defer r.rows.Close()
         .          .    695:
         .       10ms    696:	v := reflect.ValueOf(dest)
         .          .    697:	if v.Kind() != reflect.Ptr {
         .          .    698:		return errors.New("must pass a pointer, not a value, to StructScan destination")
         .          .    699:	}
         .          .    700:	if v.IsNil() {
         .          .    701:		return errors.New("nil pointer passed to StructScan destination")
         .          .    702:	}
         .          .    703:
         .       10ms    704:	base := reflectx.Deref(v.Type())
         .       30ms    705:	scannable := isScannable(base)
         .          .    706:
         .          .    707:	if structOnly && scannable {
         .          .    708:		return structOnlyError(base)
         .          .    709:	}
         .          .    710:
         .       50ms    711:	columns, err := r.Columns()
         .          .    712:	if err != nil {
         .          .    713:		return err
         .          .    714:	}
         .          .    715:
         .          .    716:	if scannable && len(columns) > 1 {
         .          .    717:		return fmt.Errorf("scannable dest type %s with >1 columns (%d) in result", base.Kind(), len(columns))
         .          .    718:	}
         .          .    719:
      10ms       10ms    720:	if scannable {
         .      200ms    721:		return r.Scan(dest)
         .          .    722:	}
         .          .    723:
         .          .    724:	m := r.Mapper
         .          .    725:
         .       60ms    726:	fields := m.TraversalsByName(v.Type(), columns)
         .          .    727:	// if we are not unsafe and are missing fields, return an error
         .          .    728:	if f, err := missingFields(fields); err != nil && !r.unsafe {
         .          .    729:		return fmt.Errorf("missing destination name %s", columns[f])
         .          .    730:	}
         .       20ms    731:	values := make([]interface{}, len(columns))
         .          .    732:
         .       30ms    733:	err = fieldsByTraversal(v, fields, values, true)
         .          .    734:	if err != nil {
         .          .    735:		return err
         .          .    736:	}
         .          .    737:	// scan into the struct field pointers and append to our results
      10ms      2.68s    738:	return r.Scan(values...)
         .          .    739:}
         .          .    740:
         .          .    741:// StructScan a single Row into dest.
         .          .    742:func (r *Row) StructScan(dest interface{}) error {
         .          .    743:	return r.scanAny(dest, true)
ROUTINE ======================== github.com/jmoiron/sqlx.(*Rows).Next in <autogenerated>
      40ms       40ms (flat, cum) 0.072% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== github.com/jmoiron/sqlx.(*Rows).Scan in <autogenerated>
      20ms       20ms (flat, cum) 0.036% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== github.com/jmoiron/sqlx.Get in /home/isucon/gocode/src/github.com/jmoiron/sqlx/sqlx.go
         0      6.41s (flat, cum) 11.52% of Total
         .          .    638:
         .          .    639:// Get does a QueryRow using the provided Queryer, and scans the resulting row
         .          .    640:// to dest.  If dest is scannable, the result must only have one column.  Otherwise,
         .          .    641:// StructScan is used.  Get will return sql.ErrNoRows like row.Scan would.
         .          .    642:func Get(q Queryer, dest interface{}, query string, args ...interface{}) error {
         .      3.31s    643:	r := q.QueryRowx(query, args...)
         .      3.10s    644:	return r.scanAny(dest, false)
         .          .    645:}
         .          .    646:
         .          .    647:// LoadFile exec's every statement in a file (as a single call to Exec).
         .          .    648:// LoadFile may return a nil *sql.Result if errors are encountered locating or
         .          .    649:// reading the file at path.  LoadFile reads the entire file into memory, so it
ROUTINE ======================== github.com/jmoiron/sqlx.Select in /home/isucon/gocode/src/github.com/jmoiron/sqlx/sqlx.go
      10ms     35.57s (flat, cum) 63.92% of Total
         .          .    625:// Select executes a query using the provided Queryer, and StructScans each row
         .          .    626:// into dest, which must be a slice.  If the slice elements are scannable, then
         .          .    627:// the result set must have only one column.  Otherwise, StructScan is used.
         .          .    628:// The *sql.Rows are closed automatically.
         .          .    629:func Select(q Queryer, dest interface{}, query string, args ...interface{}) error {
      10ms      770ms    630:	rows, err := q.Queryx(query, args...)
         .          .    631:	if err != nil {
         .          .    632:		return err
         .          .    633:	}
         .          .    634:	// if something happens here, we want to make sure the rows are Closed
         .          .    635:	defer rows.Close()
         .     34.80s    636:	return scanAll(rows, dest, false)
         .          .    637:}
         .          .    638:
         .          .    639:// Get does a QueryRow using the provided Queryer, and scans the resulting row
         .          .    640:// to dest.  If dest is scannable, the result must only have one column.  Otherwise,
         .          .    641:// StructScan is used.  Get will return sql.ErrNoRows like row.Scan would.
ROUTINE ======================== github.com/jmoiron/sqlx.fieldsByTraversal in /home/isucon/gocode/src/github.com/jmoiron/sqlx/sqlx.go
     660ms      2.95s (flat, cum)  5.30% of Total
         .          .    959:// on the traversals in int.  If ptrs is true, return addresses instead of values.
         .          .    960:// We write this instead of using FieldsByName to save allocations and map lookups
         .          .    961:// when iterating over many rows.  Empty traversals will get an interface pointer.
         .          .    962:// Because of the necessity of requesting ptrs or values, it's considered a bit too
         .          .    963:// specialized for inclusion in reflectx itself.
      40ms       40ms    964:func fieldsByTraversal(v reflect.Value, traversals [][]int, values []interface{}, ptrs bool) error {
      20ms       70ms    965:	v = reflect.Indirect(v)
      20ms       20ms    966:	if v.Kind() != reflect.Struct {
         .          .    967:		return errors.New("argument not a struct")
         .          .    968:	}
         .          .    969:
     120ms      120ms    970:	for i, traversal := range traversals {
         .          .    971:		if len(traversal) == 0 {
         .          .    972:			values[i] = new(interface{})
         .          .    973:			continue
         .          .    974:		}
     130ms      1.24s    975:		f := reflectx.FieldByIndexes(v, traversal)
         .          .    976:		if ptrs {
     300ms      1.43s    977:			values[i] = f.Addr().Interface()
         .          .    978:		} else {
         .          .    979:			values[i] = f.Interface()
         .          .    980:		}
         .          .    981:	}
      30ms       30ms    982:	return nil
         .          .    983:}
         .          .    984:
         .          .    985:func missingFields(transversals [][]int) (field int, err error) {
         .          .    986:	for i, t := range transversals {
         .          .    987:		if len(t) == 0 {
ROUTINE ======================== github.com/jmoiron/sqlx.isScannable in /home/isucon/gocode/src/github.com/jmoiron/sqlx/sqlx.go
         0       60ms (flat, cum)  0.11% of Total
         .          .     46:// whether or not it's Scannable.  Something is scannable if:
         .          .     47://   * it is not a struct
         .          .     48://   * it implements sql.Scanner
         .          .     49://   * it has no exported fields
         .          .     50:func isScannable(t reflect.Type) bool {
         .       10ms     51:	if reflect.PtrTo(t).Implements(_scannerInterface) {
         .          .     52:		return true
         .          .     53:	}
         .       10ms     54:	if t.Kind() != reflect.Struct {
         .          .     55:		return true
         .          .     56:	}
         .          .     57:
         .          .     58:	// it's not important that we use the right mapper for this particular object,
         .          .     59:	// we're only concerned on how many exported fields this struct has
         .          .     60:	m := mapper()
         .       40ms     61:	if len(m.TypeMap(t).Index) == 0 {
         .          .     62:		return true
         .          .     63:	}
         .          .     64:	return false
         .          .     65:}
         .          .     66:
ROUTINE ======================== github.com/jmoiron/sqlx.scanAll in /home/isucon/gocode/src/github.com/jmoiron/sqlx/sqlx.go
     280ms     34.80s (flat, cum) 62.53% of Total
         .          .    860:		return err
         .          .    861:	}
         .          .    862:
         .          .    863:	isPtr := slice.Elem().Kind() == reflect.Ptr
         .          .    864:	base := reflectx.Deref(slice.Elem())
         .       30ms    865:	scannable := isScannable(base)
         .          .    866:
         .          .    867:	if structOnly && scannable {
         .          .    868:		return structOnlyError(base)
         .          .    869:	}
         .          .    870:
         .       10ms    871:	columns, err := rows.Columns()
         .          .    872:	if err != nil {
         .          .    873:		return err
         .          .    874:	}
         .          .    875:
         .          .    876:	// if it's a base type make sure it only has 1 column;  if not return an error
         .          .    877:	if scannable && len(columns) > 1 {
         .          .    878:		return fmt.Errorf("non-struct dest type %s with >1 columns (%d)", base.Kind(), len(columns))
         .          .    879:	}
         .          .    880:
         .          .    881:	if !scannable {
         .          .    882:		var values []interface{}
         .          .    883:		var m *reflectx.Mapper
         .          .    884:
         .          .    885:		switch rows.(type) {
         .          .    886:		case *Rows:
         .          .    887:			m = rows.(*Rows).Mapper
         .          .    888:		default:
         .          .    889:			m = mapper()
         .          .    890:		}
         .          .    891:
         .       20ms    892:		fields := m.TraversalsByName(base, columns)
         .          .    893:		// if we are not unsafe and are missing fields, return an error
         .          .    894:		if f, err := missingFields(fields); err != nil && !isUnsafe(rows) {
         .          .    895:			return fmt.Errorf("missing destination name %s", columns[f])
         .          .    896:		}
         .          .    897:		values = make([]interface{}, len(columns))
         .          .    898:
      50ms     14.14s    899:		for rows.Next() {
         .          .    900:			// create a new struct type (which returns PtrTo) and indirect it
      10ms      1.65s    901:			vp = reflect.New(base)
      30ms      100ms    902:			v = reflect.Indirect(vp)
         .          .    903:
      30ms      2.95s    904:			err = fieldsByTraversal(v, fields, values, true)
         .          .    905:
         .          .    906:			// scan into the struct field pointers and append to our results
      60ms      8.57s    907:			err = rows.Scan(values...)
      10ms       10ms    908:			if err != nil {
         .          .    909:				return err
         .          .    910:			}
         .          .    911:
         .          .    912:			if isPtr {
         .          .    913:				direct.Set(reflect.Append(direct, vp))
         .          .    914:			} else {
      80ms      7.29s    915:				direct.Set(reflect.Append(direct, v))
         .          .    916:			}
         .          .    917:		}
         .          .    918:	} else {
         .       10ms    919:		for rows.Next() {
         .          .    920:			vp = reflect.New(base)
         .       10ms    921:			err = rows.Scan(vp.Interface())
         .          .    922:			// append
         .          .    923:			if isPtr {
         .          .    924:				direct.Set(reflect.Append(direct, vp))
         .          .    925:			} else {
         .          .    926:				direct.Set(reflect.Append(direct, reflect.Indirect(vp)))
         .          .    927:			}
         .          .    928:		}
         .          .    929:	}
         .          .    930:
      10ms       10ms    931:	return rows.Err()
         .          .    932:}
         .          .    933:
         .          .    934:// FIXME: StructScan was the very first bit of API in sqlx, and now unfortunately
         .          .    935:// it doesn't really feel like it's named properly.  There is an incongruency
         .          .    936:// between this and the way that StructScan (which might better be ScanStruct
ROUTINE ======================== github.com/jmoiron/sqlx/reflectx.(*Mapper).TraversalsByName in /home/isucon/gocode/src/github.com/jmoiron/sqlx/reflectx/reflect.go
      40ms       80ms (flat, cum)  0.14% of Total
         .          .    163:}
         .          .    164:
         .          .    165:// TraversalsByName returns a slice of int slices which represent the struct
         .          .    166:// traversals for each mapped name.  Panics if t is not a struct or Indirectable
         .          .    167:// to a struct.  Returns empty int slice for each name not found.
      10ms       10ms    168:func (m *Mapper) TraversalsByName(t reflect.Type, names []string) [][]int {
         .          .    169:	t = Deref(t)
         .       20ms    170:	mustBe(t, reflect.Struct)
         .          .    171:	tm := m.TypeMap(t)
         .          .    172:
         .       20ms    173:	r := make([][]int, 0, len(names))
         .          .    174:	for _, name := range names {
      10ms       10ms    175:		fi, ok := tm.Names[name]
      10ms       10ms    176:		if !ok {
         .          .    177:			r = append(r, []int{})
         .          .    178:		} else {
      10ms       10ms    179:			r = append(r, fi.Index)
         .          .    180:		}
         .          .    181:	}
         .          .    182:	return r
         .          .    183:}
         .          .    184:
ROUTINE ======================== github.com/jmoiron/sqlx/reflectx.(*Mapper).TypeMap in /home/isucon/gocode/src/github.com/jmoiron/sqlx/reflectx/reflect.go
         0       40ms (flat, cum) 0.072% of Total
         .          .    102:
         .          .    103:// TypeMap returns a mapping of field strings to int slices representing
         .          .    104:// the traversal down the struct to reach the field.
         .          .    105:func (m *Mapper) TypeMap(t reflect.Type) *StructMap {
         .          .    106:	m.mutex.Lock()
         .       40ms    107:	mapping, ok := m.cache[t]
         .          .    108:	if !ok {
         .          .    109:		mapping = getMapping(t, m.tagName, m.mapFunc, m.tagMapFunc)
         .          .    110:		m.cache[t] = mapping
         .          .    111:	}
         .          .    112:	m.mutex.Unlock()
ROUTINE ======================== github.com/jmoiron/sqlx/reflectx.Deref in /home/isucon/gocode/src/github.com/jmoiron/sqlx/reflectx/reflect.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    208:	return v
         .          .    209:}
         .          .    210:
         .          .    211:// Deref is Indirect for reflect.Types
         .          .    212:func Deref(t reflect.Type) reflect.Type {
      10ms       10ms    213:	if t.Kind() == reflect.Ptr {
         .          .    214:		t = t.Elem()
         .          .    215:	}
         .          .    216:	return t
         .          .    217:}
         .          .    218:
ROUTINE ======================== github.com/jmoiron/sqlx/reflectx.FieldByIndexes in /home/isucon/gocode/src/github.com/jmoiron/sqlx/reflectx/reflect.go
     550ms      1.11s (flat, cum)  1.99% of Total
         .          .    181:	}
         .          .    182:	return r
         .          .    183:}
         .          .    184:
         .          .    185:// FieldByIndexes returns a value for a particular struct traversal.
     100ms      100ms    186:func FieldByIndexes(v reflect.Value, indexes []int) reflect.Value {
     160ms      160ms    187:	for _, i := range indexes {
     200ms      760ms    188:		v = reflect.Indirect(v).Field(i)
         .          .    189:		// if this is a pointer, it's possible it is nil
      20ms       20ms    190:		if v.Kind() == reflect.Ptr && v.IsNil() {
         .          .    191:			alloc := reflect.New(Deref(v.Type()))
         .          .    192:			v.Set(alloc)
         .          .    193:		}
      20ms       20ms    194:		if v.Kind() == reflect.Map && v.IsNil() {
         .          .    195:			v.Set(reflect.MakeMap(v.Type()))
         .          .    196:		}
         .          .    197:	}
      50ms       50ms    198:	return v
         .          .    199:}
         .          .    200:
         .          .    201:// FieldByIndexesReadOnly returns a value for a particular struct traversal,
         .          .    202:// but is not concerned with allocating nil pointers because the value is
         .          .    203:// going to be used for reading and not setting.
ROUTINE ======================== github.com/zenazn/goji.Serve in /home/isucon/gocode/src/github.com/zenazn/goji/serve.go
         0      380ms (flat, cum)  0.68% of Total
         .          .     26:func Serve() {
         .          .     27:	if !flag.Parsed() {
         .          .     28:		flag.Parse()
         .          .     29:	}
         .          .     30:
         .      380ms     31:	ServeListener(bind.Default())
         .          .     32:}
         .          .     33:
         .          .     34:// Like Serve, but enables TLS using the given config.
         .          .     35:func ServeTLS(config *tls.Config) {
         .          .     36:	if !flag.Parsed() {
ROUTINE ======================== github.com/zenazn/goji.ServeListener in /home/isucon/gocode/src/github.com/zenazn/goji/serve.go
         0      380ms (flat, cum)  0.68% of Total
         .          .     52:	graceful.HandleSignals()
         .          .     53:	bind.Ready()
         .          .     54:	graceful.PreHook(func() { log.Printf("Goji received signal, gracefully stopping") })
         .          .     55:	graceful.PostHook(func() { log.Printf("Goji stopped") })
         .          .     56:
         .      380ms     57:	err := graceful.Serve(listener, http.DefaultServeMux)
         .          .     58:
         .          .     59:	if err != nil {
         .          .     60:		log.Fatal(err)
         .          .     61:	}
         .          .     62:
ROUTINE ======================== github.com/zenazn/goji/graceful.(*Server).Serve in /home/isucon/gocode/src/github.com/zenazn/goji/graceful/serve13.go
         0      380ms (flat, cum)  0.68% of Total
         .          .     69:
         .          .     70:	l = gracefulServer{l, &shadow}
         .          .     71:	wrap := listener.Wrap(l, listener.Automatic)
         .          .     72:	appendListener(wrap)
         .          .     73:
         .      380ms     74:	err := shadow.Serve(wrap)
         .          .     75:	return peacefulError(err)
         .          .     76:}
ROUTINE ======================== github.com/zenazn/goji/graceful.(*gracefulServer).Accept in <autogenerated>
         0      360ms (flat, cum)  0.65% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== github.com/zenazn/goji/graceful.Serve in /home/isucon/gocode/src/github.com/zenazn/goji/graceful/server.go
         0      380ms (flat, cum)  0.68% of Total
         .          .    102:func Serve(l net.Listener, handler http.Handler) error {
         .          .    103:	if tl, ok := l.(*net.TCPListener); ok {
         .          .    104:		l = tcpKeepAliveListener{tl}
         .          .    105:	}
         .          .    106:	server := &Server{Handler: handler}
         .      380ms    107:	return server.Serve(l)
         .          .    108:}
ROUTINE ======================== github.com/zenazn/goji/graceful.tcpKeepAliveListener.Accept in /home/isucon/gocode/src/github.com/zenazn/goji/graceful/server.go
         0      360ms (flat, cum)  0.65% of Total
         .          .     16:type tcpKeepAliveListener struct {
         .          .     17:	*net.TCPListener
         .          .     18:}
         .          .     19:
         .          .     20:func (ln tcpKeepAliveListener) Accept() (c net.Conn, err error) {
         .      340ms     21:	tc, err := ln.AcceptTCP()
         .          .     22:	if err != nil {
         .          .     23:		return
         .          .     24:	}
         .       10ms     25:	tc.SetKeepAlive(true)
         .       10ms     26:	tc.SetKeepAlivePeriod(3 * time.Minute)
         .          .     27:	return tc, nil
         .          .     28:}
         .          .     29:
         .          .     30:// A Server is exactly the same as an http.Server, but provides more graceful
         .          .     31:// implementations of its methods.
ROUTINE ======================== github.com/zenazn/goji/graceful/listener.(*T).Accept in /home/isucon/gocode/src/github.com/zenazn/goji/graceful/listener/listener.go
         0      370ms (flat, cum)  0.66% of Total
         .          .     70:
         .          .     71:// Accept waits for and returns the next connection to the listener. The
         .          .     72:// returned net.Conn's idleness is tracked, and idle connections can be closed
         .          .     73:// from the associated T.
         .          .     74:func (t *T) Accept() (net.Conn, error) {
         .      360ms     75:	c, err := t.l.Accept()
         .          .     76:	if err != nil {
         .          .     77:		return nil, err
         .          .     78:	}
         .          .     79:
         .          .     80:	connID := atomic.AddUint64(&t.connCount, 1)
         .          .     81:	shard := &t.shards[int(connID)%len(t.shards)]
         .          .     82:	wc := &conn{
         .          .     83:		Conn:  c,
         .          .     84:		shard: shard,
         .          .     85:		mode:  t.mode,
         .          .     86:	}
         .          .     87:
         .       10ms     88:	if err = wc.init(); err != nil {
         .          .     89:		return nil, err
         .          .     90:	}
         .          .     91:	return wc, nil
         .          .     92:}
         .          .     93:
ROUTINE ======================== github.com/zenazn/goji/graceful/listener.(*conn).Close in /home/isucon/gocode/src/github.com/zenazn/goji/graceful/listener/conn.go
         0      170ms (flat, cum)  0.31% of Total
         .          .     70:	} else if c.closed {
         .          .     71:		return errClosing
         .          .     72:	}
         .          .     73:
         .          .     74:	c.closed = true
         .       20ms     75:	c.shard.disown(c)
         .          .     76:	defer c.shard.wg.Done()
         .          .     77:
         .      150ms     78:	return c.Conn.Close()
         .          .     79:}
         .          .     80:
         .          .     81:func (c *conn) SetReadDeadline(t time.Time) error {
         .          .     82:	c.mu.Lock()
         .          .     83:	if !c.disowned && c.mode == Deadline {
ROUTINE ======================== github.com/zenazn/goji/graceful/listener.(*conn).Read in /home/isucon/gocode/src/github.com/zenazn/goji/graceful/listener/conn.go
         0       70ms (flat, cum)  0.13% of Total
         .          .     56:			c.busy = true
         .          .     57:			c.shard.markInUse(c)
         .          .     58:		}
         .          .     59:	}()
         .          .     60:
         .       70ms     61:	return c.Conn.Read(b)
         .          .     62:}
         .          .     63:
         .          .     64:func (c *conn) Close() error {
         .          .     65:	c.mu.Lock()
         .          .     66:	defer c.mu.Unlock()
ROUTINE ======================== github.com/zenazn/goji/graceful/listener.(*conn).Read.func1 in /home/isucon/gocode/src/github.com/zenazn/goji/graceful/listener/conn.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     52:			return
         .          .     53:		}
         .          .     54:
         .          .     55:		if c.mode != Manual && !c.busy && !c.closed {
         .          .     56:			c.busy = true
         .       10ms     57:			c.shard.markInUse(c)
         .          .     58:		}
         .          .     59:	}()
         .          .     60:
         .          .     61:	return c.Conn.Read(b)
         .          .     62:}
ROUTINE ======================== github.com/zenazn/goji/graceful/listener.(*conn).ReadFrom in /home/isucon/gocode/src/github.com/zenazn/goji/graceful/listener/conn.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     86:	c.mu.Unlock()
         .          .     87:	return c.Conn.SetReadDeadline(t)
         .          .     88:}
         .          .     89:
         .          .     90:func (c *conn) ReadFrom(r io.Reader) (int64, error) {
         .       20ms     91:	return io.Copy(c.Conn, r)
         .          .     92:}
         .          .     93:
         .          .     94:func (c *conn) markIdle() {
         .          .     95:	c.mu.Lock()
         .          .     96:	defer c.mu.Unlock()
ROUTINE ======================== github.com/zenazn/goji/graceful/listener.(*conn).RemoteAddr in <autogenerated>
      10ms       10ms (flat, cum) 0.018% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== github.com/zenazn/goji/graceful/listener.(*conn).Write in <autogenerated>
         0      630ms (flat, cum)  1.13% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== github.com/zenazn/goji/graceful/listener.(*conn).init in /home/isucon/gocode/src/github.com/zenazn/goji/graceful/listener/conn.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     23:// This intentionally looks a lot like the one in package net.
         .          .     24:var errClosing = errors.New("use of closed network connection")
         .          .     25:
         .          .     26:func (c *conn) init() error {
         .          .     27:	c.shard.wg.Add(1)
         .       10ms     28:	if shouldExit := c.shard.track(c); shouldExit {
         .          .     29:		c.Close()
         .          .     30:		return errClosing
         .          .     31:	}
         .          .     32:	return nil
         .          .     33:}
ROUTINE ======================== github.com/zenazn/goji/graceful/listener.(*shard).disown in /home/isucon/gocode/src/github.com/zenazn/goji/graceful/listener/shard.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     36:	return false
         .          .     37:}
         .          .     38:
         .          .     39:func (s *shard) disown(c *conn) {
         .          .     40:	s.mu.Lock()
         .       20ms     41:	delete(s.all, c)
         .          .     42:	delete(s.idle, c)
         .          .     43:	s.mu.Unlock()
         .          .     44:}
         .          .     45:
         .          .     46:func (s *shard) markIdle(c *conn) (shouldClose bool) {
ROUTINE ======================== github.com/zenazn/goji/graceful/listener.(*shard).markInUse in /home/isucon/gocode/src/github.com/zenazn/goji/graceful/listener/shard.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     54:	return false
         .          .     55:}
         .          .     56:
         .          .     57:func (s *shard) markInUse(c *conn) {
         .          .     58:	s.mu.Lock()
         .       10ms     59:	delete(s.idle, c)
         .          .     60:	s.mu.Unlock()
         .          .     61:}
         .          .     62:
         .          .     63:func (s *shard) closeConns(all, drain bool) {
         .          .     64:	s.mu.Lock()
ROUTINE ======================== github.com/zenazn/goji/graceful/listener.(*shard).track in /home/isucon/gocode/src/github.com/zenazn/goji/graceful/listener/shard.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     28:	s.mu.Lock()
         .          .     29:	if s.drain {
         .          .     30:		s.mu.Unlock()
         .          .     31:		return true
         .          .     32:	}
         .       10ms     33:	s.all[c] = struct{}{}
         .          .     34:	s.idle[c] = struct{}{}
         .          .     35:	s.mu.Unlock()
         .          .     36:	return false
         .          .     37:}
         .          .     38:
ROUTINE ======================== github.com/zenazn/goji/web.(*Mux).ServeHTTP in /home/isucon/gocode/src/github.com/zenazn/goji/web/mux.go
         0     46.70s (flat, cum) 83.92% of Total
         .          .     39:	return &mux
         .          .     40:}
         .          .     41:
         .          .     42:// ServeHTTP processes HTTP requests. Satisfies net/http.Handler.
         .          .     43:func (m *Mux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
         .       10ms     44:	stack := m.ms.alloc()
         .     46.69s     45:	stack.ServeHTTP(w, r)
         .          .     46:	m.ms.release(stack)
         .          .     47:}
         .          .     48:
         .          .     49:// ServeHTTPC creates a context dependent request with the given Mux. Satisfies
         .          .     50:// the Handler interface.
ROUTINE ======================== github.com/zenazn/goji/web.(*cStack).ServeHTTP in /home/isucon/gocode/src/github.com/zenazn/goji/web/middleware.go
         0     46.69s (flat, cum) 83.90% of Total
         .          .     41:	pool *cPool
         .          .     42:}
         .          .     43:
         .          .     44:func (s *cStack) ServeHTTP(w http.ResponseWriter, r *http.Request) {
         .          .     45:	s.C = C{}
         .     46.69s     46:	s.m.ServeHTTP(w, r)
         .          .     47:}
         .          .     48:func (s *cStack) ServeHTTPC(c C, w http.ResponseWriter, r *http.Request) {
         .          .     49:	s.C = c
         .          .     50:	s.m.ServeHTTP(w, r)
         .          .     51:}
ROUTINE ======================== github.com/zenazn/goji/web.(*mStack).alloc in /home/isucon/gocode/src/github.com/zenazn/goji/web/middleware.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     96:
         .          .     97:func (m *mStack) alloc() *cStack {
         .          .     98:	p := m.pool
         .          .     99:	cs := p.alloc()
         .          .    100:	if cs == nil {
         .       10ms    101:		cs = m.newStack()
         .          .    102:	}
         .          .    103:
         .          .    104:	cs.pool = p
         .          .    105:	return cs
         .          .    106:}
ROUTINE ======================== github.com/zenazn/goji/web.(*mStack).newStack in /home/isucon/gocode/src/github.com/zenazn/goji/web/middleware.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .     86:
         .          .     87:	cs.m = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
         .          .     88:		router.route(&cs.C, w, r)
         .          .     89:	})
         .          .     90:	for i := len(m.stack) - 1; i >= 0; i-- {
      10ms       10ms     91:		cs.m = m.stack[i].fn(&cs.C, cs.m)
         .          .     92:	}
         .          .     93:
         .          .     94:	return &cs
         .          .     95:}
         .          .     96:
ROUTINE ======================== github.com/zenazn/goji/web.(*mStack).newStack.func1 in /home/isucon/gocode/src/github.com/zenazn/goji/web/middleware.go
         0     46.22s (flat, cum) 83.05% of Total
         .          .     83:func (m *mStack) newStack() *cStack {
         .          .     84:	cs := cStack{}
         .          .     85:	router := m.router
         .          .     86:
         .          .     87:	cs.m = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
         .     46.22s     88:		router.route(&cs.C, w, r)
         .          .     89:	})
         .          .     90:	for i := len(m.stack) - 1; i >= 0; i-- {
         .          .     91:		cs.m = m.stack[i].fn(&cs.C, cs.m)
         .          .     92:	}
         .          .     93:
ROUTINE ======================== github.com/zenazn/goji/web.(*netHTTPHandlerWrap).ServeHTTPC in <autogenerated>
         0      150ms (flat, cum)  0.27% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== github.com/zenazn/goji/web.(*router).getMatch in /home/isucon/gocode/src/github.com/zenazn/goji/web/router.go
         0       70ms (flat, cum)  0.13% of Total
         .          .     79:	rm := rt.getMachine()
         .          .     80:	if rm == nil {
         .          .     81:		rm = rt.compile()
         .          .     82:	}
         .          .     83:
         .       70ms     84:	methods, route := rm.route(c, w, r)
         .          .     85:	if route != nil {
         .          .     86:		return Match{
         .          .     87:			Pattern: route.pattern,
         .          .     88:			Handler: route.handler,
         .          .     89:		}
ROUTINE ======================== github.com/zenazn/goji/web.(*router).route in /home/isucon/gocode/src/github.com/zenazn/goji/web/router.go
         0     46.22s (flat, cum) 83.05% of Total
         .          .    110:	}
         .          .    111:	return Match{Handler: rt.notFound}
         .          .    112:}
         .          .    113:
         .          .    114:func (rt *router) route(c *C, w http.ResponseWriter, r *http.Request) {
         .       10ms    115:	match := GetMatch(*c)
         .          .    116:	if match.Handler == nil {
         .       70ms    117:		match = rt.getMatch(c, w, r)
         .          .    118:	}
         .     46.14s    119:	match.Handler.ServeHTTPC(*c, w, r)
         .          .    120:}
         .          .    121:
         .          .    122:func (rt *router) handleUntyped(p PatternType, m method, h HandlerType) {
         .          .    123:	rt.handle(ParsePattern(p), m, parseHandler(h))
         .          .    124:}
ROUTINE ======================== github.com/zenazn/goji/web.(*stringPattern).Match in <autogenerated>
      10ms       40ms (flat, cum) 0.072% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== github.com/zenazn/goji/web.(*stringPattern).Run in <autogenerated>
         0       20ms (flat, cum) 0.036% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== github.com/zenazn/goji/web.handlerFuncWrap.ServeHTTPC in /home/isucon/gocode/src/github.com/zenazn/goji/web/handler.go
      10ms      5.85s (flat, cum) 10.51% of Total
         .          .     20:}
         .          .     21:func (h netHTTPHandlerFuncWrap) ServeHTTPC(c C, w http.ResponseWriter, r *http.Request) {
         .          .     22:	h.fn(w, r)
         .          .     23:}
         .          .     24:func (h handlerFuncWrap) ServeHTTPC(c C, w http.ResponseWriter, r *http.Request) {
         .      5.84s     25:	h.fn(c, w, r)
      10ms       10ms     26:}
         .          .     27:
         .          .     28:func parseHandler(h HandlerType) Handler {
         .          .     29:	switch f := h.(type) {
         .          .     30:	case func(c C, w http.ResponseWriter, r *http.Request):
         .          .     31:		return handlerFuncWrap{f}
ROUTINE ======================== github.com/zenazn/goji/web.matchRoute in /home/isucon/gocode/src/github.com/zenazn/goji/web/bytecode_runner.go
         0       60ms (flat, cum)  0.11% of Total
         .          .      6:	sm     stateMachine
         .          .      7:	routes []route
         .          .      8:}
         .          .      9:
         .          .     10:func matchRoute(route route, m method, ms *method, r *http.Request, c *C) bool {
         .       40ms     11:	if !route.pattern.Match(r, c) {
         .          .     12:		return false
         .          .     13:	}
         .          .     14:	*ms |= route.method
         .          .     15:
         .          .     16:	if route.method&m != 0 {
         .       20ms     17:		route.pattern.Run(r, c)
         .          .     18:		return true
         .          .     19:	}
         .          .     20:	return false
         .          .     21:}
         .          .     22:
ROUTINE ======================== github.com/zenazn/goji/web.netHTTPHandlerFuncWrap.ServeHTTPC in /home/isucon/gocode/src/github.com/zenazn/goji/web/handler.go
         0     40.14s (flat, cum) 72.13% of Total
         .          .     17:
         .          .     18:func (h netHTTPHandlerWrap) ServeHTTPC(c C, w http.ResponseWriter, r *http.Request) {
         .          .     19:	h.Handler.ServeHTTP(w, r)
         .          .     20:}
         .          .     21:func (h netHTTPHandlerFuncWrap) ServeHTTPC(c C, w http.ResponseWriter, r *http.Request) {
         .     40.14s     22:	h.fn(w, r)
         .          .     23:}
         .          .     24:func (h handlerFuncWrap) ServeHTTPC(c C, w http.ResponseWriter, r *http.Request) {
         .          .     25:	h.fn(c, w, r)
         .          .     26:}
         .          .     27:
ROUTINE ======================== github.com/zenazn/goji/web.netHTTPHandlerWrap.ServeHTTPC in /home/isucon/gocode/src/github.com/zenazn/goji/web/handler.go
         0      150ms (flat, cum)  0.27% of Total
         .          .     14:type handlerFuncWrap struct {
         .          .     15:	fn func(C, http.ResponseWriter, *http.Request)
         .          .     16:}
         .          .     17:
         .          .     18:func (h netHTTPHandlerWrap) ServeHTTPC(c C, w http.ResponseWriter, r *http.Request) {
         .      150ms     19:	h.Handler.ServeHTTP(w, r)
         .          .     20:}
         .          .     21:func (h netHTTPHandlerFuncWrap) ServeHTTPC(c C, w http.ResponseWriter, r *http.Request) {
         .          .     22:	h.fn(w, r)
         .          .     23:}
         .          .     24:func (h handlerFuncWrap) ServeHTTPC(c C, w http.ResponseWriter, r *http.Request) {
ROUTINE ======================== github.com/zenazn/goji/web.routeMachine.route in /home/isucon/gocode/src/github.com/zenazn/goji/web/bytecode_runner.go
         0       70ms (flat, cum)  0.13% of Total
         .          .     19:	}
         .          .     20:	return false
         .          .     21:}
         .          .     22:
         .          .     23:func (rm routeMachine) route(c *C, w http.ResponseWriter, r *http.Request) (method, *route) {
         .       10ms     24:	m := httpMethod(r.Method)
         .          .     25:	var methods method
         .          .     26:	p := r.URL.Path
         .          .     27:
         .          .     28:	if len(rm.sm) == 0 {
         .          .     29:		return methods, nil
         .          .     30:	}
         .          .     31:
         .          .     32:	var i int
         .          .     33:	for {
         .          .     34:		sm := rm.sm[i].mode
         .          .     35:		if sm&smSetCursor != 0 {
         .          .     36:			si := rm.sm[i].i
         .          .     37:			p = r.URL.Path[si:]
         .          .     38:			i++
         .          .     39:			continue
         .          .     40:		}
         .          .     41:
         .          .     42:		length := int(sm & smLengthMask)
         .          .     43:		match := false
         .          .     44:		if length <= len(p) {
         .          .     45:			bs := rm.sm[i].bs
         .          .     46:			switch length {
         .          .     47:			case 3:
         .          .     48:				if p[2] != bs[2] {
         .          .     49:					break
         .          .     50:				}
         .          .     51:				fallthrough
         .          .     52:			case 2:
         .          .     53:				if p[1] != bs[1] {
         .          .     54:					break
         .          .     55:				}
         .          .     56:				fallthrough
         .          .     57:			case 1:
         .          .     58:				if p[0] != bs[0] {
         .          .     59:					break
         .          .     60:				}
         .          .     61:				fallthrough
         .          .     62:			case 0:
         .          .     63:				p = p[length:]
         .          .     64:				match = true
         .          .     65:			}
         .          .     66:		}
         .          .     67:
         .          .     68:		if match && sm&smRoute != 0 {
         .          .     69:			si := rm.sm[i].i
         .       60ms     70:			if matchRoute(rm.routes[si], m, &methods, r, c) {
         .          .     71:				return 0, &rm.routes[si]
         .          .     72:			}
         .          .     73:			i++
         .          .     74:		} else if match != (sm&smJumpOnMatch == 0) {
         .          .     75:			if sm&smFail != 0 {
ROUTINE ======================== github.com/zenazn/goji/web.stringPattern.Match in /home/isucon/gocode/src/github.com/zenazn/goji/web/string_pattern.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     18:
         .          .     19:func (s stringPattern) Prefix() string {
         .          .     20:	return s.literals[0]
         .          .     21:}
         .          .     22:func (s stringPattern) Match(r *http.Request, c *C) bool {
         .       20ms     23:	return s.match(r, c, true)
         .          .     24:}
         .          .     25:func (s stringPattern) Run(r *http.Request, c *C) {
         .          .     26:	s.match(r, c, false)
         .          .     27:}
         .          .     28:func (s stringPattern) match(r *http.Request, c *C, dryrun bool) bool {
ROUTINE ======================== github.com/zenazn/goji/web.stringPattern.Run in /home/isucon/gocode/src/github.com/zenazn/goji/web/string_pattern.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     21:}
         .          .     22:func (s stringPattern) Match(r *http.Request, c *C) bool {
         .          .     23:	return s.match(r, c, true)
         .          .     24:}
         .          .     25:func (s stringPattern) Run(r *http.Request, c *C) {
         .       20ms     26:	s.match(r, c, false)
         .          .     27:}
         .          .     28:func (s stringPattern) match(r *http.Request, c *C, dryrun bool) bool {
         .          .     29:	path := r.URL.Path
         .          .     30:	var matches map[string]string
         .          .     31:	if !dryrun {
ROUTINE ======================== github.com/zenazn/goji/web.stringPattern.match in /home/isucon/gocode/src/github.com/zenazn/goji/web/string_pattern.go
      20ms       40ms (flat, cum) 0.072% of Total
         .          .     30:	var matches map[string]string
         .          .     31:	if !dryrun {
         .          .     32:		if s.wildcard {
         .          .     33:			matches = make(map[string]string, len(s.pats)+1)
         .          .     34:		} else if len(s.pats) != 0 {
         .       20ms     35:			matches = make(map[string]string, len(s.pats))
         .          .     36:		}
         .          .     37:	}
      10ms       10ms     38:	for i, pat := range s.pats {
      10ms       10ms     39:		sli := s.literals[i]
         .          .     40:		if !strings.HasPrefix(path, sli) {
         .          .     41:			return false
         .          .     42:		}
         .          .     43:		path = path[len(sli):]
         .          .     44:
ROUTINE ======================== github.com/zenazn/goji/web/middleware.AutomaticOptions.func1 in /home/isucon/gocode/src/github.com/zenazn/goji/web/middleware/options.go
      10ms     46.23s (flat, cum) 83.07% of Total
         .          .     65:	fn := func(w http.ResponseWriter, r *http.Request) {
         .          .     66:		if r.Method == "OPTIONS" {
         .          .     67:			w = &autoOptionsProxy{c: c, w: w}
         .          .     68:		}
         .          .     69:
         .     46.22s     70:		h.ServeHTTP(w, r)
      10ms       10ms     71:	}
         .          .     72:
         .          .     73:	return http.HandlerFunc(fn)
         .          .     74:}
         .          .     75:
         .          .     76:func getValidMethods(c web.C) []string {
ROUTINE ======================== github.com/zenazn/goji/web/middleware.Logger.func1 in /home/isucon/gocode/src/github.com/zenazn/goji/web/middleware/logger.go
         0     46.59s (flat, cum) 83.72% of Total
         .          .     23:// a custom request logger, such as one that produces machine-parseable output,
         .          .     24:// outputs logs to a different service (e.g., syslog), or formats lines like
         .          .     25:// those printed elsewhere in the application.
         .          .     26:func Logger(c *web.C, h http.Handler) http.Handler {
         .          .     27:	fn := func(w http.ResponseWriter, r *http.Request) {
         .       10ms     28:		reqID := GetReqID(*c)
         .          .     29:
         .      160ms     30:		printStart(reqID, r)
         .          .     31:
         .       20ms     32:		lw := mutil.WrapWriter(w)
         .          .     33:
         .          .     34:		t1 := time.Now()
         .     46.24s     35:		h.ServeHTTP(lw, r)
         .          .     36:
         .          .     37:		if lw.Status() == 0 {
         .          .     38:			lw.WriteHeader(http.StatusOK)
         .          .     39:		}
         .          .     40:		t2 := time.Now()
         .          .     41:
         .      160ms     42:		printEnd(reqID, lw, t2.Sub(t1))
         .          .     43:	}
         .          .     44:
         .          .     45:	return http.HandlerFunc(fn)
         .          .     46:}
         .          .     47:
ROUTINE ======================== github.com/zenazn/goji/web/middleware.Recoverer.func1 in /home/isucon/gocode/src/github.com/zenazn/goji/web/middleware/recoverer.go
         0     46.24s (flat, cum) 83.09% of Total
         .          .     14:// possible.
         .          .     15://
         .          .     16:// Recoverer prints a request ID if one is provided.
         .          .     17:func Recoverer(c *web.C, h http.Handler) http.Handler {
         .          .     18:	fn := func(w http.ResponseWriter, r *http.Request) {
         .       10ms     19:		reqID := GetReqID(*c)
         .          .     20:
         .          .     21:		defer func() {
         .          .     22:			if err := recover(); err != nil {
         .          .     23:				printPanic(reqID, err)
         .          .     24:				debug.PrintStack()
         .          .     25:				http.Error(w, http.StatusText(500), 500)
         .          .     26:			}
         .          .     27:		}()
         .          .     28:
         .     46.23s     29:		h.ServeHTTP(w, r)
         .          .     30:	}
         .          .     31:
         .          .     32:	return http.HandlerFunc(fn)
         .          .     33:}
         .          .     34:
ROUTINE ======================== github.com/zenazn/goji/web/middleware.RequestID.func1 in /home/isucon/gocode/src/github.com/zenazn/goji/web/middleware/request_id.go
         0     46.69s (flat, cum) 83.90% of Total
         .          .     58:// process, and where the last number is an atomically incremented request
         .          .     59:// counter.
         .          .     60:func RequestID(c *web.C, h http.Handler) http.Handler {
         .          .     61:	fn := func(w http.ResponseWriter, r *http.Request) {
         .          .     62:		if c.Env == nil {
         .       10ms     63:			c.Env = make(map[interface{}]interface{})
         .          .     64:		}
         .          .     65:		myid := atomic.AddUint64(&reqid, 1)
         .       90ms     66:		c.Env[RequestIDKey] = fmt.Sprintf("%s-%06d", prefix, myid)
         .          .     67:
         .     46.59s     68:		h.ServeHTTP(w, r)
         .          .     69:	}
         .          .     70:
         .          .     71:	return http.HandlerFunc(fn)
         .          .     72:}
         .          .     73:
ROUTINE ======================== github.com/zenazn/goji/web/middleware.cW in /home/isucon/gocode/src/github.com/zenazn/goji/web/middleware/terminal.go
      10ms      120ms (flat, cum)  0.22% of Total
         .          .     51:// colorWrite
         .          .     52:func cW(buf *bytes.Buffer, color []byte, s string, args ...interface{}) {
         .          .     53:	if isTTY {
         .          .     54:		buf.Write(color)
         .          .     55:	}
         .      110ms     56:	fmt.Fprintf(buf, s, args...)
      10ms       10ms     57:	if isTTY {
         .          .     58:		buf.Write(reset)
         .          .     59:	}
         .          .     60:}
ROUTINE ======================== github.com/zenazn/goji/web/middleware.printEnd in /home/isucon/gocode/src/github.com/zenazn/goji/web/middleware/logger.go
      10ms      160ms (flat, cum)  0.29% of Total
         .          .     59:
         .          .     60:	log.Print(buf.String())
         .          .     61:}
         .          .     62:
         .          .     63:func printEnd(reqID string, w mutil.WriterProxy, dt time.Duration) {
         .       10ms     64:	var buf bytes.Buffer
         .          .     65:
         .          .     66:	if reqID != "" {
         .       30ms     67:		cW(&buf, bBlack, "[%s] ", reqID)
         .          .     68:	}
         .          .     69:	buf.WriteString("Returning ")
         .          .     70:	status := w.Status()
         .          .     71:	if status < 200 {
         .          .     72:		cW(&buf, bBlue, "%03d", status)
         .          .     73:	} else if status < 300 {
         .          .     74:		cW(&buf, bGreen, "%03d", status)
         .          .     75:	} else if status < 400 {
         .          .     76:		cW(&buf, bCyan, "%03d", status)
         .          .     77:	} else if status < 500 {
         .          .     78:		cW(&buf, bYellow, "%03d", status)
         .          .     79:	} else {
         .          .     80:		cW(&buf, bRed, "%03d", status)
         .          .     81:	}
         .          .     82:	buf.WriteString(" in ")
         .          .     83:	if dt < 500*time.Millisecond {
         .       20ms     84:		cW(&buf, nGreen, "%s", dt)
         .          .     85:	} else if dt < 5*time.Second {
         .          .     86:		cW(&buf, nYellow, "%s", dt)
         .          .     87:	} else {
         .          .     88:		cW(&buf, nRed, "%s", dt)
         .          .     89:	}
         .          .     90:
         .       90ms     91:	log.Print(buf.String())
      10ms       10ms     92:}
ROUTINE ======================== github.com/zenazn/goji/web/middleware.printStart in /home/isucon/gocode/src/github.com/zenazn/goji/web/middleware/logger.go
         0      160ms (flat, cum)  0.29% of Total
         .          .     51:	if reqID != "" {
         .          .     52:		cW(&buf, bBlack, "[%s] ", reqID)
         .          .     53:	}
         .          .     54:	buf.WriteString("Started ")
         .          .     55:	cW(&buf, bMagenta, "%s ", r.Method)
         .       90ms     56:	cW(&buf, nBlue, "%q ", r.URL.String())
         .       10ms     57:	buf.WriteString("from ")
         .          .     58:	buf.WriteString(r.RemoteAddr)
         .          .     59:
         .       60ms     60:	log.Print(buf.String())
         .          .     61:}
         .          .     62:
         .          .     63:func printEnd(reqID string, w mutil.WriterProxy, dt time.Duration) {
         .          .     64:	var buf bytes.Buffer
         .          .     65:
ROUTINE ======================== github.com/zenazn/goji/web/mutil.(*basicWriter).Write in /home/isucon/gocode/src/github.com/zenazn/goji/web/mutil/writer_proxy.go
      20ms      830ms (flat, cum)  1.49% of Total
         .          .     61:		b.wroteHeader = true
         .          .     62:		b.ResponseWriter.WriteHeader(code)
         .          .     63:	}
         .          .     64:}
         .          .     65:func (b *basicWriter) Write(buf []byte) (int, error) {
         .       30ms     66:	b.WriteHeader(http.StatusOK)
      10ms      790ms     67:	n, err := b.ResponseWriter.Write(buf)
         .          .     68:	if b.tee != nil {
         .          .     69:		_, err2 := b.tee.Write(buf[:n])
         .          .     70:		// Prefer errors generated by the proxied writer.
         .          .     71:		if err == nil {
         .          .     72:			err = err2
         .          .     73:		}
         .          .     74:	}
      10ms       10ms     75:	b.bytes += n
         .          .     76:	return n, err
         .          .     77:}
         .          .     78:func (b *basicWriter) maybeWriteHeader() {
         .          .     79:	if !b.wroteHeader {
         .          .     80:		b.WriteHeader(http.StatusOK)
ROUTINE ======================== github.com/zenazn/goji/web/mutil.(*basicWriter).WriteHeader in /home/isucon/gocode/src/github.com/zenazn/goji/web/mutil/writer_proxy.go
      10ms       60ms (flat, cum)  0.11% of Total
         .          .     57:
         .          .     58:func (b *basicWriter) WriteHeader(code int) {
         .          .     59:	if !b.wroteHeader {
         .          .     60:		b.code = code
         .          .     61:		b.wroteHeader = true
      10ms       60ms     62:		b.ResponseWriter.WriteHeader(code)
         .          .     63:	}
         .          .     64:}
         .          .     65:func (b *basicWriter) Write(buf []byte) (int, error) {
         .          .     66:	b.WriteHeader(http.StatusOK)
         .          .     67:	n, err := b.ResponseWriter.Write(buf)
ROUTINE ======================== github.com/zenazn/goji/web/mutil.(*fancyWriter).Header in <autogenerated>
      20ms       20ms (flat, cum) 0.036% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== github.com/zenazn/goji/web/mutil.(*fancyWriter).ReadFrom in /home/isucon/gocode/src/github.com/zenazn/goji/web/mutil/writer_proxy.go
         0       70ms (flat, cum)  0.13% of Total
         .          .    117:	if f.basicWriter.tee != nil {
         .          .    118:		return io.Copy(&f.basicWriter, r)
         .          .    119:	}
         .          .    120:	rf := f.basicWriter.ResponseWriter.(io.ReaderFrom)
         .          .    121:	f.basicWriter.maybeWriteHeader()
         .       70ms    122:	return rf.ReadFrom(r)
         .          .    123:}
         .          .    124:
         .          .    125:var _ http.CloseNotifier = &fancyWriter{}
         .          .    126:var _ http.Flusher = &fancyWriter{}
         .          .    127:var _ http.Hijacker = &fancyWriter{}
ROUTINE ======================== github.com/zenazn/goji/web/mutil.(*fancyWriter).Write in <autogenerated>
      10ms       10ms (flat, cum) 0.018% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== html/template.(*Template).Execute in /home/isucon/.local/go/src/html/template/template.go
         0      2.04s (flat, cum)  3.67% of Total
         .          .     96:// If an error occurs executing the template or writing its output,
         .          .     97:// execution stops, but partial results may already have been written to
         .          .     98:// the output writer.
         .          .     99:// A template may be executed safely in parallel.
         .          .    100:func (t *Template) Execute(wr io.Writer, data interface{}) error {
         .      400ms    101:	if err := t.escape(); err != nil {
         .          .    102:		return err
         .          .    103:	}
         .      1.64s    104:	return t.text.Execute(wr, data)
         .          .    105:}
         .          .    106:
         .          .    107:// ExecuteTemplate applies the template associated with t that has the given
         .          .    108:// name to the specified data object and writes the output to wr.
         .          .    109:// If an error occurs executing the template or writing its output,
ROUTINE ======================== html/template.(*Template).Funcs in /home/isucon/.local/go/src/html/template/template.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    307:// Funcs adds the elements of the argument map to the template's function map.
         .          .    308:// It panics if a value in the map is not a function with appropriate return
         .          .    309:// type. However, it is legal to overwrite elements of the map. The return
         .          .    310:// value is the template, so calls can be chained.
         .          .    311:func (t *Template) Funcs(funcMap FuncMap) *Template {
         .       10ms    312:	t.text.Funcs(template.FuncMap(funcMap))
         .          .    313:	return t
         .          .    314:}
         .          .    315:
         .          .    316:// Delims sets the action delimiters to the specified strings, to be used in
         .          .    317:// subsequent calls to Parse, ParseFiles, or ParseGlob. Nested template
ROUTINE ======================== html/template.(*Template).Parse in /home/isucon/.local/go/src/html/template/template.go
      10ms      320ms (flat, cum)  0.58% of Total
         .          .    160:// other than space, comments, and template definitions.)
         .          .    161:func (t *Template) Parse(src string) (*Template, error) {
         .          .    162:	t.nameSpace.mu.Lock()
         .          .    163:	t.escapeErr = nil
         .          .    164:	t.nameSpace.mu.Unlock()
         .      300ms    165:	ret, err := t.text.Parse(src)
         .          .    166:	if err != nil {
         .          .    167:		return nil, err
         .          .    168:	}
         .          .    169:	// In general, all the named templates might have changed underfoot.
         .          .    170:	// Regardless, some new ones may have been defined.
         .          .    171:	// The template.Template set has been updated; update ours.
         .          .    172:	t.nameSpace.mu.Lock()
         .          .    173:	defer t.nameSpace.mu.Unlock()
         .       10ms    174:	for _, v := range ret.Templates() {
         .          .    175:		name := v.Name()
      10ms       10ms    176:		tmpl := t.set[name]
         .          .    177:		if tmpl == nil {
         .          .    178:			tmpl = t.new(name)
         .          .    179:		} else if tmpl.escapeErr != nil {
         .          .    180:			return nil, fmt.Errorf("html/template: cannot redefine %q after it has executed", name)
         .          .    181:		}
ROUTINE ======================== html/template.(*Template).ParseFiles in /home/isucon/.local/go/src/html/template/template.go
         0      340ms (flat, cum)  0.61% of Total
         .          .    352:
         .          .    353:// ParseFiles parses the named files and associates the resulting templates with
         .          .    354:// t. If an error occurs, parsing stops and the returned template is nil;
         .          .    355:// otherwise it is t. There must be at least one file.
         .          .    356:func (t *Template) ParseFiles(filenames ...string) (*Template, error) {
         .      340ms    357:	return parseFiles(t, filenames...)
         .          .    358:}
         .          .    359:
         .          .    360:// parseFiles is the helper for the method and function. If the argument
         .          .    361:// template is nil, it is created from the first file.
         .          .    362:func parseFiles(t *Template, filenames ...string) (*Template, error) {
ROUTINE ======================== html/template.(*Template).escape in /home/isucon/.local/go/src/html/template/template.go
         0      400ms (flat, cum)  0.72% of Total
         .          .     80:	defer t.nameSpace.mu.Unlock()
         .          .     81:	if t.escapeErr == nil {
         .          .     82:		if t.Tree == nil {
         .          .     83:			return fmt.Errorf("template: %q is an incomplete or empty template%s", t.Name(), t.DefinedTemplates())
         .          .     84:		}
         .      400ms     85:		if err := escapeTemplate(t, t.text.Root, t.Name()); err != nil {
         .          .     86:			return err
         .          .     87:		}
         .          .     88:	} else if t.escapeErr != escapeOK {
         .          .     89:		return t.escapeErr
         .          .     90:	}
ROUTINE ======================== html/template.(*escaper).commit in /home/isucon/.local/go/src/html/template/escape.go
         0      150ms (flat, cum)  0.27% of Total
         .          .    738:
         .          .    739:// commit applies changes to actions and template calls needed to contextually
         .          .    740:// autoescape content and adds any derived templates to the set.
         .          .    741:func (e *escaper) commit() {
         .          .    742:	for name := range e.output {
         .      130ms    743:		e.template(name).Funcs(funcMap)
         .          .    744:	}
         .          .    745:	for _, t := range e.derived {
         .          .    746:		if _, err := e.tmpl.text.AddParseTree(t.Name(), t.Tree); err != nil {
         .          .    747:			panic("error adding derived template")
         .          .    748:		}
         .          .    749:	}
         .          .    750:	for n, s := range e.actionNodeEdits {
         .       20ms    751:		ensurePipelineContains(n.Pipe, s)
         .          .    752:	}
         .          .    753:	for n, name := range e.templateNodeEdits {
         .          .    754:		n.Name = name
         .          .    755:	}
         .          .    756:	for n, s := range e.textNodeEdits {
ROUTINE ======================== html/template.(*escaper).computeOutCtx in /home/isucon/.local/go/src/html/template/escape.go
         0      250ms (flat, cum)  0.45% of Total
         .          .    531:
         .          .    532:// computeOutCtx takes a template and its start context and computes the output
         .          .    533:// context while storing any inferences in e.
         .          .    534:func (e *escaper) computeOutCtx(c context, t *template.Template) context {
         .          .    535:	// Propagate context over the body.
         .      250ms    536:	c1, ok := e.escapeTemplateBody(c, t)
         .          .    537:	if !ok {
         .          .    538:		// Look for a fixed point by assuming c1 as the output context.
         .          .    539:		if c2, ok2 := e.escapeTemplateBody(c1, t); ok2 {
         .          .    540:			c1, ok = c2, true
         .          .    541:		}
ROUTINE ======================== html/template.(*escaper).editActionNode in /home/isucon/.local/go/src/html/template/escape.go
         0       70ms (flat, cum)  0.13% of Total
         .          .    712:	return context{state: stateTag, element: c.element}, i
         .          .    713:}
         .          .    714:
         .          .    715:// editActionNode records a change to an action pipeline for later commit.
         .          .    716:func (e *escaper) editActionNode(n *parse.ActionNode, cmds []string) {
         .       10ms    717:	if _, ok := e.actionNodeEdits[n]; ok {
         .          .    718:		panic(fmt.Sprintf("node %s shared between templates", n))
         .          .    719:	}
         .       60ms    720:	e.actionNodeEdits[n] = cmds
         .          .    721:}
         .          .    722:
         .          .    723:// editTemplateNode records a change to a {{template}} callee for later commit.
         .          .    724:func (e *escaper) editTemplateNode(n *parse.TemplateNode, callee string) {
         .          .    725:	if _, ok := e.templateNodeEdits[n]; ok {
ROUTINE ======================== html/template.(*escaper).escape in /home/isucon/.local/go/src/html/template/escape.go
         0      420ms (flat, cum)  0.75% of Total
         .          .    114:
         .          .    115:// escape escapes a template node.
         .          .    116:func (e *escaper) escape(c context, n parse.Node) context {
         .          .    117:	switch n := n.(type) {
         .          .    118:	case *parse.ActionNode:
         .       30ms    119:		return e.escapeAction(c, n)
         .          .    120:	case *parse.IfNode:
         .       30ms    121:		return e.escapeBranch(c, &n.BranchNode, "if")
         .          .    122:	case *parse.ListNode:
         .          .    123:		return e.escapeList(c, n)
         .          .    124:	case *parse.RangeNode:
         .       70ms    125:		return e.escapeBranch(c, &n.BranchNode, "range")
         .          .    126:	case *parse.TemplateNode:
         .      170ms    127:		return e.escapeTemplate(c, n)
         .          .    128:	case *parse.TextNode:
         .      120ms    129:		return e.escapeText(c, n)
         .          .    130:	case *parse.WithNode:
         .          .    131:		return e.escapeBranch(c, &n.BranchNode, "with")
         .          .    132:	}
         .          .    133:	panic("escaping " + n.String() + " is unimplemented")
         .          .    134:}
ROUTINE ======================== html/template.(*escaper).escapeAction in /home/isucon/.local/go/src/html/template/escape.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    138:	if len(n.Pipe.Decl) != 0 {
         .          .    139:		// A local variable assignment, not an interpolation.
         .          .    140:		return c
         .          .    141:	}
         .          .    142:	c = nudge(c)
         .       10ms    143:	s := make([]string, 0, 3)
         .          .    144:	switch c.state {
         .          .    145:	case stateError:
         .          .    146:		return c
         .          .    147:	case stateURL, stateCSSDqStr, stateCSSSqStr, stateCSSDqURL, stateCSSSqURL, stateCSSURL:
         .          .    148:		switch c.urlPart {
         .          .    149:		case urlPartNone:
         .          .    150:			s = append(s, "html_template_urlfilter")
         .          .    151:			fallthrough
         .          .    152:		case urlPartPreQuery:
         .          .    153:			switch c.state {
         .          .    154:			case stateCSSDqStr, stateCSSSqStr:
         .          .    155:				s = append(s, "html_template_cssescaper")
         .          .    156:			default:
         .          .    157:				s = append(s, "html_template_urlnormalizer")
         .          .    158:			}
         .          .    159:		case urlPartQueryOrFrag:
         .          .    160:			s = append(s, "html_template_urlescaper")
         .          .    161:		case urlPartUnknown:
         .          .    162:			return context{
         .          .    163:				state: stateError,
         .          .    164:				err:   errorf(ErrAmbigContext, n, n.Line, "%s appears in an ambiguous URL context", n),
         .          .    165:			}
         .          .    166:		default:
         .          .    167:			panic(c.urlPart.String())
         .          .    168:		}
         .          .    169:	case stateJS:
         .          .    170:		s = append(s, "html_template_jsvalescaper")
         .          .    171:		// A slash after a value starts a div operator.
         .          .    172:		c.jsCtx = jsCtxDivOp
         .          .    173:	case stateJSDqStr, stateJSSqStr:
         .          .    174:		s = append(s, "html_template_jsstrescaper")
         .          .    175:	case stateJSRegexp:
         .          .    176:		s = append(s, "html_template_jsregexpescaper")
         .          .    177:	case stateCSS:
         .          .    178:		s = append(s, "html_template_cssvaluefilter")
         .          .    179:	case stateText:
         .          .    180:		s = append(s, "html_template_htmlescaper")
         .          .    181:	case stateRCDATA:
         .          .    182:		s = append(s, "html_template_rcdataescaper")
         .          .    183:	case stateAttr:
         .          .    184:		// Handled below in delim check.
         .          .    185:	case stateAttrName, stateTag:
         .          .    186:		c.state = stateAttrName
         .          .    187:		s = append(s, "html_template_htmlnamefilter")
         .          .    188:	default:
         .          .    189:		if isComment(c.state) {
         .          .    190:			s = append(s, "html_template_commentescaper")
         .          .    191:		} else {
         .          .    192:			panic("unexpected state " + c.state.String())
         .          .    193:		}
         .          .    194:	}
         .          .    195:	switch c.delim {
         .          .    196:	case delimNone:
         .          .    197:		// No extra-escaping needed for raw text content.
         .          .    198:	case delimSpaceOrTagEnd:
         .          .    199:		s = append(s, "html_template_nospaceescaper")
         .          .    200:	default:
         .          .    201:		s = append(s, "html_template_attrescaper")
         .          .    202:	}
         .       20ms    203:	e.editActionNode(n, s)
         .          .    204:	return c
         .          .    205:}
         .          .    206:
         .          .    207:// allIdents returns the names of the identifiers under the Ident field of the node,
         .          .    208:// which might be a singleton (Identifier) or a slice (Field or Chain).
ROUTINE ======================== html/template.(*escaper).escapeBranch in /home/isucon/.local/go/src/html/template/escape.go
         0      120ms (flat, cum)  0.22% of Total
         .          .    411:	}
         .          .    412:}
         .          .    413:
         .          .    414:// escapeBranch escapes a branch template node: "if", "range" and "with".
         .          .    415:func (e *escaper) escapeBranch(c context, n *parse.BranchNode, nodeName string) context {
         .       80ms    416:	c0 := e.escapeList(c, n.List)
         .          .    417:	if nodeName == "range" && c0.state != stateError {
         .          .    418:		// The "true" branch of a "range" node can execute multiple times.
         .          .    419:		// We check that executing n.List once results in the same context
         .          .    420:		// as executing n.List twice.
         .       10ms    421:		c1, _ := e.escapeListConditionally(c0, n.List, nil)
         .          .    422:		c0 = join(c0, c1, n, nodeName)
         .          .    423:		if c0.state == stateError {
         .          .    424:			// Make clear that this is a problem on loop re-entry
         .          .    425:			// since developers tend to overlook that branch when
         .          .    426:			// debugging templates.
         .          .    427:			c0.err.Line = n.Line
         .          .    428:			c0.err.Description = "on range loop re-entry: " + c0.err.Description
         .          .    429:			return c0
         .          .    430:		}
         .          .    431:	}
         .       30ms    432:	c1 := e.escapeList(c, n.ElseList)
         .          .    433:	return join(c0, c1, n, nodeName)
         .          .    434:}
         .          .    435:
         .          .    436:// escapeList escapes a list template node.
         .          .    437:func (e *escaper) escapeList(c context, n *parse.ListNode) context {
ROUTINE ======================== html/template.(*escaper).escapeList in /home/isucon/.local/go/src/html/template/escape.go
         0      230ms (flat, cum)  0.41% of Total
         .          .    437:func (e *escaper) escapeList(c context, n *parse.ListNode) context {
         .          .    438:	if n == nil {
         .          .    439:		return c
         .          .    440:	}
         .          .    441:	for _, m := range n.Nodes {
         .      230ms    442:		c = e.escape(c, m)
         .          .    443:	}
         .          .    444:	return c
         .          .    445:}
         .          .    446:
         .          .    447:// escapeListConditionally escapes a list node but only preserves edits and
ROUTINE ======================== html/template.(*escaper).escapeListConditionally in /home/isucon/.local/go/src/html/template/escape.go
      10ms      320ms (flat, cum)  0.58% of Total
         .          .    447:// escapeListConditionally escapes a list node but only preserves edits and
         .          .    448:// inferences in e if the inferences and output context satisfy filter.
         .          .    449:// It returns the best guess at an output context, and the result of the filter
         .          .    450:// which is the same as whether e was updated.
         .          .    451:func (e *escaper) escapeListConditionally(c context, n *parse.ListNode, filter func(*escaper, context) bool) (context, bool) {
         .       20ms    452:	e1 := newEscaper(e.tmpl)
         .          .    453:	// Make type inferences available to f.
         .          .    454:	for k, v := range e.output {
      10ms       20ms    455:		e1.output[k] = v
         .          .    456:	}
         .      230ms    457:	c = e1.escapeList(c, n)
         .          .    458:	ok := filter != nil && filter(e1, c)
         .          .    459:	if ok {
         .          .    460:		// Copy inferences and edits from e1 back into e.
         .          .    461:		for k, v := range e1.output {
         .          .    462:			e.output[k] = v
         .          .    463:		}
         .          .    464:		for k, v := range e1.derived {
         .          .    465:			e.derived[k] = v
         .          .    466:		}
         .          .    467:		for k, v := range e1.called {
         .          .    468:			e.called[k] = v
         .          .    469:		}
         .          .    470:		for k, v := range e1.actionNodeEdits {
         .       50ms    471:			e.editActionNode(k, v)
         .          .    472:		}
         .          .    473:		for k, v := range e1.templateNodeEdits {
         .          .    474:			e.editTemplateNode(k, v)
         .          .    475:		}
         .          .    476:		for k, v := range e1.textNodeEdits {
ROUTINE ======================== html/template.(*escaper).escapeTemplate in /home/isucon/.local/go/src/html/template/escape.go
         0      170ms (flat, cum)  0.31% of Total
         .          .    480:	return c, ok
         .          .    481:}
         .          .    482:
         .          .    483:// escapeTemplate escapes a {{template}} call node.
         .          .    484:func (e *escaper) escapeTemplate(c context, n *parse.TemplateNode) context {
         .      170ms    485:	c, name := e.escapeTree(c, n, n.Name, n.Line)
         .          .    486:	if name != n.Name {
         .          .    487:		e.editTemplateNode(n, name)
         .          .    488:	}
         .          .    489:	return c
         .          .    490:}
ROUTINE ======================== html/template.(*escaper).escapeTemplateBody in /home/isucon/.local/go/src/html/template/escape.go
         0      250ms (flat, cum)  0.45% of Total
         .          .    570:	// We need to assume an output context so that recursive template calls
         .          .    571:	// take the fast path out of escapeTree instead of infinitely recursing.
         .          .    572:	// Naively assuming that the input context is the same as the output
         .          .    573:	// works >90% of the time.
         .          .    574:	e.output[t.Name()] = c
         .      250ms    575:	return e.escapeListConditionally(c, t.Tree.Root, filter)
         .          .    576:}
         .          .    577:
         .          .    578:// delimEnds maps each delim to a string of characters that terminate it.
         .          .    579:var delimEnds = [...]string{
         .          .    580:	delimDoubleQuote: `"`,
ROUTINE ======================== html/template.(*escaper).escapeText in /home/isucon/.local/go/src/html/template/escape.go
      20ms      120ms (flat, cum)  0.22% of Total
         .          .    591:
         .          .    592:var doctypeBytes = []byte("<!DOCTYPE")
         .          .    593:
         .          .    594:// escapeText escapes a text template node.
         .          .    595:func (e *escaper) escapeText(c context, n *parse.TextNode) context {
         .       10ms    596:	s, written, i, b := n.Text, 0, 0, new(bytes.Buffer)
         .          .    597:	for i != len(s) {
      10ms      100ms    598:		c1, nread := contextAfterText(c, s[i:])
         .          .    599:		i1 := i + nread
         .          .    600:		if c.state == stateText || c.state == stateRCDATA {
         .          .    601:			end := i1
         .          .    602:			if c1.state != c.state {
         .          .    603:				for j := end - 1; j >= i; j-- {
         .          .    604:					if s[j] == '<' {
         .          .    605:						end = j
         .          .    606:						break
         .          .    607:					}
         .          .    608:				}
         .          .    609:			}
         .          .    610:			for j := i; j < end; j++ {
         .          .    611:				if s[j] == '<' && !bytes.HasPrefix(bytes.ToUpper(s[j:]), doctypeBytes) {
         .          .    612:					b.Write(s[written:j])
         .          .    613:					b.WriteString("&lt;")
         .          .    614:					written = j + 1
         .          .    615:				}
         .          .    616:			}
         .          .    617:		} else if isComment(c.state) && c.delim == delimNone {
         .          .    618:			switch c.state {
         .          .    619:			case stateJSBlockCmt:
         .          .    620:				// http://es5.github.com/#x7.4:
         .          .    621:				// "Comments behave like white space and are
         .          .    622:				// discarded except that, if a MultiLineComment
         .          .    623:				// contains a line terminator character, then
         .          .    624:				// the entire comment is considered to be a
         .          .    625:				// LineTerminator for purposes of parsing by
         .          .    626:				// the syntactic grammar."
         .          .    627:				if bytes.IndexAny(s[written:i1], "\n\r\u2028\u2029") != -1 {
         .          .    628:					b.WriteByte('\n')
         .          .    629:				} else {
         .          .    630:					b.WriteByte(' ')
         .          .    631:				}
         .          .    632:			case stateCSSBlockCmt:
         .          .    633:				b.WriteByte(' ')
         .          .    634:			}
         .          .    635:			written = i1
         .          .    636:		}
         .          .    637:		if c.state != c1.state && isComment(c1.state) && c1.delim == delimNone {
         .          .    638:			// Preserve the portion between written and the comment start.
         .          .    639:			cs := i1 - 2
         .          .    640:			if c1.state == stateHTMLCmt {
         .          .    641:				// "<!--" instead of "/*" or "//"
         .          .    642:				cs -= 2
         .          .    643:			}
         .          .    644:			b.Write(s[written:cs])
         .          .    645:			written = i1
         .          .    646:		}
      10ms       10ms    647:		if i == i1 && c.state == c1.state {
         .          .    648:			panic(fmt.Sprintf("infinite loop from %v to %v on %q..%q", c, c1, s[:i], s[i:]))
         .          .    649:		}
         .          .    650:		c, i = c1, i1
         .          .    651:	}
         .          .    652:
ROUTINE ======================== html/template.(*escaper).escapeTree in /home/isucon/.local/go/src/html/template/escape.go
         0      260ms (flat, cum)  0.47% of Total
         .          .    493:// necessary and returns its output context.
         .          .    494:func (e *escaper) escapeTree(c context, node parse.Node, name string, line int) (context, string) {
         .          .    495:	// Mangle the template name with the input context to produce a reliable
         .          .    496:	// identifier.
         .          .    497:	dname := c.mangle(name)
         .       10ms    498:	e.called[dname] = true
         .          .    499:	if out, ok := e.output[dname]; ok {
         .          .    500:		// Already escaped.
         .          .    501:		return out, dname
         .          .    502:	}
         .          .    503:	t := e.template(name)
         .          .    504:	if t == nil {
         .          .    505:		// Two cases: The template exists but is empty, or has never been mentioned at
         .          .    506:		// all. Distinguish the cases in the error messages.
         .          .    507:		if e.tmpl.set[name] != nil {
         .          .    508:			return context{
         .          .    509:				state: stateError,
         .          .    510:				err:   errorf(ErrNoSuchTemplate, node, line, "%q is an incomplete or empty template", name),
         .          .    511:			}, dname
         .          .    512:		}
         .          .    513:		return context{
         .          .    514:			state: stateError,
         .          .    515:			err:   errorf(ErrNoSuchTemplate, node, line, "no such template %q", name),
         .          .    516:		}, dname
         .          .    517:	}
         .          .    518:	if dname != name {
         .          .    519:		// Use any template derived during an earlier call to escapeTemplate
         .          .    520:		// with different top level templates, or clone if necessary.
         .          .    521:		dt := e.template(dname)
         .          .    522:		if dt == nil {
         .          .    523:			dt = template.New(dname)
         .          .    524:			dt.Tree = &parse.Tree{Name: dname, Root: t.Root.CopyList()}
         .          .    525:			e.derived[dname] = dt
         .          .    526:		}
         .          .    527:		t = dt
         .          .    528:	}
         .      250ms    529:	return e.computeOutCtx(c, t), dname
         .          .    530:}
         .          .    531:
         .          .    532:// computeOutCtx takes a template and its start context and computes the output
         .          .    533:// context while storing any inferences in e.
         .          .    534:func (e *escaper) computeOutCtx(c context, t *template.Template) context {
ROUTINE ======================== html/template.ParseFiles in /home/isucon/.local/go/src/html/template/template.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    345:// ParseFiles creates a new Template and parses the template definitions from
         .          .    346:// the named files. The returned template's name will have the (base) name and
         .          .    347:// (parsed) contents of the first file. There must be at least one file.
         .          .    348:// If an error occurs, parsing stops and the returned *Template is nil.
         .          .    349:func ParseFiles(filenames ...string) (*Template, error) {
         .       20ms    350:	return parseFiles(nil, filenames...)
         .          .    351:}
         .          .    352:
         .          .    353:// ParseFiles parses the named files and associates the resulting templates with
         .          .    354:// t. If an error occurs, parsing stops and the returned template is nil;
         .          .    355:// otherwise it is t. There must be at least one file.
ROUTINE ======================== html/template.allIdents in /home/isucon/.local/go/src/html/template/escape.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    207:// allIdents returns the names of the identifiers under the Ident field of the node,
         .          .    208:// which might be a singleton (Identifier) or a slice (Field or Chain).
         .          .    209:func allIdents(node parse.Node) []string {
         .          .    210:	switch node := node.(type) {
         .          .    211:	case *parse.IdentifierNode:
         .       10ms    212:		return []string{node.Ident}
         .          .    213:	case *parse.FieldNode:
         .          .    214:		return node.Ident
         .          .    215:	case *parse.ChainNode:
         .          .    216:		return node.Field
         .          .    217:	}
ROUTINE ======================== html/template.attrEscaper in /home/isucon/.local/go/src/html/template/html.go
      20ms      110ms (flat, cum)   0.2% of Total
         .          .     19:	}
         .          .     20:	return htmlReplacer(s, htmlNospaceReplacementTable, false)
         .          .     21:}
         .          .     22:
         .          .     23:// attrEscaper escapes for inclusion in quoted attribute values.
      10ms       10ms     24:func attrEscaper(args ...interface{}) string {
         .       40ms     25:	s, t := stringify(args...)
         .          .     26:	if t == contentTypeHTML {
         .          .     27:		return htmlReplacer(stripTags(s), htmlNormReplacementTable, true)
         .          .     28:	}
      10ms       60ms     29:	return htmlReplacer(s, htmlReplacementTable, true)
         .          .     30:}
         .          .     31:
         .          .     32:// rcdataEscaper escapes for inclusion in an RCDATA element body.
         .          .     33:func rcdataEscaper(args ...interface{}) string {
         .          .     34:	s, t := stringify(args...)
ROUTINE ======================== html/template.attrType in /home/isucon/.local/go/src/html/template/attr.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .    141:	if strings.HasPrefix(name, "data-") {
         .          .    142:		// Strip data- so that custom attribute heuristics below are
         .          .    143:		// widely applied.
         .          .    144:		// Treat data-action as URL below.
         .          .    145:		name = name[5:]
      10ms       10ms    146:	} else if colon := strings.IndexRune(name, ':'); colon != -1 {
         .          .    147:		if name[:colon] == "xmlns" {
         .          .    148:			return contentTypeURL
         .          .    149:		}
         .          .    150:		// Treat svg:href and xlink:href as href below.
         .          .    151:		name = name[colon+1:]
         .          .    152:	}
         .          .    153:	if t, ok := attrTypeMap[name]; ok {
         .          .    154:		return t
         .          .    155:	}
         .          .    156:	// Treat partial event handler names as script.
         .          .    157:	if strings.HasPrefix(name, "on") {
         .          .    158:		return contentTypeJS
         .          .    159:	}
         .          .    160:
         .          .    161:	// Heuristics to prevent "javascript:..." injection in custom
         .          .    162:	// data attributes and custom attributes like g:tweetUrl.
         .          .    163:	// http://www.w3.org/TR/html5/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes
         .          .    164:	// "Custom data attributes are intended to store custom data
         .          .    165:	//  private to the page or application, for which there are no
         .          .    166:	//  more appropriate attributes or elements."
         .          .    167:	// Developers seem to store URL content in data URLs that start
         .          .    168:	// or end with "URI" or "URL".
         .       10ms    169:	if strings.Contains(name, "src") ||
         .          .    170:		strings.Contains(name, "uri") ||
         .          .    171:		strings.Contains(name, "url") {
         .          .    172:		return contentTypeURL
         .          .    173:	}
         .          .    174:	return contentTypePlain
ROUTINE ======================== html/template.contextAfterText in /home/isucon/.local/go/src/html/template/escape.go
      20ms       90ms (flat, cum)  0.16% of Total
         .          .    659:	return c
         .          .    660:}
         .          .    661:
         .          .    662:// contextAfterText starts in context c, consumes some tokens from the front of
         .          .    663:// s, then returns the context after those tokens and the unprocessed suffix.
      10ms       10ms    664:func contextAfterText(c context, s []byte) (context, int) {
         .          .    665:	if c.delim == delimNone {
         .          .    666:		c1, i := tSpecialTagEnd(c, s)
         .          .    667:		if i == 0 {
         .          .    668:			// A special end tag (`</script>`) has been seen and
         .          .    669:			// all content preceding it has been consumed.
         .          .    670:			return c1, 0
         .          .    671:		}
         .          .    672:		// Consider all content up to any end tag.
      10ms       80ms    673:		return transitionFunc[c.state](c, s[:i])
         .          .    674:	}
         .          .    675:
         .          .    676:	i := bytes.IndexAny(s, delimEnds[c.delim])
         .          .    677:	if i == -1 {
         .          .    678:		i = len(s)
ROUTINE ======================== html/template.eatTagName in /home/isucon/.local/go/src/html/template/transition.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    561:			j += 2
         .          .    562:			continue
         .          .    563:		}
         .          .    564:		break
         .          .    565:	}
         .       20ms    566:	return j, elementNameMap[strings.ToLower(string(s[i:j]))]
         .          .    567:}
         .          .    568:
         .          .    569:// eatWhiteSpace returns the largest j such that s[i:j] is white space.
         .          .    570:func eatWhiteSpace(s []byte, i int) int {
         .          .    571:	for j := i; j < len(s); j++ {
ROUTINE ======================== html/template.ensurePipelineContains in /home/isucon/.local/go/src/html/template/escape.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    239:		}
         .          .    240:		idents = p.Cmds[i+1:]
         .          .    241:	}
         .          .    242:	dups := 0
         .          .    243:	for _, idNode := range idents {
         .       10ms    244:		for _, ident := range allIdents(idNode.Args[0]) {
         .          .    245:			if escFnsEq(s[dups], ident) {
         .          .    246:				dups++
         .          .    247:				if dups == len(s) {
         .          .    248:					return
         .          .    249:				}
         .          .    250:			}
         .          .    251:		}
         .          .    252:	}
         .          .    253:	newCmds := make([]*parse.CommandNode, n-len(idents), n+len(s)-dups)
         .          .    254:	copy(newCmds, p.Cmds)
         .          .    255:	// Merge existing identifier commands with the sanitizers needed.
         .          .    256:	for _, idNode := range idents {
         .          .    257:		pos := idNode.Args[0].Position()
         .          .    258:		for _, ident := range allIdents(idNode.Args[0]) {
         .          .    259:			i := indexOfStr(ident, s, escFnsEq)
         .          .    260:			if i != -1 {
         .          .    261:				for _, name := range s[:i] {
         .          .    262:					newCmds = appendCmd(newCmds, newIdentCmd(name, pos))
         .          .    263:				}
         .          .    264:				s = s[i+1:]
         .          .    265:			}
         .          .    266:		}
         .          .    267:		newCmds = appendCmd(newCmds, idNode)
         .          .    268:	}
         .          .    269:	// Create any remaining sanitizers.
         .          .    270:	for _, name := range s {
         .       10ms    271:		newCmds = appendCmd(newCmds, newIdentCmd(name, p.Position()))
         .          .    272:	}
         .          .    273:	p.Cmds = newCmds
         .          .    274:}
         .          .    275:
         .          .    276:// redundantFuncs[a][b] implies that funcMap[b](funcMap[a](x)) == funcMap[a](x)
ROUTINE ======================== html/template.escapeTemplate in /home/isucon/.local/go/src/html/template/escape.go
         0      400ms (flat, cum)  0.72% of Total
         .          .     18:// templates is properly escaped.  If no error is returned, then the named templates have
         .          .     19:// been modified.  Otherwise the named templates have been rendered
         .          .     20:// unusable.
         .          .     21:func escapeTemplate(tmpl *Template, node parse.Node, name string) error {
         .          .     22:	e := newEscaper(tmpl)
         .      250ms     23:	c, _ := e.escapeTree(context{}, node, name, 0)
         .          .     24:	var err error
         .          .     25:	if c.err != nil {
         .          .     26:		err, c.err.Name = c.err, name
         .          .     27:	} else if c.state != stateText {
         .          .     28:		err = &Error{ErrEndContext, nil, name, 0, fmt.Sprintf("ends in a non-text context: %v", c)}
         .          .     29:	}
         .          .     30:	if err != nil {
         .          .     31:		// Prevent execution of unsafe templates.
         .          .     32:		if t := tmpl.set[name]; t != nil {
         .          .     33:			t.escapeErr = err
         .          .     34:			t.text.Tree = nil
         .          .     35:			t.Tree = nil
         .          .     36:		}
         .          .     37:		return err
         .          .     38:	}
         .      150ms     39:	e.commit()
         .          .     40:	if t := tmpl.set[name]; t != nil {
         .          .     41:		t.escapeErr = escapeOK
         .          .     42:		t.Tree = t.text.Tree
         .          .     43:	}
         .          .     44:	return nil
ROUTINE ======================== html/template.htmlEscaper in /home/isucon/.local/go/src/html/template/html.go
         0       80ms (flat, cum)  0.14% of Total
         .          .     42:func htmlEscaper(args ...interface{}) string {
         .          .     43:	s, t := stringify(args...)
         .          .     44:	if t == contentTypeHTML {
         .          .     45:		return s
         .          .     46:	}
         .       80ms     47:	return htmlReplacer(s, htmlReplacementTable, true)
         .          .     48:}
         .          .     49:
         .          .     50:// htmlReplacementTable contains the runes that need to be escaped
         .          .     51:// inside a quoted attribute value or in a text node.
         .          .     52:var htmlReplacementTable = []string{
ROUTINE ======================== html/template.htmlReplacer in /home/isucon/.local/go/src/html/template/html.go
      20ms      130ms (flat, cum)  0.23% of Total
         .          .    135:}
         .          .    136:
         .          .    137:// htmlReplacer returns s with runes replaced according to replacementTable
         .          .    138:// and when badRunes is true, certain bad runes are allowed through unescaped.
         .          .    139:func htmlReplacer(s string, replacementTable []string, badRunes bool) string {
         .       50ms    140:	written, b := 0, new(bytes.Buffer)
         .          .    141:	r, w := rune(0), 0
         .          .    142:	for i := 0; i < len(s); i += w {
         .          .    143:		// Cannot use 'for range s' because we need to preserve the width
         .          .    144:		// of the runes in the input. If we see a decoding error, the input
         .          .    145:		// width will not be utf8.Runelen(r) and we will overrun the buffer.
      20ms       30ms    146:		r, w = utf8.DecodeRuneInString(s[i:])
         .          .    147:		if int(r) < len(replacementTable) {
         .          .    148:			if repl := replacementTable[r]; len(repl) != 0 {
         .       10ms    149:				b.WriteString(s[written:i])
         .       10ms    150:				b.WriteString(repl)
         .          .    151:				written = i + w
         .          .    152:			}
         .          .    153:		} else if badRunes {
         .          .    154:			// No-op.
         .          .    155:			// IE does not allow these ranges in unquoted attrs.
         .          .    156:		} else if 0xfdd0 <= r && r <= 0xfdef || 0xfff0 <= r && r <= 0xffff {
         .          .    157:			fmt.Fprintf(b, "%s&#x%x;", s[written:i], r)
         .          .    158:			written = i + w
         .          .    159:		}
         .          .    160:	}
         .          .    161:	if written == 0 {
         .          .    162:		return s
         .          .    163:	}
         .       30ms    164:	b.WriteString(s[written:])
         .          .    165:	return b.String()
         .          .    166:}
         .          .    167:
         .          .    168:// stripTags takes a snippet of HTML and returns only the text content.
         .          .    169:// For example, `<b>&iexcl;Hi!</b> <script>...</script>` -> `&iexcl;Hi! `.
ROUTINE ======================== html/template.parseFiles in /home/isucon/.local/go/src/html/template/template.go
         0      360ms (flat, cum)  0.65% of Total
         .          .    363:	if len(filenames) == 0 {
         .          .    364:		// Not really a problem, but be consistent.
         .          .    365:		return nil, fmt.Errorf("html/template: no files named in call to ParseFiles")
         .          .    366:	}
         .          .    367:	for _, filename := range filenames {
         .       40ms    368:		b, err := ioutil.ReadFile(filename)
         .          .    369:		if err != nil {
         .          .    370:			return nil, err
         .          .    371:		}
         .          .    372:		s := string(b)
         .          .    373:		name := filepath.Base(filename)
         .          .    374:		// First template becomes return value if not already defined,
         .          .    375:		// and we use that one for subsequent New calls to associate
         .          .    376:		// all the templates together. Also, if this file has the same name
         .          .    377:		// as t, this file becomes the contents of t, so
         .          .    378:		//  t, err := New(name).Funcs(xxx).ParseFiles(name)
         .          .    379:		// works. Otherwise we create a new template associated with t.
         .          .    380:		var tmpl *Template
         .          .    381:		if t == nil {
         .          .    382:			t = New(name)
         .          .    383:		}
         .          .    384:		if name == t.Name() {
         .          .    385:			tmpl = t
         .          .    386:		} else {
         .          .    387:			tmpl = t.New(name)
         .          .    388:		}
         .      320ms    389:		_, err = tmpl.Parse(s)
         .          .    390:		if err != nil {
         .          .    391:			return nil, err
         .          .    392:		}
         .          .    393:	}
         .          .    394:	return t, nil
ROUTINE ======================== html/template.stringify in /home/isucon/.local/go/src/html/template/content.go
      20ms       50ms (flat, cum)  0.09% of Total
         .          .    110:
         .          .    111:// stringify converts its arguments to a string and the type of the content.
         .          .    112:// All pointers are dereferenced, as in the text/template package.
         .          .    113:func stringify(args ...interface{}) (string, contentType) {
         .          .    114:	if len(args) == 1 {
      20ms       30ms    115:		switch s := indirect(args[0]).(type) {
         .          .    116:		case string:
         .          .    117:			return s, contentTypePlain
         .          .    118:		case CSS:
         .          .    119:			return string(s), contentTypeCSS
         .          .    120:		case HTML:
         .          .    121:			return string(s), contentTypeHTML
         .          .    122:		case HTMLAttr:
         .          .    123:			return string(s), contentTypeHTMLAttr
         .          .    124:		case JS:
         .          .    125:			return string(s), contentTypeJS
         .          .    126:		case JSStr:
         .          .    127:			return string(s), contentTypeJSStr
         .          .    128:		case URL:
         .          .    129:			return string(s), contentTypeURL
         .          .    130:		}
         .          .    131:	}
         .          .    132:	for i, arg := range args {
         .          .    133:		args[i] = indirectToStringerOrError(arg)
         .          .    134:	}
         .       20ms    135:	return fmt.Sprint(args...), contentTypePlain
         .          .    136:}
ROUTINE ======================== html/template.tTag in /home/isucon/.local/go/src/html/template/transition.go
      10ms       40ms (flat, cum) 0.072% of Total
         .          .     82:}
         .          .     83:
         .          .     84:// tTag is the context transition function for the tag state.
         .          .     85:func tTag(c context, s []byte) (context, int) {
         .          .     86:	// Find the attribute name.
      10ms       10ms     87:	i := eatWhiteSpace(s, 0)
         .          .     88:	if i == len(s) {
         .          .     89:		return c, len(s)
         .          .     90:	}
         .          .     91:	if s[i] == '>' {
         .          .     92:		return context{
         .          .     93:			state:   elementContentType[c.element],
         .          .     94:			element: c.element,
         .          .     95:		}, i + 1
         .          .     96:	}
         .          .     97:	j, err := eatAttrName(s, i)
         .          .     98:	if err != nil {
         .          .     99:		return context{state: stateError, err: err}, len(s)
         .          .    100:	}
         .          .    101:	state, attr := stateTag, attrNone
         .          .    102:	if i == j {
         .          .    103:		return context{
         .          .    104:			state: stateError,
         .          .    105:			err:   errorf(ErrBadHTML, nil, 0, "expected space, attr name, or end of tag, but got %q", s[i:]),
         .          .    106:		}, len(s)
         .          .    107:	}
         .       30ms    108:	switch attrType(string(s[i:j])) {
         .          .    109:	case contentTypeURL:
         .          .    110:		attr = attrURL
         .          .    111:	case contentTypeCSS:
         .          .    112:		attr = attrStyle
         .          .    113:	case contentTypeJS:
ROUTINE ======================== html/template.tText in /home/isucon/.local/go/src/html/template/transition.go
      10ms       30ms (flat, cum) 0.054% of Total
         .          .     42:
         .          .     43:var commentStart = []byte("<!--")
         .          .     44:var commentEnd = []byte("-->")
         .          .     45:
         .          .     46:// tText is the context transition function for the text state.
      10ms       10ms     47:func tText(c context, s []byte) (context, int) {
         .          .     48:	k := 0
         .          .     49:	for {
         .          .     50:		i := k + bytes.IndexByte(s[k:], '<')
         .          .     51:		if i < k || i+1 == len(s) {
         .          .     52:			return c, len(s)
         .          .     53:		} else if i+4 <= len(s) && bytes.Equal(commentStart, s[i:i+4]) {
         .          .     54:			return context{state: stateHTMLCmt}, i + 4
         .          .     55:		}
         .          .     56:		i++
         .          .     57:		end := false
         .          .     58:		if s[i] == '/' {
         .          .     59:			if i+1 == len(s) {
         .          .     60:				return c, len(s)
         .          .     61:			}
         .          .     62:			end, i = true, i+1
         .          .     63:		}
         .       20ms     64:		j, e := eatTagName(s, i)
         .          .     65:		if j != i {
         .          .     66:			if end {
         .          .     67:				e = elementNone
         .          .     68:			}
         .          .     69:			// We've found an HTML tag.
ROUTINE ======================== html/template.urlNormalizer in /home/isucon/.local/go/src/html/template/url.go
         0       40ms (flat, cum) 0.072% of Total
         .          .     36:// string or parenthesis delimited url(...).
         .          .     37:// The normalizer does not encode all HTML specials. Specifically, it does not
         .          .     38:// encode '&' so correct embedding in an HTML attribute requires escaping of
         .          .     39:// '&' to '&amp;'.
         .          .     40:func urlNormalizer(args ...interface{}) string {
         .       40ms     41:	return urlProcessor(true, args...)
         .          .     42:}
         .          .     43:
         .          .     44:// urlProcessor normalizes (when norm is true) or escapes its input to produce
         .          .     45:// a valid hierarchical or opaque URL part.
         .          .     46:func urlProcessor(norm bool, args ...interface{}) string {
ROUTINE ======================== html/template.urlProcessor in /home/isucon/.local/go/src/html/template/url.go
      10ms       40ms (flat, cum) 0.072% of Total
         .          .     42:}
         .          .     43:
         .          .     44:// urlProcessor normalizes (when norm is true) or escapes its input to produce
         .          .     45:// a valid hierarchical or opaque URL part.
         .          .     46:func urlProcessor(norm bool, args ...interface{}) string {
         .       10ms     47:	s, t := stringify(args...)
         .          .     48:	if t == contentTypeURL {
         .          .     49:		norm = true
         .          .     50:	}
      10ms       30ms     51:	var b bytes.Buffer
         .          .     52:	written := 0
         .          .     53:	// The byte loop below assumes that all URLs use UTF-8 as the
         .          .     54:	// content-encoding. This is similar to the URI to IRI encoding scheme
         .          .     55:	// defined in section 3.1 of  RFC 3987, and behaves the same as the
         .          .     56:	// EcmaScript builtin encodeURIComponent.
ROUTINE ======================== internal/singleflight.(*Group).Do in /home/isucon/.local/go/src/internal/singleflight/singleflight.go
         0      210ms (flat, cum)  0.38% of Total
         .          .     58:	c := new(call)
         .          .     59:	c.wg.Add(1)
         .          .     60:	g.m[key] = c
         .          .     61:	g.mu.Unlock()
         .          .     62:
         .      210ms     63:	g.doCall(c, key, fn)
         .          .     64:	return c.val, c.err, c.dups > 0
         .          .     65:}
         .          .     66:
         .          .     67:// DoChan is like Do but returns a channel that will receive the
         .          .     68:// results when they are ready.
ROUTINE ======================== internal/singleflight.(*Group).doCall in /home/isucon/.local/go/src/internal/singleflight/singleflight.go
         0      210ms (flat, cum)  0.38% of Total
         .          .     88:	return ch
         .          .     89:}
         .          .     90:
         .          .     91:// doCall handles the single call for a key.
         .          .     92:func (g *Group) doCall(c *call, key string, fn func() (interface{}, error)) {
         .      210ms     93:	c.val, c.err = fn()
         .          .     94:	c.wg.Done()
         .          .     95:
         .          .     96:	g.mu.Lock()
         .          .     97:	delete(g.m, key)
         .          .     98:	for _, ch := range c.chans {
ROUTINE ======================== io.(*LimitedReader).Read in /home/isucon/.local/go/src/io/io.go
         0       40ms (flat, cum) 0.072% of Total
         .          .    421:		return 0, EOF
         .          .    422:	}
         .          .    423:	if int64(len(p)) > l.N {
         .          .    424:		p = p[0:l.N]
         .          .    425:	}
         .       40ms    426:	n, err = l.R.Read(p)
         .          .    427:	l.N -= int64(n)
         .          .    428:	return
         .          .    429:}
         .          .    430:
         .          .    431:// NewSectionReader returns a SectionReader that reads from r
ROUTINE ======================== io.Copy in /home/isucon/.local/go/src/io/io.go
         0      260ms (flat, cum)  0.47% of Total
         .          .    345:// If src implements the WriterTo interface,
         .          .    346:// the copy is implemented by calling src.WriteTo(dst).
         .          .    347:// Otherwise, if dst implements the ReaderFrom interface,
         .          .    348:// the copy is implemented by calling dst.ReadFrom(src).
         .          .    349:func Copy(dst Writer, src Reader) (written int64, err error) {
         .      260ms    350:	return copyBuffer(dst, src, nil)
         .          .    351:}
         .          .    352:
         .          .    353:// CopyBuffer is identical to Copy except that it stages through the
         .          .    354:// provided buffer (if one is required) rather than allocating a
         .          .    355:// temporary one. If buf is nil, one is allocated; otherwise if it has
ROUTINE ======================== io.CopyN in /home/isucon/.local/go/src/io/io.go
         0      140ms (flat, cum)  0.25% of Total
         .          .    321:// On return, written == n if and only if err == nil.
         .          .    322://
         .          .    323:// If dst implements the ReaderFrom interface,
         .          .    324:// the copy is implemented using it.
         .          .    325:func CopyN(dst Writer, src Reader, n int64) (written int64, err error) {
         .      140ms    326:	written, err = Copy(dst, LimitReader(src, n))
         .          .    327:	if written == n {
         .          .    328:		return n, nil
         .          .    329:	}
         .          .    330:	if written < n && err == nil {
         .          .    331:		// src stopped early; must have been EOF.
ROUTINE ======================== io.ReadAtLeast in /home/isucon/.local/go/src/io/io.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    292:	if len(buf) < min {
         .          .    293:		return 0, ErrShortBuffer
         .          .    294:	}
         .          .    295:	for n < min && err == nil {
         .          .    296:		var nn int
         .       10ms    297:		nn, err = r.Read(buf[n:])
         .          .    298:		n += nn
         .          .    299:	}
         .          .    300:	if n >= min {
         .          .    301:		err = nil
         .          .    302:	} else if n > 0 && err == EOF {
ROUTINE ======================== io.ReadFull in /home/isucon/.local/go/src/io/io.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    310:// The error is EOF only if no bytes were read.
         .          .    311:// If an EOF happens after reading some but not all the bytes,
         .          .    312:// ReadFull returns ErrUnexpectedEOF.
         .          .    313:// On return, n == len(buf) if and only if err == nil.
         .          .    314:func ReadFull(r Reader, buf []byte) (n int, err error) {
         .       10ms    315:	return ReadAtLeast(r, buf, len(buf))
         .          .    316:}
         .          .    317:
         .          .    318:// CopyN copies n bytes (or until an error) from src to dst.
         .          .    319:// It returns the number of bytes copied and the earliest
         .          .    320:// error encountered while copying.
ROUTINE ======================== io.copyBuffer in /home/isucon/.local/go/src/io/io.go
         0      260ms (flat, cum)  0.47% of Total
         .          .    369:	if wt, ok := src.(WriterTo); ok {
         .          .    370:		return wt.WriteTo(dst)
         .          .    371:	}
         .          .    372:	// Similarly, if the writer has a ReadFrom method, use it to do the copy.
         .          .    373:	if rt, ok := dst.(ReaderFrom); ok {
         .      210ms    374:		return rt.ReadFrom(src)
         .          .    375:	}
         .          .    376:	if buf == nil {
         .       40ms    377:		buf = make([]byte, 32*1024)
         .          .    378:	}
         .          .    379:	for {
         .       10ms    380:		nr, er := src.Read(buf)
         .          .    381:		if nr > 0 {
         .          .    382:			nw, ew := dst.Write(buf[0:nr])
         .          .    383:			if nw > 0 {
         .          .    384:				written += int64(nw)
         .          .    385:			}
ROUTINE ======================== io/ioutil.ReadAll in /home/isucon/.local/go/src/io/ioutil/ioutil.go
         0       40ms (flat, cum) 0.072% of Total
         .          .     37:// ReadAll reads from r until an error or EOF and returns the data it read.
         .          .     38:// A successful call returns err == nil, not err == EOF. Because ReadAll is
         .          .     39:// defined to read from src until EOF, it does not treat an EOF from Read
         .          .     40:// as an error to be reported.
         .          .     41:func ReadAll(r io.Reader) ([]byte, error) {
         .       40ms     42:	return readAll(r, bytes.MinRead)
         .          .     43:}
         .          .     44:
         .          .     45:// ReadFile reads the file named by filename and returns the contents.
         .          .     46:// A successful call returns err == nil, not err == EOF. Because ReadFile
         .          .     47:// reads the whole file, it does not treat an EOF from Read as an error
ROUTINE ======================== io/ioutil.ReadFile in /home/isucon/.local/go/src/io/ioutil/ioutil.go
         0       40ms (flat, cum) 0.072% of Total
         .          .     45:// ReadFile reads the file named by filename and returns the contents.
         .          .     46:// A successful call returns err == nil, not err == EOF. Because ReadFile
         .          .     47:// reads the whole file, it does not treat an EOF from Read as an error
         .          .     48:// to be reported.
         .          .     49:func ReadFile(filename string) ([]byte, error) {
         .       10ms     50:	f, err := os.Open(filename)
         .          .     51:	if err != nil {
         .          .     52:		return nil, err
         .          .     53:	}
         .       10ms     54:	defer f.Close()
         .          .     55:	// It's a good but not certain bet that FileInfo will tell us exactly how much to
         .          .     56:	// read, so let's try it but be prepared for the answer to be wrong.
         .          .     57:	var n int64
         .          .     58:
         .          .     59:	if fi, err := f.Stat(); err == nil {
         .          .     60:		// Don't preallocate a huge buffer, just in case.
         .          .     61:		if size := fi.Size(); size < 1e9 {
         .          .     62:			n = size
         .          .     63:		}
         .          .     64:	}
         .          .     65:	// As initial capacity for readAll, use n + a little extra in case Size is zero,
         .          .     66:	// and to avoid another allocation after Read has filled the buffer.  The readAll
         .          .     67:	// call will read into its allocated internal buffer cheaply.  If the size was
         .          .     68:	// wrong, we'll either waste some space off the end or reallocate as needed, but
         .          .     69:	// in the overwhelmingly common case we'll get it just right.
         .       20ms     70:	return readAll(f, n+bytes.MinRead)
         .          .     71:}
         .          .     72:
         .          .     73:// WriteFile writes data to a file named by filename.
         .          .     74:// If the file does not exist, WriteFile creates it with permissions perm;
         .          .     75:// otherwise WriteFile truncates it before writing.
ROUTINE ======================== io/ioutil.readAll in /home/isucon/.local/go/src/io/ioutil/ioutil.go
         0       60ms (flat, cum)  0.11% of Total
         .          .     28:			err = panicErr
         .          .     29:		} else {
         .          .     30:			panic(e)
         .          .     31:		}
         .          .     32:	}()
         .       60ms     33:	_, err = buf.ReadFrom(r)
         .          .     34:	return buf.Bytes(), err
         .          .     35:}
         .          .     36:
         .          .     37:// ReadAll reads from r until an error or EOF and returns the data it read.
         .          .     38:// A successful call returns err == nil, not err == EOF. Because ReadAll is
ROUTINE ======================== log.(*Logger).Output in /home/isucon/.local/go/src/log/log.go
         0      130ms (flat, cum)  0.23% of Total
         .          .    142:// paths it will be 2.
         .          .    143:func (l *Logger) Output(calldepth int, s string) error {
         .          .    144:	now := time.Now() // get this early.
         .          .    145:	var file string
         .          .    146:	var line int
         .       10ms    147:	l.mu.Lock()
         .       10ms    148:	defer l.mu.Unlock()
         .          .    149:	if l.flag&(Lshortfile|Llongfile) != 0 {
         .          .    150:		// release lock while getting caller info - it's expensive.
         .          .    151:		l.mu.Unlock()
         .          .    152:		var ok bool
         .          .    153:		_, file, line, ok = runtime.Caller(calldepth)
         .          .    154:		if !ok {
         .          .    155:			file = "???"
         .          .    156:			line = 0
         .          .    157:		}
         .          .    158:		l.mu.Lock()
         .          .    159:	}
         .          .    160:	l.buf = l.buf[:0]
         .       10ms    161:	l.formatHeader(&l.buf, now, file, line)
         .          .    162:	l.buf = append(l.buf, s...)
         .          .    163:	if len(s) == 0 || s[len(s)-1] != '\n' {
         .          .    164:		l.buf = append(l.buf, '\n')
         .          .    165:	}
         .       90ms    166:	_, err := l.out.Write(l.buf)
         .       10ms    167:	return err
         .          .    168:}
         .          .    169:
         .          .    170:// Printf calls l.Output to print to the logger.
         .          .    171:// Arguments are handled in the manner of fmt.Printf.
         .          .    172:func (l *Logger) Printf(format string, v ...interface{}) {
ROUTINE ======================== log.(*Logger).formatHeader in /home/isucon/.local/go/src/log/log.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .     85:	// i < 10
         .          .     86:	b[bp] = byte('0' + i)
         .          .     87:	*buf = append(*buf, b[bp:]...)
         .          .     88:}
         .          .     89:
      10ms       10ms     90:func (l *Logger) formatHeader(buf *[]byte, t time.Time, file string, line int) {
         .          .     91:	*buf = append(*buf, l.prefix...)
         .          .     92:	if l.flag&LUTC != 0 {
         .          .     93:		t = t.UTC()
         .          .     94:	}
         .          .     95:	if l.flag&(Ldate|Ltime|Lmicroseconds) != 0 {
ROUTINE ======================== log.Print in /home/isucon/.local/go/src/log/log.go
         0      150ms (flat, cum)  0.27% of Total
         .          .    278:// These functions write to the standard logger.
         .          .    279:
         .          .    280:// Print calls Output to print to the standard logger.
         .          .    281:// Arguments are handled in the manner of fmt.Print.
         .          .    282:func Print(v ...interface{}) {
         .      150ms    283:	std.Output(2, fmt.Sprint(v...))
         .          .    284:}
         .          .    285:
         .          .    286:// Printf calls Output to print to the standard logger.
         .          .    287:// Arguments are handled in the manner of fmt.Printf.
         .          .    288:func Printf(format string, v ...interface{}) {
ROUTINE ======================== main.calculatePasshash in /home/isucon/private_isu/webapp/golang/app.go
         0      220ms (flat, cum)   0.4% of Total
         .          .    138:func calculateSalt(accountName string) string {
         .          .    139:	return digest(accountName)
         .          .    140:}
         .          .    141:
         .          .    142:func calculatePasshash(accountName, password string) string {
         .      220ms    143:	return digest(password + ":" + calculateSalt(accountName))
         .          .    144:}
         .          .    145:
         .          .    146:func getSession(r *http.Request) *sessions.Session {
         .          .    147:	session, _ := store.Get(r, "isuconp-go.session")
         .          .    148:
ROUTINE ======================== main.calculateSalt in /home/isucon/private_isu/webapp/golang/app.go
         0      110ms (flat, cum)   0.2% of Total
         .          .    134:
         .          .    135:	return strings.TrimSuffix(string(out), "\n")
         .          .    136:}
         .          .    137:
         .          .    138:func calculateSalt(accountName string) string {
         .      110ms    139:	return digest(accountName)
         .          .    140:}
         .          .    141:
         .          .    142:func calculatePasshash(accountName, password string) string {
         .          .    143:	return digest(password + ":" + calculateSalt(accountName))
         .          .    144:}
ROUTINE ======================== main.digest in /home/isucon/private_isu/webapp/golang/app.go
         0      220ms (flat, cum)   0.4% of Total
         .          .    124:	return "'" + strings.Replace(arg, "'", "'\\''", -1) + "'"
         .          .    125:}
         .          .    126:
         .          .    127:func digest(src string) string {
         .          .    128:	// opensslのバージョンによっては (stdin)= というのがつくので取る
         .      220ms    129:	out, err := exec.Command("/bin/bash", "-c", `printf "%s" `+escapeshellarg(src)+` | openssl dgst -sha512 | sed 's/^.*= //'`).Output()
         .          .    130:	if err != nil {
         .          .    131:		fmt.Println(err)
         .          .    132:		return ""
         .          .    133:	}
         .          .    134:
ROUTINE ======================== main.getAccountName in /home/isucon/private_isu/webapp/golang/app.go
      10ms      1.50s (flat, cum)  2.70% of Total
         .          .    423:	}{posts, me, getCSRFToken(r), getFlash(w, r, "notice")})
         .          .    424:}
         .          .    425:
         .          .    426:func getAccountName(c web.C, w http.ResponseWriter, r *http.Request) {
         .          .    427:	user := User{}
         .       20ms    428:	uerr := db.Get(&user, "SELECT * FROM `users` WHERE `account_name` = ? AND `del_flg` = 0", c.URLParams["accountName"])
         .          .    429:
         .          .    430:	if uerr != nil {
         .          .    431:		fmt.Println(uerr)
         .          .    432:		return
         .          .    433:	}
         .          .    434:
         .          .    435:	if user.ID == 0 {
         .          .    436:		w.WriteHeader(http.StatusNotFound)
         .          .    437:		return
         .          .    438:	}
         .          .    439:
         .          .    440:	results := []Post{}
         .          .    441:
         .       20ms    442:	rerr := db.Select(&results, "SELECT `id`, `user_id`, `body`, `mime`, `created_at` FROM `posts` WHERE `user_id` = ? ORDER BY `created_at` DESC", user.ID)
         .          .    443:	if rerr != nil {
         .          .    444:		fmt.Println(rerr)
         .          .    445:		return
         .          .    446:	}
         .          .    447:
      10ms      1.04s    448:	posts, merr := makePosts(results, getCSRFToken(r), false)
         .          .    449:	if merr != nil {
         .          .    450:		fmt.Println(merr)
         .          .    451:		return
         .          .    452:	}
         .          .    453:
         .          .    454:	commentCount := 0
         .       20ms    455:	cerr := db.Get(&commentCount, "SELECT COUNT(*) AS count FROM `comments` WHERE `user_id` = ?", user.ID)
         .          .    456:	if cerr != nil {
         .          .    457:		fmt.Println(cerr)
         .          .    458:		return
         .          .    459:	}
         .          .    460:
         .          .    461:	postIDs := []int{}
         .       50ms    462:	perr := db.Select(&postIDs, "SELECT `id` FROM `posts` WHERE `user_id` = ?", user.ID)
         .          .    463:	if perr != nil {
         .          .    464:		fmt.Println(perr)
         .          .    465:		return
         .          .    466:	}
         .          .    467:	postCount := len(postIDs)
         .          .    468:
         .          .    469:	commentedCount := 0
         .          .    470:	if postCount > 0 {
         .          .    471:		s := []string{}
         .          .    472:		for range postIDs {
         .          .    473:			s = append(s, "?")
         .          .    474:		}
         .          .    475:		placeholder := strings.Join(s, ", ")
         .          .    476:
         .          .    477:		// convert []int -> []interface{}
         .          .    478:		args := make([]interface{}, len(postIDs))
         .          .    479:		for i, v := range postIDs {
         .          .    480:			args[i] = v
         .          .    481:		}
         .          .    482:
         .       20ms    483:		ccerr := db.Get(&commentedCount, "SELECT COUNT(*) AS count FROM `comments` WHERE `post_id` IN ("+placeholder+")", args...)
         .          .    484:		if ccerr != nil {
         .          .    485:			fmt.Println(ccerr)
         .          .    486:			return
         .          .    487:		}
         .          .    488:	}
         .          .    489:
         .          .    490:	me := getSessionUser(r)
         .          .    491:
         .          .    492:	fmap := template.FuncMap{
         .          .    493:		"imageURL": imageURL,
         .          .    494:	}
         .          .    495:
         .          .    496:	template.Must(template.New("layout.html").Funcs(fmap).ParseFiles(
         .          .    497:		getTemplPath("layout.html"),
         .          .    498:		getTemplPath("user.html"),
         .          .    499:		getTemplPath("posts.html"),
         .          .    500:		getTemplPath("post.html"),
         .       40ms    501:	)).Execute(w, struct {
         .          .    502:		Posts          []Post
         .          .    503:		User           User
         .          .    504:		PostCount      int
         .          .    505:		CommentCount   int
         .          .    506:		CommentedCount int
         .          .    507:		Me             User
         .      290ms    508:	}{posts, user, postCount, commentCount, commentedCount, me})
         .          .    509:}
         .          .    510:
         .          .    511:func getPosts(w http.ResponseWriter, r *http.Request) {
         .          .    512:	m, parseErr := url.ParseQuery(r.URL.RawQuery)
         .          .    513:	if parseErr != nil {
ROUTINE ======================== main.getAdminBanned in /home/isucon/private_isu/webapp/golang/app.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    737:		http.Redirect(w, r, "/", http.StatusFound)
         .          .    738:		return
         .          .    739:	}
         .          .    740:
         .          .    741:	if me.Authority == 0 {
         .       10ms    742:		w.WriteHeader(http.StatusForbidden)
         .          .    743:		return
         .          .    744:	}
         .          .    745:
         .          .    746:	users := []User{}
         .          .    747:	err := db.Select(&users, "SELECT * FROM `users` WHERE `authority` = 0 AND `del_flg` = 0 ORDER BY `created_at` DESC")
ROUTINE ======================== main.getCSRFToken in /home/isucon/private_isu/webapp/golang/app.go
         0      120ms (flat, cum)  0.22% of Total
         .          .    246:func isLogin(u User) bool {
         .          .    247:	return u.ID != 0
         .          .    248:}
         .          .    249:
         .          .    250:func getCSRFToken(r *http.Request) string {
         .      120ms    251:	session := getSession(r)
         .          .    252:	csrfToken, ok := session.Values["csrf_token"]
         .          .    253:	if !ok {
         .          .    254:		return ""
         .          .    255:	}
         .          .    256:	return csrfToken.(string)
ROUTINE ======================== main.getImage in /home/isucon/private_isu/webapp/golang/app.go
         0      3.80s (flat, cum)  6.83% of Total
         .          .    683:		w.WriteHeader(http.StatusNotFound)
         .          .    684:		return
         .          .    685:	}
         .          .    686:
         .          .    687:	post := Post{}
         .      3.19s    688:	derr := db.Get(&post, "SELECT * FROM `posts` WHERE `id` = ?", pid)
         .          .    689:	if derr != nil {
         .          .    690:		fmt.Println(derr.Error())
         .          .    691:		return
         .          .    692:	}
         .          .    693:
         .          .    694:	ext := c.URLParams["ext"]
         .          .    695:
         .          .    696:	if ext == "jpg" && post.Mime == "image/jpeg" ||
         .          .    697:		ext == "png" && post.Mime == "image/png" ||
         .          .    698:		ext == "gif" && post.Mime == "image/gif" {
         .       20ms    699:		w.Header().Set("Content-Type", post.Mime)
         .      590ms    700:		_, err := w.Write(post.Imgdata)
         .          .    701:		if err != nil {
         .          .    702:			fmt.Println(err.Error())
         .          .    703:		}
         .          .    704:		return
         .          .    705:	}
ROUTINE ======================== main.getIndex in /home/isucon/private_isu/webapp/golang/app.go
         0     36.59s (flat, cum) 65.75% of Total
         .          .    388:
         .          .    389:	http.Redirect(w, r, "/", http.StatusFound)
         .          .    390:}
         .          .    391:
         .          .    392:func getIndex(w http.ResponseWriter, r *http.Request) {
         .      130ms    393:	me := getSessionUser(r)
         .          .    394:
         .          .    395:	results := []Post{}
         .          .    396:
         .     32.37s    397:	err := db.Select(&results, "SELECT `id`, `user_id`, `body`, `mime`, `created_at` FROM `posts` ORDER BY `created_at` DESC")
         .          .    398:	if err != nil {
         .          .    399:		fmt.Println(err)
         .          .    400:		return
         .          .    401:	}
         .          .    402:
         .      2.45s    403:	posts, merr := makePosts(results, getCSRFToken(r), false)
         .          .    404:	if merr != nil {
         .          .    405:		fmt.Println(merr)
         .          .    406:		return
         .          .    407:	}
         .          .    408:
         .          .    409:	fmap := template.FuncMap{
         .          .    410:		"imageURL": imageURL,
         .          .    411:	}
         .          .    412:
         .       10ms    413:	template.Must(template.New("layout.html").Funcs(fmap).ParseFiles(
         .       10ms    414:		getTemplPath("layout.html"),
         .          .    415:		getTemplPath("index.html"),
         .          .    416:		getTemplPath("posts.html"),
         .          .    417:		getTemplPath("post.html"),
         .      210ms    418:	)).Execute(w, struct {
         .          .    419:		Posts     []Post
         .          .    420:		Me        User
         .          .    421:		CSRFToken string
         .          .    422:		Flash     string
         .      1.41s    423:	}{posts, me, getCSRFToken(r), getFlash(w, r, "notice")})
         .          .    424:}
         .          .    425:
         .          .    426:func getAccountName(c web.C, w http.ResponseWriter, r *http.Request) {
         .          .    427:	user := User{}
         .          .    428:	uerr := db.Get(&user, "SELECT * FROM `users` WHERE `account_name` = ? AND `del_flg` = 0", c.URLParams["accountName"])
ROUTINE ======================== main.getLogin in /home/isucon/private_isu/webapp/golang/app.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    281:		return
         .          .    282:	}
         .          .    283:
         .          .    284:	template.Must(template.ParseFiles(
         .          .    285:		getTemplPath("layout.html"),
         .       20ms    286:		getTemplPath("login.html")),
         .          .    287:	).Execute(w, struct {
         .          .    288:		Me    User
         .          .    289:		Flash string
         .       10ms    290:	}{me, getFlash(w, r, "notice")})
         .          .    291:}
         .          .    292:
         .          .    293:func postLogin(w http.ResponseWriter, r *http.Request) {
         .          .    294:	if isLogin(getSessionUser(r)) {
         .          .    295:		http.Redirect(w, r, "/", http.StatusFound)
ROUTINE ======================== main.getLogout in /home/isucon/private_isu/webapp/golang/app.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    379:
         .          .    380:	http.Redirect(w, r, "/", http.StatusFound)
         .          .    381:}
         .          .    382:
         .          .    383:func getLogout(w http.ResponseWriter, r *http.Request) {
         .       10ms    384:	session := getSession(r)
         .          .    385:	delete(session.Values, "user_id")
         .          .    386:	session.Options = &sessions.Options{MaxAge: -1}
         .       10ms    387:	session.Save(r, w)
         .          .    388:
         .          .    389:	http.Redirect(w, r, "/", http.StatusFound)
         .          .    390:}
         .          .    391:
         .          .    392:func getIndex(w http.ResponseWriter, r *http.Request) {
ROUTINE ======================== main.getPosts in /home/isucon/private_isu/webapp/golang/app.go
         0      2.76s (flat, cum)  4.96% of Total
         .          .    525:		fmt.Println(terr)
         .          .    526:		return
         .          .    527:	}
         .          .    528:
         .          .    529:	results := []Post{}
         .      2.17s    530:	rerr := db.Select(&results, "SELECT `id`, `user_id`, `body`, `mime`, `created_at` FROM `posts` WHERE `created_at` <= ? ORDER BY `created_at` DESC", t.Format(ISO8601_FORMAT))
         .          .    531:	if rerr != nil {
         .          .    532:		fmt.Println(rerr)
         .          .    533:		return
         .          .    534:	}
         .          .    535:
         .      430ms    536:	posts, merr := makePosts(results, getCSRFToken(r), false)
         .          .    537:	if merr != nil {
         .          .    538:		fmt.Println(merr)
         .          .    539:		return
         .          .    540:	}
         .          .    541:
         .          .    542:	if len(posts) == 0 {
         .          .    543:		w.WriteHeader(http.StatusNotFound)
         .          .    544:		return
         .          .    545:	}
         .          .    546:
         .          .    547:	fmap := template.FuncMap{
         .          .    548:		"imageURL": imageURL,
         .          .    549:	}
         .          .    550:
         .          .    551:	template.Must(template.New("posts.html").Funcs(fmap).ParseFiles(
         .          .    552:		getTemplPath("posts.html"),
         .          .    553:		getTemplPath("post.html"),
         .      160ms    554:	)).Execute(w, posts)
         .          .    555:}
         .          .    556:
         .          .    557:func getPostsID(c web.C, w http.ResponseWriter, r *http.Request) {
         .          .    558:	pid, err := strconv.Atoi(c.URLParams["id"])
         .          .    559:	if err != nil {
ROUTINE ======================== main.getPostsID in /home/isucon/private_isu/webapp/golang/app.go
         0      540ms (flat, cum)  0.97% of Total
         .          .    560:		w.WriteHeader(http.StatusNotFound)
         .          .    561:		return
         .          .    562:	}
         .          .    563:
         .          .    564:	results := []Post{}
         .       70ms    565:	rerr := db.Select(&results, "SELECT * FROM `posts` WHERE `id` = ?", pid)
         .          .    566:	if rerr != nil {
         .          .    567:		fmt.Println(rerr)
         .          .    568:		return
         .          .    569:	}
         .          .    570:
         .      190ms    571:	posts, merr := makePosts(results, getCSRFToken(r), true)
         .          .    572:	if merr != nil {
         .          .    573:		fmt.Println(merr)
         .          .    574:		return
         .          .    575:	}
         .          .    576:
         .          .    577:	if len(posts) == 0 {
         .          .    578:		w.WriteHeader(http.StatusNotFound)
         .          .    579:		return
         .          .    580:	}
         .          .    581:
         .          .    582:	p := posts[0]
         .          .    583:
         .       20ms    584:	me := getSessionUser(r)
         .          .    585:
         .          .    586:	fmap := template.FuncMap{
         .          .    587:		"imageURL": imageURL,
         .          .    588:	}
         .          .    589:
         .          .    590:	template.Must(template.New("layout.html").Funcs(fmap).ParseFiles(
         .          .    591:		getTemplPath("layout.html"),
         .          .    592:		getTemplPath("post_id.html"),
         .          .    593:		getTemplPath("post.html"),
         .       80ms    594:	)).Execute(w, struct {
         .          .    595:		Post Post
         .          .    596:		Me   User
         .      180ms    597:	}{p, me})
         .          .    598:}
         .          .    599:
         .          .    600:func postIndex(w http.ResponseWriter, r *http.Request) {
         .          .    601:	me := getSessionUser(r)
         .          .    602:	if !isLogin(me) {
ROUTINE ======================== main.getSession in /home/isucon/private_isu/webapp/golang/app.go
         0      230ms (flat, cum)  0.41% of Total
         .          .    142:func calculatePasshash(accountName, password string) string {
         .          .    143:	return digest(password + ":" + calculateSalt(accountName))
         .          .    144:}
         .          .    145:
         .          .    146:func getSession(r *http.Request) *sessions.Session {
         .      230ms    147:	session, _ := store.Get(r, "isuconp-go.session")
         .          .    148:
         .          .    149:	return session
         .          .    150:}
         .          .    151:
         .          .    152:func getSessionUser(r *http.Request) User {
ROUTINE ======================== main.getSessionUser in /home/isucon/private_isu/webapp/golang/app.go
         0      250ms (flat, cum)  0.45% of Total
         .          .    148:
         .          .    149:	return session
         .          .    150:}
         .          .    151:
         .          .    152:func getSessionUser(r *http.Request) User {
         .      100ms    153:	session := getSession(r)
         .          .    154:	uid, ok := session.Values["user_id"]
         .          .    155:	if !ok || uid == nil {
         .          .    156:		return User{}
         .          .    157:	}
         .          .    158:
         .          .    159:	u := User{}
         .          .    160:
         .      150ms    161:	err := db.Get(&u, "SELECT * FROM `users` WHERE `id` = ?", uid)
         .          .    162:	if err != nil {
         .          .    163:		return User{}
         .          .    164:	}
         .          .    165:
         .          .    166:	return u
ROUTINE ======================== main.getTemplPath in /home/isucon/private_isu/webapp/golang/app.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    263:	}
         .          .    264:	return hex.EncodeToString(k)
         .          .    265:}
         .          .    266:
         .          .    267:func getTemplPath(filename string) string {
         .       10ms    268:	return path.Join("templates", filename)
         .          .    269:}
         .          .    270:
         .          .    271:func getInitialize(w http.ResponseWriter, r *http.Request) {
         .          .    272:	dbInitialize()
         .          .    273:	w.WriteHeader(http.StatusOK)
ROUTINE ======================== main.imageURL in /home/isucon/private_isu/webapp/golang/app.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    238:		ext = ".png"
         .          .    239:	} else if p.Mime == "image/gif" {
         .          .    240:		ext = ".gif"
         .          .    241:	}
         .          .    242:
         .       10ms    243:	return "/image/" + strconv.Itoa(p.ID) + ext
         .          .    244:}
         .          .    245:
         .          .    246:func isLogin(u User) bool {
         .          .    247:	return u.ID != 0
         .          .    248:}
ROUTINE ======================== main.main in /home/isucon/private_isu/webapp/golang/app.go
         0      380ms (flat, cum)  0.68% of Total
         .          .    843:	goji.Get("/image/:id.:ext", getImage)
         .          .    844:	goji.Post("/comment", postComment)
         .          .    845:	goji.Get("/admin/banned", getAdminBanned)
         .          .    846:	goji.Post("/admin/banned", postAdminBanned)
         .          .    847:	goji.Get("/*", http.FileServer(http.Dir("../public")))
         .      380ms    848:	goji.Serve()
         .          .    849:}
ROUTINE ======================== main.makePosts in /home/isucon/private_isu/webapp/golang/app.go
         0      3.98s (flat, cum)  7.15% of Total
         .          .    181:
         .          .    182:func makePosts(results []Post, CSRFToken string, allComments bool) ([]Post, error) {
         .          .    183:	var posts []Post
         .          .    184:
         .          .    185:	for _, p := range results {
         .      820ms    186:		err := db.Get(&p.CommentCount, "SELECT COUNT(*) AS `count` FROM `comments` WHERE `post_id` = ?", p.ID)
         .          .    187:		if err != nil {
         .          .    188:			return nil, err
         .          .    189:		}
         .          .    190:
         .          .    191:		query := "SELECT * FROM `comments` WHERE `post_id` = ? ORDER BY `created_at` DESC"
         .          .    192:		if !allComments {
         .       30ms    193:			query += " LIMIT 3"
         .          .    194:		}
         .          .    195:		var comments []Comment
         .      900ms    196:		cerr := db.Select(&comments, query, p.ID)
         .          .    197:		if cerr != nil {
         .          .    198:			return nil, cerr
         .          .    199:		}
         .          .    200:
         .          .    201:		for i := 0; i < len(comments); i++ {
         .      1.17s    202:			uerr := db.Get(&comments[i].User, "SELECT * FROM `users` WHERE `id` = ?", comments[i].UserID)
         .          .    203:			if uerr != nil {
         .          .    204:				return nil, uerr
         .          .    205:			}
         .          .    206:		}
         .          .    207:
         .          .    208:		// reverse
         .          .    209:		for i, j := 0, len(comments)-1; i < j; i, j = i+1, j-1 {
         .          .    210:			comments[i], comments[j] = comments[j], comments[i]
         .          .    211:		}
         .          .    212:
         .          .    213:		p.Comments = comments
         .          .    214:
         .         1s    215:		perr := db.Get(&p.User, "SELECT * FROM `users` WHERE `id` = ?", p.UserID)
         .          .    216:		if perr != nil {
         .          .    217:			return nil, perr
         .          .    218:		}
         .          .    219:
         .          .    220:		p.CSRFToken = CSRFToken
         .          .    221:
         .          .    222:		if p.User.DelFlg == 0 {
         .       60ms    223:			posts = append(posts, p)
         .          .    224:		}
         .          .    225:		if len(posts) >= postsPerPage {
         .          .    226:			break
         .          .    227:		}
         .          .    228:	}
ROUTINE ======================== main.postComment in /home/isucon/private_isu/webapp/golang/app.go
         0       50ms (flat, cum)  0.09% of Total
         .          .    706:
         .          .    707:	w.WriteHeader(http.StatusNotFound)
         .          .    708:}
         .          .    709:
         .          .    710:func postComment(w http.ResponseWriter, r *http.Request) {
         .       20ms    711:	me := getSessionUser(r)
         .          .    712:	if !isLogin(me) {
         .          .    713:		http.Redirect(w, r, "/login", http.StatusFound)
         .          .    714:		return
         .          .    715:	}
         .          .    716:
         .          .    717:	if r.FormValue("csrf_token") != getCSRFToken(r) {
         .          .    718:		w.WriteHeader(StatusUnprocessableEntity)
         .          .    719:		return
         .          .    720:	}
         .          .    721:
         .          .    722:	postID, ierr := strconv.Atoi(r.FormValue("post_id"))
         .          .    723:	if ierr != nil {
         .          .    724:		fmt.Println("post_idは整数のみです")
         .          .    725:		return
         .          .    726:	}
         .          .    727:
         .          .    728:	query := "INSERT INTO `comments` (`post_id`, `user_id`, `comment`) VALUES (?,?,?)"
         .       30ms    729:	db.Exec(query, postID, me.ID, r.FormValue("comment"))
         .          .    730:
         .          .    731:	http.Redirect(w, r, fmt.Sprintf("/posts/%d", postID), http.StatusFound)
         .          .    732:}
         .          .    733:
         .          .    734:func getAdminBanned(w http.ResponseWriter, r *http.Request) {
ROUTINE ======================== main.postIndex in /home/isucon/private_isu/webapp/golang/app.go
         0      240ms (flat, cum)  0.43% of Total
         .          .    596:		Me   User
         .          .    597:	}{p, me})
         .          .    598:}
         .          .    599:
         .          .    600:func postIndex(w http.ResponseWriter, r *http.Request) {
         .       80ms    601:	me := getSessionUser(r)
         .          .    602:	if !isLogin(me) {
         .          .    603:		http.Redirect(w, r, "/login", http.StatusFound)
         .          .    604:		return
         .          .    605:	}
         .          .    606:
         .       80ms    607:	if r.FormValue("csrf_token") != getCSRFToken(r) {
         .          .    608:		w.WriteHeader(StatusUnprocessableEntity)
         .          .    609:		return
         .          .    610:	}
         .          .    611:
         .          .    612:	file, header, ferr := r.FormFile("file")
         .          .    613:	if ferr != nil {
         .          .    614:		session := getSession(r)
         .          .    615:		session.Values["notice"] = "画像が必須です"
         .          .    616:		session.Save(r, w)
         .          .    617:
         .          .    618:		http.Redirect(w, r, "/", http.StatusFound)
         .          .    619:		return
         .          .    620:	}
         .          .    621:
         .          .    622:	mime := ""
         .          .    623:	if file != nil {
         .          .    624:		// 投稿のContent-Typeからファイルのタイプを決定する
         .          .    625:		contentType := header.Header["Content-Type"][0]
         .          .    626:		if strings.Contains(contentType, "jpeg") {
         .          .    627:			mime = "image/jpeg"
         .          .    628:		} else if strings.Contains(contentType, "png") {
         .          .    629:			mime = "image/png"
         .          .    630:		} else if strings.Contains(contentType, "gif") {
         .          .    631:			mime = "image/gif"
         .          .    632:		} else {
         .          .    633:			session := getSession(r)
         .          .    634:			session.Values["notice"] = "投稿できる画像形式はjpgとpngとgifだけです"
         .          .    635:			session.Save(r, w)
         .          .    636:
         .          .    637:			http.Redirect(w, r, "/", http.StatusFound)
         .          .    638:			return
         .          .    639:		}
         .          .    640:	}
         .          .    641:
         .       30ms    642:	filedata, rerr := ioutil.ReadAll(file)
         .          .    643:	if rerr != nil {
         .          .    644:		fmt.Println(rerr.Error())
         .          .    645:	}
         .          .    646:
         .          .    647:	if len(filedata) > UploadLimit {
         .          .    648:		session := getSession(r)
         .          .    649:		session.Values["notice"] = "ファイルサイズが大きすぎます"
         .          .    650:		session.Save(r, w)
         .          .    651:
         .          .    652:		http.Redirect(w, r, "/", http.StatusFound)
         .          .    653:		return
         .          .    654:	}
         .          .    655:
         .          .    656:	query := "INSERT INTO `posts` (`user_id`, `mime`, `imgdata`, `body`) VALUES (?,?,?,?)"
         .          .    657:	result, eerr := db.Exec(
         .          .    658:		query,
         .          .    659:		me.ID,
         .          .    660:		mime,
         .          .    661:		filedata,
         .          .    662:		r.FormValue("body"),
         .       50ms    663:	)
         .          .    664:	if eerr != nil {
         .          .    665:		fmt.Println(eerr.Error())
         .          .    666:		return
         .          .    667:	}
         .          .    668:
ROUTINE ======================== main.postLogin in /home/isucon/private_isu/webapp/golang/app.go
         0      360ms (flat, cum)  0.65% of Total
         .          .    294:	if isLogin(getSessionUser(r)) {
         .          .    295:		http.Redirect(w, r, "/", http.StatusFound)
         .          .    296:		return
         .          .    297:	}
         .          .    298:
         .      260ms    299:	u := tryLogin(r.FormValue("account_name"), r.FormValue("password"))
         .          .    300:
         .          .    301:	if u != nil {
         .          .    302:		session := getSession(r)
         .          .    303:		session.Values["user_id"] = u.ID
         .          .    304:		session.Values["csrf_token"] = secureRandomStr(16)
         .       60ms    305:		session.Save(r, w)
         .          .    306:
         .       10ms    307:		http.Redirect(w, r, "/", http.StatusFound)
         .          .    308:	} else {
         .          .    309:		session := getSession(r)
         .       10ms    310:		session.Values["notice"] = "アカウント名かパスワードが間違っています"
         .       20ms    311:		session.Save(r, w)
         .          .    312:
         .          .    313:		http.Redirect(w, r, "/login", http.StatusFound)
         .          .    314:	}
         .          .    315:}
         .          .    316:
ROUTINE ======================== main.postRegister in /home/isucon/private_isu/webapp/golang/app.go
         0       80ms (flat, cum)  0.14% of Total
         .          .    359:		http.Redirect(w, r, "/register", http.StatusFound)
         .          .    360:		return
         .          .    361:	}
         .          .    362:
         .          .    363:	query := "INSERT INTO `users` (`account_name`, `passhash`) VALUES (?,?)"
         .       70ms    364:	result, eerr := db.Exec(query, accountName, calculatePasshash(accountName, password))
         .          .    365:	if eerr != nil {
         .          .    366:		fmt.Println(eerr.Error())
         .          .    367:		return
         .          .    368:	}
         .          .    369:
         .          .    370:	session := getSession(r)
         .          .    371:	uid, lerr := result.LastInsertId()
         .          .    372:	if lerr != nil {
         .          .    373:		fmt.Println(lerr.Error())
         .          .    374:		return
         .          .    375:	}
         .          .    376:	session.Values["user_id"] = uid
         .          .    377:	session.Values["csrf_token"] = secureRandomStr(16)
         .       10ms    378:	session.Save(r, w)
         .          .    379:
         .          .    380:	http.Redirect(w, r, "/", http.StatusFound)
         .          .    381:}
         .          .    382:
         .          .    383:func getLogout(w http.ResponseWriter, r *http.Request) {
ROUTINE ======================== main.tryLogin in /home/isucon/private_isu/webapp/golang/app.go
         0      250ms (flat, cum)  0.45% of Total
         .          .     92:	}
         .          .     93:}
         .          .     94:
         .          .     95:func tryLogin(accountName, password string) *User {
         .          .     96:	u := User{}
         .       70ms     97:	err := db.Get(&u, "SELECT * FROM users WHERE account_name = ? AND del_flg = 0", accountName)
         .          .     98:	if err != nil {
         .          .     99:		return nil
         .          .    100:	}
         .          .    101:
         .      180ms    102:	if &u != nil && calculatePasshash(u.AccountName, password) == u.Passhash {
         .          .    103:		return &u
         .          .    104:	} else if &u == nil {
         .          .    105:		return nil
         .          .    106:	} else {
         .          .    107:		return nil
ROUTINE ======================== mime.ParseMediaType in /home/isucon/.local/go/src/mime/mediatype.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    106:	if i == -1 {
         .          .    107:		i = len(v)
         .          .    108:	}
         .          .    109:	mediatype = strings.TrimSpace(strings.ToLower(v[0:i]))
         .          .    110:
         .       10ms    111:	err = checkMediaTypeDisposition(mediatype)
         .          .    112:	if err != nil {
         .          .    113:		return "", nil, err
         .          .    114:	}
         .          .    115:
         .          .    116:	params = make(map[string]string)
ROUTINE ======================== mime.checkMediaTypeDisposition in /home/isucon/.local/go/src/mime/mediatype.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     72:	}
         .          .     73:	return b.String()
         .          .     74:}
         .          .     75:
         .          .     76:func checkMediaTypeDisposition(s string) error {
         .       10ms     77:	typ, rest := consumeToken(s)
         .          .     78:	if typ == "" {
         .          .     79:		return errors.New("mime: no media type")
         .          .     80:	}
         .          .     81:	if rest == "" {
         .          .     82:		return nil
ROUTINE ======================== mime.consumeToken in /home/isucon/.local/go/src/mime/mediatype.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    222:// consumeToken consumes a token from the beginning of provided
         .          .    223:// string, per RFC 2045 section 5.1 (referenced from 2183), and return
         .          .    224:// the token consumed and the rest of the string.  Returns ("", v) on
         .          .    225:// failure to consume at least one character.
         .          .    226:func consumeToken(v string) (token, rest string) {
         .       10ms    227:	notPos := strings.IndexFunc(v, isNotTokenChar)
         .          .    228:	if notPos == -1 {
         .          .    229:		return v, ""
         .          .    230:	}
         .          .    231:	if notPos == 0 {
         .          .    232:		return "", v
ROUTINE ======================== mime.isNotTokenChar in /home/isucon/.local/go/src/mime/mediatype.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    214:	encv, _ := percentHexUnescape(sv[2])
         .          .    215:	return encv
         .          .    216:}
         .          .    217:
         .          .    218:func isNotTokenChar(r rune) bool {
         .       10ms    219:	return !isTokenChar(r)
         .          .    220:}
         .          .    221:
         .          .    222:// consumeToken consumes a token from the beginning of provided
         .          .    223:// string, per RFC 2045 section 5.1 (referenced from 2183), and return
         .          .    224:// the token consumed and the rest of the string.  Returns ("", v) on
ROUTINE ======================== mime.isTSpecial in /home/isucon/.local/go/src/mime/grammar.go
         0       10ms (flat, cum) 0.018% of Total
         .          .      9:)
         .          .     10:
         .          .     11:// isTSpecial reports whether rune is in 'tspecials' as defined by RFC
         .          .     12:// 1521 and RFC 2045.
         .          .     13:func isTSpecial(r rune) bool {
         .       10ms     14:	return strings.IndexRune(`()<>@,;:\"/[]?=`, r) != -1
         .          .     15:}
         .          .     16:
         .          .     17:// isTokenChar reports whether rune is in 'token' as defined by RFC
         .          .     18:// 1521 and RFC 2045.
         .          .     19:func isTokenChar(r rune) bool {
ROUTINE ======================== mime.isTokenChar in /home/isucon/.local/go/src/mime/grammar.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     17:// isTokenChar reports whether rune is in 'token' as defined by RFC
         .          .     18:// 1521 and RFC 2045.
         .          .     19:func isTokenChar(r rune) bool {
         .          .     20:	// token := 1*<any (US-ASCII) CHAR except SPACE, CTLs,
         .          .     21:	//             or tspecials>
         .       10ms     22:	return r > 0x20 && r < 0x7f && !isTSpecial(r)
         .          .     23:}
         .          .     24:
         .          .     25:// isToken reports whether s is a 'token' as defined by RFC 1521
         .          .     26:// and RFC 2045.
         .          .     27:func isToken(s string) bool {
ROUTINE ======================== mime/multipart.(*Part).Read in /home/isucon/.local/go/src/mime/multipart/multipart.go
         0       40ms (flat, cum) 0.072% of Total
         .          .    150:}
         .          .    151:
         .          .    152:// Read reads the body of a part, after its headers and before the
         .          .    153:// next part (if any) begins.
         .          .    154:func (p *Part) Read(d []byte) (n int, err error) {
         .       40ms    155:	return p.r.Read(d)
         .          .    156:}
         .          .    157:
         .          .    158:// partReader implements io.Reader by reading raw bytes directly from the
         .          .    159:// wrapped *Part, without doing any Transfer-Encoding decoding.
         .          .    160:type partReader struct {
ROUTINE ======================== mime/multipart.(*Reader).ReadForm in /home/isucon/.local/go/src/mime/multipart/formdata.go
         0       80ms (flat, cum)  0.14% of Total
         .          .     54:			}
         .          .     55:			maxValueBytes -= n
         .          .     56:			if maxValueBytes == 0 {
         .          .     57:				return nil, errors.New("multipart: message too large")
         .          .     58:			}
         .       10ms     59:			form.Value[name] = append(form.Value[name], b.String())
         .          .     60:			continue
         .          .     61:		}
         .          .     62:
         .          .     63:		// file, store in memory or on disk
         .          .     64:		fh := &FileHeader{
         .          .     65:			Filename: filename,
         .          .     66:			Header:   p.Header,
         .          .     67:		}
         .       70ms     68:		n, err := io.CopyN(&b, p, maxMemory+1)
         .          .     69:		if err != nil && err != io.EOF {
         .          .     70:			return nil, err
         .          .     71:		}
         .          .     72:		if n > maxMemory {
         .          .     73:			// too big, write to disk and flush buffer
ROUTINE ======================== mime/multipart.(*Reader).peekBufferSeparatorIndex in /home/isucon/.local/go/src/mime/multipart/multipart.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    367:// peekBufferSeparatorIndex returns the index of mr.nlDashBoundary in
         .          .    368:// peek and whether it is a real boundary (and not a prefix of an
         .          .    369:// unrelated separator). To be the end, the peek buffer must contain a
         .          .    370:// newline after the boundary or contain the ending boundary (--separator--).
         .          .    371:func (mr *Reader) peekBufferSeparatorIndex(peek []byte) (idx int, isEnd bool) {
         .       10ms    372:	idx = bytes.Index(peek, mr.nlDashBoundary)
         .          .    373:	if idx == -1 {
         .          .    374:		return
         .          .    375:	}
         .          .    376:
         .          .    377:	peek = peek[idx+len(mr.nlDashBoundary):]
ROUTINE ======================== mime/multipart.(*stickyErrorReader).Read in /home/isucon/.local/go/src/mime/multipart/multipart.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    116:
         .          .    117:func (r *stickyErrorReader) Read(p []byte) (n int, _ error) {
         .          .    118:	if r.err != nil {
         .          .    119:		return 0, r.err
         .          .    120:	}
         .       20ms    121:	n, r.err = r.r.Read(p)
         .          .    122:	return n, r.err
         .          .    123:}
         .          .    124:
         .          .    125:func newPart(mr *Reader) (*Part, error) {
         .          .    126:	bp := &Part{
ROUTINE ======================== mime/multipart.partReader.Read in /home/isucon/.local/go/src/mime/multipart/multipart.go
         0       40ms (flat, cum) 0.072% of Total
         .          .    169:	if p.buffer.Len() >= len(d) {
         .          .    170:		// Internal buffer of unconsumed data is large enough for
         .          .    171:		// the read request.  No need to parse more at the moment.
         .          .    172:		return p.buffer.Read(d)
         .          .    173:	}
         .       20ms    174:	peek, err := p.mr.bufReader.Peek(peekBufferSize) // TODO(bradfitz): add buffer size accessor
         .          .    175:
         .          .    176:	// Look for an immediate empty part without a leading \r\n
         .          .    177:	// before the boundary separator.  Some MIME code makes empty
         .          .    178:	// parts like this. Most browsers, however, write the \r\n
         .          .    179:	// before the subsequent boundary even for empty parts and
         .          .    180:	// won't hit this path.
         .          .    181:	if p.bytesRead == 0 && p.mr.peekBufferIsEmptyPart(peek) {
         .          .    182:		return 0, io.EOF
         .          .    183:	}
         .          .    184:	unexpectedEOF := err == io.EOF
         .          .    185:	if err != nil && !unexpectedEOF {
         .          .    186:		return 0, fmt.Errorf("multipart: Part Read: %v", err)
         .          .    187:	}
         .          .    188:	if peek == nil {
         .          .    189:		panic("nil peek buf")
         .          .    190:	}
         .          .    191:	// Search the peek buffer for "\r\n--boundary". If found,
         .          .    192:	// consume everything up to the boundary. If not, consume only
         .          .    193:	// as much of the peek buffer as cannot hold the boundary
         .          .    194:	// string.
         .          .    195:	nCopy := 0
         .          .    196:	foundBoundary := false
         .       10ms    197:	if idx, isEnd := p.mr.peekBufferSeparatorIndex(peek); idx != -1 {
         .          .    198:		nCopy = idx
         .          .    199:		foundBoundary = isEnd
         .          .    200:		if !isEnd && nCopy == 0 {
         .          .    201:			nCopy = 1 // make some progress.
         .          .    202:		}
         .          .    203:	} else if safeCount := len(peek) - len(p.mr.nlDashBoundary); safeCount > 0 {
         .          .    204:		nCopy = safeCount
         .          .    205:	} else if unexpectedEOF {
         .          .    206:		// If we've run out of peek buffer and the boundary
         .          .    207:		// wasn't found (and can't possibly fit), we must have
         .          .    208:		// hit the end of the file unexpectedly.
         .          .    209:		return 0, io.ErrUnexpectedEOF
         .          .    210:	}
         .          .    211:	if nCopy > 0 {
         .       10ms    212:		if _, err := io.CopyN(p.buffer, p.mr.bufReader, int64(nCopy)); err != nil {
         .          .    213:			return 0, err
         .          .    214:		}
         .          .    215:	}
         .          .    216:	n, err = p.buffer.Read(d)
         .          .    217:	if err == io.EOF && !foundBoundary {
ROUTINE ======================== net.(*Dialer).Dial in /home/isucon/.local/go/src/net/dial.go
         0      620ms (flat, cum)  1.11% of Total
         .          .    211://
         .          .    212:// See func Dial for a description of the network and address
         .          .    213:// parameters.
         .          .    214:func (d *Dialer) Dial(network, address string) (Conn, error) {
         .          .    215:	finalDeadline := d.deadline(time.Now())
         .      240ms    216:	addrs, err := resolveAddrList("dial", network, address, finalDeadline)
         .          .    217:	if err != nil {
         .          .    218:		return nil, &OpError{Op: "dial", Net: network, Source: nil, Addr: nil, Err: err}
         .          .    219:	}
         .          .    220:
         .          .    221:	ctx := &dialContext{
         .          .    222:		Dialer:        *d,
         .          .    223:		network:       network,
         .          .    224:		address:       address,
         .          .    225:		finalDeadline: finalDeadline,
         .          .    226:	}
         .          .    227:
         .          .    228:	var primaries, fallbacks addrList
         .          .    229:	if d.DualStack && network == "tcp" {
         .          .    230:		primaries, fallbacks = addrs.partition(isIPv4)
         .          .    231:	} else {
         .          .    232:		primaries = addrs
         .          .    233:	}
         .          .    234:
         .          .    235:	var c Conn
         .          .    236:	if len(fallbacks) == 0 {
         .          .    237:		// dialParallel can accept an empty fallbacks list,
         .          .    238:		// but this shortcut avoids the goroutine/channel overhead.
         .      380ms    239:		c, err = dialSerial(ctx, primaries, nil)
         .          .    240:	} else {
         .          .    241:		c, err = dialParallel(ctx, primaries, fallbacks)
         .          .    242:	}
         .          .    243:
         .          .    244:	if d.KeepAlive > 0 && err == nil {
ROUTINE ======================== net.(*TCPAddr).String in /home/isucon/.local/go/src/net/tcpsock.go
         0      260ms (flat, cum)  0.47% of Total
         .          .     16:
         .          .     17:func (a *TCPAddr) String() string {
         .          .     18:	if a == nil {
         .          .     19:		return "<nil>"
         .          .     20:	}
         .      260ms     21:	ip := ipEmptyString(a.IP)
         .          .     22:	if a.Zone != "" {
         .          .     23:		return JoinHostPort(ip+"%"+a.Zone, itoa(a.Port))
         .          .     24:	}
         .          .     25:	return JoinHostPort(ip, itoa(a.Port))
         .          .     26:}
ROUTINE ======================== net.(*TCPConn).Close in <autogenerated>
      20ms       20ms (flat, cum) 0.036% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== net.(*TCPConn).ReadFrom in /home/isucon/.local/go/src/net/tcpsock_posix.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     52:	return c
         .          .     53:}
         .          .     54:
         .          .     55:// ReadFrom implements the io.ReaderFrom ReadFrom method.
         .          .     56:func (c *TCPConn) ReadFrom(r io.Reader) (int64, error) {
         .       20ms     57:	if n, err, handled := sendFile(c.fd, r); handled {
         .          .     58:		if err != nil && err != io.EOF {
         .          .     59:			err = &OpError{Op: "read", Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}
         .          .     60:		}
         .          .     61:		return n, err
         .          .     62:	}
ROUTINE ======================== net.(*TCPConn).SetKeepAlive in /home/isucon/.local/go/src/net/tcpsock_posix.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    119:// keepalive messages on the connection.
         .          .    120:func (c *TCPConn) SetKeepAlive(keepalive bool) error {
         .          .    121:	if !c.ok() {
         .          .    122:		return syscall.EINVAL
         .          .    123:	}
         .       20ms    124:	if err := setKeepAlive(c.fd, keepalive); err != nil {
         .          .    125:		return &OpError{Op: "set", Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}
         .          .    126:	}
         .          .    127:	return nil
         .          .    128:}
         .          .    129:
ROUTINE ======================== net.(*TCPConn).SetKeepAlivePeriod in /home/isucon/.local/go/src/net/tcpsock_posix.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    130:// SetKeepAlivePeriod sets period between keep alives.
         .          .    131:func (c *TCPConn) SetKeepAlivePeriod(d time.Duration) error {
         .          .    132:	if !c.ok() {
         .          .    133:		return syscall.EINVAL
         .          .    134:	}
         .       10ms    135:	if err := setKeepAlivePeriod(c.fd, d); err != nil {
         .          .    136:		return &OpError{Op: "set", Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}
         .          .    137:	}
         .          .    138:	return nil
         .          .    139:}
         .          .    140:
ROUTINE ======================== net.(*TCPConn).Write in <autogenerated>
      20ms       20ms (flat, cum) 0.036% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== net.(*TCPListener).AcceptTCP in /home/isucon/.local/go/src/net/tcpsock_posix.go
         0      340ms (flat, cum)  0.61% of Total
         .          .    249:// connection.
         .          .    250:func (l *TCPListener) AcceptTCP() (*TCPConn, error) {
         .          .    251:	if l == nil || l.fd == nil {
         .          .    252:		return nil, syscall.EINVAL
         .          .    253:	}
         .      330ms    254:	fd, err := l.fd.accept()
         .          .    255:	if err != nil {
         .          .    256:		return nil, &OpError{Op: "accept", Net: l.fd.net, Source: nil, Addr: l.fd.laddr, Err: err}
         .          .    257:	}
         .       10ms    258:	return newTCPConn(fd), nil
         .          .    259:}
         .          .    260:
         .          .    261:// Accept implements the Accept method in the Listener interface; it
         .          .    262:// waits for the next call and returns a generic Conn.
         .          .    263:func (l *TCPListener) Accept() (Conn, error) {
ROUTINE ======================== net.(*UDPAddr).sockaddr in /home/isucon/.local/go/src/net/udpsock_posix.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     33:
         .          .     34:func (a *UDPAddr) sockaddr(family int) (syscall.Sockaddr, error) {
         .          .     35:	if a == nil {
         .          .     36:		return nil, nil
         .          .     37:	}
         .       10ms     38:	return ipToSockaddr(family, a.IP, a.Port, a.Zone)
         .          .     39:}
         .          .     40:
         .          .     41:// UDPConn is the implementation of the Conn and PacketConn interfaces
         .          .     42:// for UDP network connections.
         .          .     43:type UDPConn struct {
ROUTINE ======================== net.(*conf).hostLookupOrder in /home/isucon/.local/go/src/net/conf.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .    117:	return c.hostLookupOrder("") == hostLookupCgo
         .          .    118:}
         .          .    119:
         .          .    120:// hostLookupOrder determines which strategy to use to resolve hostname.
         .          .    121:func (c *conf) hostLookupOrder(hostname string) (ret hostLookupOrder) {
      10ms       10ms    122:	if c.dnsDebugLevel > 1 {
         .          .    123:		defer func() {
         .          .    124:			print("go package net: hostLookupOrder(", hostname, ") = ", ret.String(), "\n")
         .          .    125:		}()
         .          .    126:	}
         .          .    127:	if c.netGo {
         .          .    128:		return hostLookupFilesDNS
         .          .    129:	}
         .          .    130:	if c.forceCgoLookupHost || c.resolv.unknownOpt || c.goos == "android" {
         .          .    131:		return hostLookupCgo
         .          .    132:	}
         .          .    133:	if byteIndex(hostname, '\\') != -1 || byteIndex(hostname, '%') != -1 {
         .          .    134:		// Don't deal with special form hostnames with backslashes
         .          .    135:		// or '%'.
         .          .    136:		return hostLookupCgo
         .          .    137:	}
         .          .    138:
         .          .    139:	// OpenBSD is unique and doesn't use nsswitch.conf.
         .          .    140:	// It also doesn't support mDNS.
         .          .    141:	if c.goos == "openbsd" {
         .          .    142:		// OpenBSD's resolv.conf manpage says that a non-existent
         .          .    143:		// resolv.conf means "lookup" defaults to only "files",
         .          .    144:		// without DNS lookups.
         .          .    145:		if os.IsNotExist(c.resolv.err) {
         .          .    146:			return hostLookupFiles
         .          .    147:		}
         .          .    148:		lookup := c.resolv.lookup
         .          .    149:		if len(lookup) == 0 {
         .          .    150:			// http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man5/resolv.conf.5
         .          .    151:			// "If the lookup keyword is not used in the
         .          .    152:			// system's resolv.conf file then the assumed
         .          .    153:			// order is 'bind file'"
         .          .    154:			return hostLookupDNSFiles
         .          .    155:		}
         .          .    156:		if len(lookup) < 1 || len(lookup) > 2 {
         .          .    157:			return hostLookupCgo
         .          .    158:		}
         .          .    159:		switch lookup[0] {
         .          .    160:		case "bind":
         .          .    161:			if len(lookup) == 2 {
         .          .    162:				if lookup[1] == "file" {
         .          .    163:					return hostLookupDNSFiles
         .          .    164:				}
         .          .    165:				return hostLookupCgo
         .          .    166:			}
         .          .    167:			return hostLookupDNS
         .          .    168:		case "file":
         .          .    169:			if len(lookup) == 2 {
         .          .    170:				if lookup[1] == "bind" {
         .          .    171:					return hostLookupFilesDNS
         .          .    172:				}
         .          .    173:				return hostLookupCgo
         .          .    174:			}
         .          .    175:			return hostLookupFiles
         .          .    176:		default:
         .          .    177:			return hostLookupCgo
         .          .    178:		}
         .          .    179:	}
         .          .    180:
         .          .    181:	hasDot := byteIndex(hostname, '.') != -1
         .          .    182:
         .          .    183:	// Canonicalize the hostname by removing any trailing dot.
         .          .    184:	if stringsHasSuffix(hostname, ".") {
         .          .    185:		hostname = hostname[:len(hostname)-1]
         .          .    186:	}
         .          .    187:	if stringsHasSuffixFold(hostname, ".local") {
         .          .    188:		// Per RFC 6762, the ".local" TLD is special.  And
         .          .    189:		// because Go's native resolver doesn't do mDNS or
         .          .    190:		// similar local resolution mechanisms, assume that
         .          .    191:		// libc might (via Avahi, etc) and use cgo.
         .          .    192:		return hostLookupCgo
         .          .    193:	}
         .          .    194:
         .          .    195:	nss := c.nss
         .       10ms    196:	srcs := nss.sources["hosts"]
         .          .    197:	// If /etc/nsswitch.conf doesn't exist or doesn't specify any
         .          .    198:	// sources for "hosts", assume Go's DNS will work fine.
         .          .    199:	if os.IsNotExist(nss.err) || (nss.err == nil && len(srcs) == 0) {
         .          .    200:		if c.goos == "solaris" {
         .          .    201:			// illumos defaults to "nis [NOTFOUND=return] files"
ROUTINE ======================== net.(*conn).Close in /home/isucon/.local/go/src/net/net.go
         0      170ms (flat, cum)  0.31% of Total
         .          .    191:// Close closes the connection.
         .          .    192:func (c *conn) Close() error {
         .          .    193:	if !c.ok() {
         .          .    194:		return syscall.EINVAL
         .          .    195:	}
         .      170ms    196:	err := c.fd.Close()
         .          .    197:	if err != nil {
         .          .    198:		err = &OpError{Op: "close", Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}
         .          .    199:	}
         .          .    200:	return err
         .          .    201:}
ROUTINE ======================== net.(*conn).Read in /home/isucon/.local/go/src/net/net.go
         0      1.08s (flat, cum)  1.94% of Total
         .          .    167:// Read implements the Conn Read method.
         .          .    168:func (c *conn) Read(b []byte) (int, error) {
         .          .    169:	if !c.ok() {
         .          .    170:		return 0, syscall.EINVAL
         .          .    171:	}
         .      1.08s    172:	n, err := c.fd.Read(b)
         .          .    173:	if err != nil && err != io.EOF {
         .          .    174:		err = &OpError{Op: "read", Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}
         .          .    175:	}
         .          .    176:	return n, err
         .          .    177:}
ROUTINE ======================== net.(*conn).Write in /home/isucon/.local/go/src/net/net.go
      70ms      2.77s (flat, cum)  4.98% of Total
         .          .    175:	}
         .          .    176:	return n, err
         .          .    177:}
         .          .    178:
         .          .    179:// Write implements the Conn Write method.
      20ms       20ms    180:func (c *conn) Write(b []byte) (int, error) {
         .          .    181:	if !c.ok() {
         .          .    182:		return 0, syscall.EINVAL
         .          .    183:	}
      10ms      2.71s    184:	n, err := c.fd.Write(b)
         .          .    185:	if err != nil {
         .          .    186:		err = &OpError{Op: "write", Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}
         .          .    187:	}
      40ms       40ms    188:	return n, err
         .          .    189:}
         .          .    190:
         .          .    191:// Close closes the connection.
         .          .    192:func (c *conn) Close() error {
         .          .    193:	if !c.ok() {
ROUTINE ======================== net.(*fdMutex).Decref in /home/isucon/.local/go/src/net/fd_mutex.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     95:		old := atomic.LoadUint64(&mu.state)
         .          .     96:		if old&mutexRefMask == 0 {
         .          .     97:			panic("net: inconsistent fdMutex")
         .          .     98:		}
         .          .     99:		new := old - mutexRef
         .       10ms    100:		if atomic.CompareAndSwapUint64(&mu.state, old, new) {
         .          .    101:			return new&(mutexClosed|mutexRefMask) == mutexClosed
         .          .    102:		}
         .          .    103:	}
         .          .    104:}
         .          .    105:
ROUTINE ======================== net.(*fdMutex).RWLock in /home/isucon/.local/go/src/net/fd_mutex.go
      30ms       40ms (flat, cum) 0.072% of Total
         .          .    101:			return new&(mutexClosed|mutexRefMask) == mutexClosed
         .          .    102:		}
         .          .    103:	}
         .          .    104:}
         .          .    105:
      10ms       10ms    106:func (mu *fdMutex) RWLock(read bool) bool {
         .          .    107:	var mutexBit, mutexWait, mutexMask uint64
         .          .    108:	var mutexSema *uint32
         .          .    109:	if read {
      10ms       10ms    110:		mutexBit = mutexRLock
         .          .    111:		mutexWait = mutexRWait
         .          .    112:		mutexMask = mutexRMask
         .          .    113:		mutexSema = &mu.rsema
         .          .    114:	} else {
      10ms       10ms    115:		mutexBit = mutexWLock
         .          .    116:		mutexWait = mutexWWait
         .          .    117:		mutexMask = mutexWMask
         .          .    118:		mutexSema = &mu.wsema
         .          .    119:	}
         .          .    120:	for {
         .       10ms    121:		old := atomic.LoadUint64(&mu.state)
         .          .    122:		if old&mutexClosed != 0 {
         .          .    123:			return false
         .          .    124:		}
         .          .    125:		var new uint64
         .          .    126:		if old&mutexBit == 0 {
ROUTINE ======================== net.(*fdMutex).RWUnlock in /home/isucon/.local/go/src/net/fd_mutex.go
      20ms       60ms (flat, cum)  0.11% of Total
         .          .    154:		mutexWait = mutexRWait
         .          .    155:		mutexMask = mutexRMask
         .          .    156:		mutexSema = &mu.rsema
         .          .    157:	} else {
         .          .    158:		mutexBit = mutexWLock
      10ms       10ms    159:		mutexWait = mutexWWait
         .          .    160:		mutexMask = mutexWMask
         .          .    161:		mutexSema = &mu.wsema
         .          .    162:	}
         .          .    163:	for {
         .       40ms    164:		old := atomic.LoadUint64(&mu.state)
         .          .    165:		if old&mutexBit == 0 || old&mutexRefMask == 0 {
         .          .    166:			panic("net: inconsistent fdMutex")
         .          .    167:		}
         .          .    168:		// Drop lock, drop reference and wake read waiter if present.
         .          .    169:		new := (old &^ mutexBit) - mutexRef
         .          .    170:		if old&mutexMask != 0 {
         .          .    171:			new -= mutexWait
         .          .    172:		}
      10ms       10ms    173:		if atomic.CompareAndSwapUint64(&mu.state, old, new) {
         .          .    174:			if old&mutexMask != 0 {
         .          .    175:				runtime_Semrelease(mutexSema)
         .          .    176:			}
         .          .    177:			return new&(mutexClosed|mutexRefMask) == mutexClosed
         .          .    178:		}
ROUTINE ======================== net.(*netFD).Close in /home/isucon/.local/go/src/net/fd_unix.go
         0      200ms (flat, cum)  0.36% of Total
         .          .    211:	// Unblock any I/O.  Once it all unblocks and returns,
         .          .    212:	// so that it cannot be referring to fd.sysfd anymore,
         .          .    213:	// the final decref will close fd.sysfd.  This should happen
         .          .    214:	// fairly quickly, since all the I/O is non-blocking, and any
         .          .    215:	// attempts to block in the pollDesc will return errClosing.
         .       20ms    216:	fd.pd.Evict()
         .      180ms    217:	fd.decref()
         .          .    218:	return nil
         .          .    219:}
         .          .    220:
         .          .    221:func (fd *netFD) shutdown(how int) error {
         .          .    222:	if err := fd.incref(); err != nil {
ROUTINE ======================== net.(*netFD).Read in /home/isucon/.local/go/src/net/fd_unix.go
      40ms      1.08s (flat, cum)  1.94% of Total
         .          .    232:
         .          .    233:func (fd *netFD) closeWrite() error {
         .          .    234:	return fd.shutdown(syscall.SHUT_WR)
         .          .    235:}
         .          .    236:
      10ms       10ms    237:func (fd *netFD) Read(p []byte) (n int, err error) {
      10ms       30ms    238:	if err := fd.readLock(); err != nil {
         .          .    239:		return 0, err
         .          .    240:	}
         .       60ms    241:	defer fd.readUnlock()
         .       40ms    242:	if err := fd.pd.PrepareRead(); err != nil {
         .          .    243:		return 0, err
         .          .    244:	}
         .          .    245:	for {
      10ms      830ms    246:		n, err = syscall.Read(fd.sysfd, p)
         .          .    247:		if err != nil {
         .          .    248:			n = 0
         .       10ms    249:			if err == syscall.EAGAIN {
         .       20ms    250:				if err = fd.pd.WaitRead(); err == nil {
         .          .    251:					continue
         .          .    252:				}
         .          .    253:			}
         .          .    254:		}
      10ms       10ms    255:		err = fd.eofError(n, err)
         .          .    256:		break
         .          .    257:	}
         .       10ms    258:	if _, ok := err.(syscall.Errno); ok {
         .          .    259:		err = os.NewSyscallError("read", err)
         .          .    260:	}
         .       60ms    261:	return
         .          .    262:}
         .          .    263:
         .          .    264:func (fd *netFD) readFrom(p []byte) (n int, sa syscall.Sockaddr, err error) {
         .          .    265:	if err := fd.readLock(); err != nil {
         .          .    266:		return 0, nil, err
ROUTINE ======================== net.(*netFD).Write in /home/isucon/.local/go/src/net/fd_unix.go
      30ms      2.70s (flat, cum)  4.85% of Total
         .          .    314:	}
         .          .    315:	return
         .          .    316:}
         .          .    317:
         .          .    318:func (fd *netFD) Write(p []byte) (nn int, err error) {
         .       40ms    319:	if err := fd.writeLock(); err != nil {
         .          .    320:		return 0, err
         .          .    321:	}
         .       40ms    322:	defer fd.writeUnlock()
         .          .    323:	if err := fd.pd.PrepareWrite(); err != nil {
         .          .    324:		return 0, err
         .          .    325:	}
         .          .    326:	for {
         .          .    327:		var n int
      20ms      2.43s    328:		n, err = syscall.Write(fd.sysfd, p[nn:])
         .          .    329:		if n > 0 {
      10ms       10ms    330:			nn += n
         .          .    331:		}
         .          .    332:		if nn == len(p) {
         .          .    333:			break
         .          .    334:		}
         .          .    335:		if err == syscall.EAGAIN {
         .          .    336:			if err = fd.pd.WaitWrite(); err == nil {
         .          .    337:				continue
         .          .    338:			}
         .          .    339:		}
         .          .    340:		if err != nil {
         .          .    341:			break
         .          .    342:		}
         .          .    343:		if n == 0 {
         .          .    344:			err = io.ErrUnexpectedEOF
         .          .    345:			break
         .          .    346:		}
         .          .    347:	}
         .          .    348:	if _, ok := err.(syscall.Errno); ok {
         .          .    349:		err = os.NewSyscallError("write", err)
         .          .    350:	}
         .      180ms    351:	return nn, err
         .          .    352:}
         .          .    353:
         .          .    354:func (fd *netFD) writeTo(p []byte, sa syscall.Sockaddr) (n int, err error) {
         .          .    355:	if err := fd.writeLock(); err != nil {
         .          .    356:		return 0, err
ROUTINE ======================== net.(*netFD).accept in /home/isucon/.local/go/src/net/fd_unix.go
         0      330ms (flat, cum)  0.59% of Total
         .          .    413:	var rsa syscall.Sockaddr
         .          .    414:	if err = fd.pd.PrepareRead(); err != nil {
         .          .    415:		return nil, err
         .          .    416:	}
         .          .    417:	for {
         .      200ms    418:		s, rsa, err = accept(fd.sysfd)
         .          .    419:		if err != nil {
         .          .    420:			nerr, ok := err.(*os.SyscallError)
         .          .    421:			if !ok {
         .          .    422:				return nil, err
         .          .    423:			}
         .          .    424:			switch nerr.Err {
         .          .    425:			case syscall.EAGAIN:
         .          .    426:				if err = fd.pd.WaitRead(); err == nil {
         .          .    427:					continue
         .          .    428:				}
         .          .    429:			case syscall.ECONNABORTED:
         .          .    430:				// This means that a socket on the
         .          .    431:				// listen queue was closed before we
         .          .    432:				// Accept()ed it; it's a silly error,
         .          .    433:				// so try again.
         .          .    434:				continue
         .          .    435:			}
         .          .    436:			return nil, err
         .          .    437:		}
         .          .    438:		break
         .          .    439:	}
         .          .    440:
         .       50ms    441:	if netfd, err = newFD(s, fd.family, fd.sotype, fd.net); err != nil {
         .          .    442:		closeFunc(s)
         .          .    443:		return nil, err
         .          .    444:	}
         .       30ms    445:	if err = netfd.init(); err != nil {
         .          .    446:		fd.Close()
         .          .    447:		return nil, err
         .          .    448:	}
         .       10ms    449:	lsa, _ := syscall.Getsockname(netfd.sysfd)
         .       30ms    450:	netfd.setAddr(netfd.addrFunc()(lsa), netfd.addrFunc()(rsa))
         .       10ms    451:	return netfd, nil
         .          .    452:}
         .          .    453:
         .          .    454:// tryDupCloexec indicates whether F_DUPFD_CLOEXEC should be used.
         .          .    455:// If the kernel doesn't support it, this is set to 0.
         .          .    456:var tryDupCloexec = int32(1)
ROUTINE ======================== net.(*netFD).connect in /home/isucon/.local/go/src/net/fd_unix.go
      10ms      280ms (flat, cum)   0.5% of Total
         .          .     70:
         .          .     71:func (fd *netFD) connect(la, ra syscall.Sockaddr, deadline time.Time, cancel <-chan struct{}) error {
         .          .     72:	// Do not need to call fd.writeLock here,
         .          .     73:	// because fd is not yet accessible to user,
         .          .     74:	// so no concurrent operations are possible.
      10ms      180ms     75:	switch err := connectFunc(fd.sysfd, ra); err {
         .          .     76:	case syscall.EINPROGRESS, syscall.EALREADY, syscall.EINTR:
         .          .     77:	case nil, syscall.EISCONN:
         .          .     78:		if !deadline.IsZero() && deadline.Before(time.Now()) {
         .          .     79:			return errTimeout
         .          .     80:		}
         .       10ms     81:		if err := fd.init(); err != nil {
         .          .     82:			return err
         .          .     83:		}
         .          .     84:		return nil
         .          .     85:	case syscall.EINVAL:
         .          .     86:		// On Solaris we can see EINVAL if the socket has
         .          .     87:		// already been accepted and closed by the server.
         .          .     88:		// Treat this as a successful connection--writes to
         .          .     89:		// the socket will see EOF.  For details and a test
         .          .     90:		// case in C see https://golang.org/issue/6828.
         .          .     91:		if runtime.GOOS == "solaris" {
         .          .     92:			return nil
         .          .     93:		}
         .          .     94:		fallthrough
         .          .     95:	default:
         .          .     96:		return os.NewSyscallError("connect", err)
         .          .     97:	}
         .       20ms     98:	if err := fd.init(); err != nil {
         .          .     99:		return err
         .          .    100:	}
         .          .    101:	if !deadline.IsZero() {
         .          .    102:		fd.setWriteDeadline(deadline)
         .          .    103:		defer fd.setWriteDeadline(noDeadline)
         .          .    104:	}
         .          .    105:	if cancel != nil {
         .          .    106:		done := make(chan bool)
         .          .    107:		defer close(done)
         .          .    108:		go func() {
         .          .    109:			select {
         .          .    110:			case <-cancel:
         .          .    111:				// Force the runtime's poller to immediately give
         .          .    112:				// up waiting for writability.
         .          .    113:				fd.setWriteDeadline(aLongTimeAgo)
         .          .    114:			case <-done:
         .          .    115:			}
         .          .    116:		}()
         .          .    117:	}
         .          .    118:	for {
         .          .    119:		// Performing multiple connect system calls on a
         .          .    120:		// non-blocking socket under Unix variants does not
         .          .    121:		// necessarily result in earlier errors being
         .          .    122:		// returned. Instead, once runtime-integrated network
         .          .    123:		// poller tells us that the socket is ready, get the
         .          .    124:		// SO_ERROR socket option to see if the connection
         .          .    125:		// succeeded or failed. See issue 7474 for further
         .          .    126:		// details.
         .          .    127:		if err := fd.pd.WaitWrite(); err != nil {
         .          .    128:			select {
         .          .    129:			case <-cancel:
         .          .    130:				return errCanceled
         .          .    131:			default:
         .          .    132:			}
         .          .    133:			return err
         .          .    134:		}
         .       10ms    135:		nerr, err := getsockoptIntFunc(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_ERROR)
         .          .    136:		if err != nil {
         .          .    137:			return os.NewSyscallError("getsockopt", err)
         .          .    138:		}
         .          .    139:		switch err := syscall.Errno(nerr); err {
         .          .    140:		case syscall.EINPROGRESS, syscall.EALREADY, syscall.EINTR:
         .          .    141:		case syscall.Errno(0), syscall.EISCONN:
         .          .    142:			return nil
         .          .    143:		default:
         .       60ms    144:			return os.NewSyscallError("getsockopt", err)
         .          .    145:		}
         .          .    146:	}
         .          .    147:}
         .          .    148:
         .          .    149:func (fd *netFD) destroy() {
ROUTINE ======================== net.(*netFD).decref in /home/isucon/.local/go/src/net/fd_unix.go
      10ms      180ms (flat, cum)  0.32% of Total
         .          .    165:}
         .          .    166:
         .          .    167:// Remove a reference to this FD and close if we've been asked to do so
         .          .    168:// (and there are no references left).
         .          .    169:func (fd *netFD) decref() {
         .       10ms    170:	if fd.fdmu.Decref() {
      10ms      170ms    171:		fd.destroy()
         .          .    172:	}
         .          .    173:}
         .          .    174:
         .          .    175:// Add a reference to this fd and lock for reading.
         .          .    176:// Returns an error if the fd cannot be used.
ROUTINE ======================== net.(*netFD).destroy in /home/isucon/.local/go/src/net/fd_unix.go
         0      160ms (flat, cum)  0.29% of Total
         .          .    147:}
         .          .    148:
         .          .    149:func (fd *netFD) destroy() {
         .          .    150:	// Poller may want to unregister fd in readiness notification mechanism,
         .          .    151:	// so this must be executed before closeFunc.
         .       30ms    152:	fd.pd.Close()
         .      110ms    153:	closeFunc(fd.sysfd)
         .          .    154:	fd.sysfd = -1
         .       20ms    155:	runtime.SetFinalizer(fd, nil)
         .          .    156:}
         .          .    157:
         .          .    158:// Add a reference to this fd.
         .          .    159:// Returns an error if the fd cannot be used.
         .          .    160:func (fd *netFD) incref() error {
ROUTINE ======================== net.(*netFD).dial in /home/isucon/.local/go/src/net/sock_posix.go
      10ms      390ms (flat, cum)   0.7% of Total
         .          .    129:			}
         .          .    130:		}
         .          .    131:	}
         .          .    132:	var rsa syscall.Sockaddr
         .          .    133:	if raddr != nil {
         .       10ms    134:		if rsa, err = raddr.sockaddr(fd.family); err != nil {
         .          .    135:			return err
         .          .    136:		}
      10ms      290ms    137:		if err := fd.connect(lsa, rsa, deadline, cancel); err != nil {
         .          .    138:			return err
         .          .    139:		}
         .          .    140:		fd.isConnected = true
         .          .    141:	} else {
         .          .    142:		if err := fd.init(); err != nil {
         .          .    143:			return err
         .          .    144:		}
         .          .    145:	}
         .       50ms    146:	lsa, _ = syscall.Getsockname(fd.sysfd)
         .       20ms    147:	if rsa, _ = syscall.Getpeername(fd.sysfd); rsa != nil {
         .       20ms    148:		fd.setAddr(fd.addrFunc()(lsa), fd.addrFunc()(rsa))
         .          .    149:	} else {
         .          .    150:		fd.setAddr(fd.addrFunc()(lsa), raddr)
         .          .    151:	}
         .          .    152:	return nil
         .          .    153:}
ROUTINE ======================== net.(*netFD).init in /home/isucon/.local/go/src/net/fd_unix.go
         0       60ms (flat, cum)  0.11% of Total
         .          .     43:func newFD(sysfd, family, sotype int, net string) (*netFD, error) {
         .          .     44:	return &netFD{sysfd: sysfd, family: family, sotype: sotype, net: net}, nil
         .          .     45:}
         .          .     46:
         .          .     47:func (fd *netFD) init() error {
         .       60ms     48:	if err := fd.pd.Init(fd); err != nil {
         .          .     49:		return err
         .          .     50:	}
         .          .     51:	return nil
         .          .     52:}
         .          .     53:
ROUTINE ======================== net.(*netFD).readLock in /home/isucon/.local/go/src/net/fd_unix.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .    173:}
         .          .    174:
         .          .    175:// Add a reference to this fd and lock for reading.
         .          .    176:// Returns an error if the fd cannot be used.
         .          .    177:func (fd *netFD) readLock() error {
      10ms       20ms    178:	if !fd.fdmu.RWLock(true) {
         .          .    179:		return errClosing
         .          .    180:	}
         .          .    181:	return nil
         .          .    182:}
         .          .    183:
ROUTINE ======================== net.(*netFD).readUnlock in /home/isucon/.local/go/src/net/fd_unix.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    181:	return nil
         .          .    182:}
         .          .    183:
         .          .    184:// Unlock for reading and remove a reference to this FD.
         .          .    185:func (fd *netFD) readUnlock() {
         .       10ms    186:	if fd.fdmu.RWUnlock(true) {
         .          .    187:		fd.destroy()
         .          .    188:	}
         .          .    189:}
         .          .    190:
         .          .    191:// Add a reference to this fd and lock for writing.
ROUTINE ======================== net.(*netFD).setAddr in /home/isucon/.local/go/src/net/fd_unix.go
         0       30ms (flat, cum) 0.054% of Total
         .          .     52:}
         .          .     53:
         .          .     54:func (fd *netFD) setAddr(laddr, raddr Addr) {
         .          .     55:	fd.laddr = laddr
         .          .     56:	fd.raddr = raddr
         .       30ms     57:	runtime.SetFinalizer(fd, (*netFD).Close)
         .          .     58:}
         .          .     59:
         .          .     60:func (fd *netFD) name() string {
         .          .     61:	var ls, rs string
         .          .     62:	if fd.laddr != nil {
ROUTINE ======================== net.(*netFD).writeLock in /home/isucon/.local/go/src/net/fd_unix.go
      10ms       40ms (flat, cum) 0.072% of Total
         .          .    189:}
         .          .    190:
         .          .    191:// Add a reference to this fd and lock for writing.
         .          .    192:// Returns an error if the fd cannot be used.
         .          .    193:func (fd *netFD) writeLock() error {
      10ms       40ms    194:	if !fd.fdmu.RWLock(false) {
         .          .    195:		return errClosing
         .          .    196:	}
         .          .    197:	return nil
         .          .    198:}
         .          .    199:
ROUTINE ======================== net.(*netFD).writeUnlock in /home/isucon/.local/go/src/net/fd_unix.go
      10ms       60ms (flat, cum)  0.11% of Total
         .          .    197:	return nil
         .          .    198:}
         .          .    199:
         .          .    200:// Unlock for writing and remove a reference to this FD.
         .          .    201:func (fd *netFD) writeUnlock() {
      10ms       60ms    202:	if fd.fdmu.RWUnlock(false) {
         .          .    203:		fd.destroy()
         .          .    204:	}
         .          .    205:}
         .          .    206:
         .          .    207:func (fd *netFD) Close() error {
ROUTINE ======================== net.(*pollDesc).Close in /home/isucon/.local/go/src/net/fd_poll_runtime.go
         0       30ms (flat, cum) 0.054% of Total
         .          .     42:
         .          .     43:func (pd *pollDesc) Close() {
         .          .     44:	if pd.runtimeCtx == 0 {
         .          .     45:		return
         .          .     46:	}
         .       30ms     47:	runtime_pollClose(pd.runtimeCtx)
         .          .     48:	pd.runtimeCtx = 0
         .          .     49:}
         .          .     50:
         .          .     51:// Evict evicts fd from the pending list, unblocking any I/O running on fd.
         .          .     52:func (pd *pollDesc) Evict() {
ROUTINE ======================== net.(*pollDesc).Evict in /home/isucon/.local/go/src/net/fd_poll_runtime.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     51:// Evict evicts fd from the pending list, unblocking any I/O running on fd.
         .          .     52:func (pd *pollDesc) Evict() {
         .          .     53:	if pd.runtimeCtx == 0 {
         .          .     54:		return
         .          .     55:	}
         .       20ms     56:	runtime_pollUnblock(pd.runtimeCtx)
         .          .     57:}
         .          .     58:
         .          .     59:func (pd *pollDesc) Prepare(mode int) error {
         .          .     60:	res := runtime_pollReset(pd.runtimeCtx, mode)
         .          .     61:	return convertErr(res)
ROUTINE ======================== net.(*pollDesc).Init in /home/isucon/.local/go/src/net/fd_poll_runtime.go
         0       60ms (flat, cum)  0.11% of Total
         .          .     30:
         .          .     31:var serverInit sync.Once
         .          .     32:
         .          .     33:func (pd *pollDesc) Init(fd *netFD) error {
         .          .     34:	serverInit.Do(runtime_pollServerInit)
         .       60ms     35:	ctx, errno := runtime_pollOpen(uintptr(fd.sysfd))
         .          .     36:	if errno != 0 {
         .          .     37:		return syscall.Errno(errno)
         .          .     38:	}
         .          .     39:	pd.runtimeCtx = ctx
         .          .     40:	return nil
ROUTINE ======================== net.(*pollDesc).Prepare in /home/isucon/.local/go/src/net/fd_poll_runtime.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     55:	}
         .          .     56:	runtime_pollUnblock(pd.runtimeCtx)
         .          .     57:}
         .          .     58:
         .          .     59:func (pd *pollDesc) Prepare(mode int) error {
         .       20ms     60:	res := runtime_pollReset(pd.runtimeCtx, mode)
         .          .     61:	return convertErr(res)
         .          .     62:}
         .          .     63:
         .          .     64:func (pd *pollDesc) PrepareRead() error {
         .          .     65:	return pd.Prepare('r')
ROUTINE ======================== net.(*pollDesc).PrepareRead in /home/isucon/.local/go/src/net/fd_poll_runtime.go
      20ms       40ms (flat, cum) 0.072% of Total
         .          .     59:func (pd *pollDesc) Prepare(mode int) error {
         .          .     60:	res := runtime_pollReset(pd.runtimeCtx, mode)
         .          .     61:	return convertErr(res)
         .          .     62:}
         .          .     63:
      20ms       20ms     64:func (pd *pollDesc) PrepareRead() error {
         .       20ms     65:	return pd.Prepare('r')
         .          .     66:}
         .          .     67:
         .          .     68:func (pd *pollDesc) PrepareWrite() error {
         .          .     69:	return pd.Prepare('w')
         .          .     70:}
ROUTINE ======================== net.(*pollDesc).Wait in /home/isucon/.local/go/src/net/fd_poll_runtime.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     68:func (pd *pollDesc) PrepareWrite() error {
         .          .     69:	return pd.Prepare('w')
         .          .     70:}
         .          .     71:
         .          .     72:func (pd *pollDesc) Wait(mode int) error {
         .       20ms     73:	res := runtime_pollWait(pd.runtimeCtx, mode)
         .          .     74:	return convertErr(res)
         .          .     75:}
         .          .     76:
         .          .     77:func (pd *pollDesc) WaitRead() error {
         .          .     78:	return pd.Wait('r')
ROUTINE ======================== net.(*pollDesc).WaitRead in /home/isucon/.local/go/src/net/fd_poll_runtime.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     73:	res := runtime_pollWait(pd.runtimeCtx, mode)
         .          .     74:	return convertErr(res)
         .          .     75:}
         .          .     76:
         .          .     77:func (pd *pollDesc) WaitRead() error {
         .       20ms     78:	return pd.Wait('r')
         .          .     79:}
         .          .     80:
         .          .     81:func (pd *pollDesc) WaitWrite() error {
         .          .     82:	return pd.Wait('w')
         .          .     83:}
ROUTINE ======================== net.DialUDP in /home/isucon/.local/go/src/net/udpsock_posix.go
         0      140ms (flat, cum)  0.25% of Total
         .          .    183:		return nil, &OpError{Op: "dial", Net: net, Source: laddr.opAddr(), Addr: raddr.opAddr(), Err: UnknownNetworkError(net)}
         .          .    184:	}
         .          .    185:	if raddr == nil {
         .          .    186:		return nil, &OpError{Op: "dial", Net: net, Source: laddr.opAddr(), Addr: nil, Err: errMissingAddress}
         .          .    187:	}
         .      140ms    188:	return dialUDP(net, laddr, raddr, noDeadline)
         .          .    189:}
         .          .    190:
         .          .    191:func dialUDP(net string, laddr, raddr *UDPAddr, deadline time.Time) (*UDPConn, error) {
         .          .    192:	fd, err := internetSocket(net, laddr, raddr, deadline, syscall.SOCK_DGRAM, 0, "dial", noCancel)
         .          .    193:	if err != nil {
ROUTINE ======================== net.IP.Equal in /home/isucon/.local/go/src/net/ip.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    352:// Equal reports whether ip and x are the same IP address.
         .          .    353:// An IPv4 address and that same address in IPv6 form are
         .          .    354:// considered to be equal.
         .          .    355:func (ip IP) Equal(x IP) bool {
         .          .    356:	if len(ip) == len(x) {
         .       10ms    357:		return bytesEqual(ip, x)
         .          .    358:	}
         .          .    359:	if len(ip) == IPv4len && len(x) == IPv6len {
         .          .    360:		return bytesEqual(x[0:12], v4InV6Prefix) && bytesEqual(ip, x[12:])
         .          .    361:	}
         .          .    362:	if len(ip) == IPv6len && len(x) == IPv4len {
ROUTINE ======================== net.IP.String in /home/isucon/.local/go/src/net/ip.go
         0      260ms (flat, cum)  0.47% of Total
         .          .    262:		return "<nil>"
         .          .    263:	}
         .          .    264:
         .          .    265:	// If IPv4, use dotted notation.
         .          .    266:	if p4 := p.To4(); len(p4) == IPv4len {
         .      240ms    267:		return uitoa(uint(p4[0])) + "." +
         .          .    268:			uitoa(uint(p4[1])) + "." +
         .          .    269:			uitoa(uint(p4[2])) + "." +
         .       20ms    270:			uitoa(uint(p4[3]))
         .          .    271:	}
         .          .    272:	if len(p) != IPv6len {
         .          .    273:		return "?"
         .          .    274:	}
         .          .    275:
ROUTINE ======================== net.SplitHostPort in /home/isucon/.local/go/src/net/ipsock.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    148:		}
         .          .    149:		if byteIndex(host, '%') >= 0 {
         .          .    150:			goto missingBrackets
         .          .    151:		}
         .          .    152:	}
      10ms       10ms    153:	if byteIndex(hostport[j:], '[') >= 0 {
         .          .    154:		err = &AddrError{Err: "unexpected '[' in address", Addr: hostport}
         .          .    155:		return
         .          .    156:	}
         .          .    157:	if byteIndex(hostport[k:], ']') >= 0 {
         .          .    158:		err = &AddrError{Err: "unexpected ']' in address", Addr: hostport}
ROUTINE ======================== net.accept in /home/isucon/.local/go/src/net/sock_cloexec.go
         0      200ms (flat, cum)  0.36% of Total
         .          .     49:}
         .          .     50:
         .          .     51:// Wrapper around the accept system call that marks the returned file
         .          .     52:// descriptor as nonblocking and close-on-exec.
         .          .     53:func accept(s int) (int, syscall.Sockaddr, error) {
         .      190ms     54:	ns, sa, err := accept4Func(s, syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC)
         .          .     55:	// On Linux the accept4 system call was introduced in 2.6.28
         .          .     56:	// kernel and on FreeBSD it was introduced in 10 kernel. If we
         .          .     57:	// get an ENOSYS error on both Linux and FreeBSD, or EINVAL
         .          .     58:	// error on Linux, fall back to using accept.
         .          .     59:	switch err {
         .          .     60:	case nil:
         .          .     61:		return ns, sa, nil
         .          .     62:	default: // errors other than the ones listed
         .       10ms     63:		return -1, sa, os.NewSyscallError("accept4", err)
         .          .     64:	case syscall.ENOSYS: // syscall missing
         .          .     65:	case syscall.EINVAL: // some Linux use this instead of ENOSYS
         .          .     66:	case syscall.EACCES: // some Linux use this instead of ENOSYS
         .          .     67:	case syscall.EFAULT: // some Linux use this instead of ENOSYS
         .          .     68:	}
ROUTINE ======================== net.bytesEqual in /home/isucon/.local/go/src/net/ip.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    368:func bytesEqual(x, y []byte) bool {
         .          .    369:	if len(x) != len(y) {
         .          .    370:		return false
         .          .    371:	}
         .          .    372:	for i, b := range x {
      10ms       10ms    373:		if y[i] != b {
         .          .    374:			return false
         .          .    375:		}
         .          .    376:	}
         .          .    377:	return true
         .          .    378:}
ROUTINE ======================== net.dial in /home/isucon/.local/go/src/net/fd_unix.go
         0      370ms (flat, cum)  0.66% of Total
         .          .     35:
         .          .     36:func sysInit() {
         .          .     37:}
         .          .     38:
         .          .     39:func dial(network string, ra Addr, dialer func(time.Time) (Conn, error), deadline time.Time) (Conn, error) {
         .      370ms     40:	return dialer(deadline)
         .          .     41:}
         .          .     42:
         .          .     43:func newFD(sysfd, family, sotype int, net string) (*netFD, error) {
         .          .     44:	return &netFD{sysfd: sysfd, family: family, sotype: sotype, net: net}, nil
         .          .     45:}
ROUTINE ======================== net.dialSerial in /home/isucon/.local/go/src/net/dial.go
         0      380ms (flat, cum)  0.68% of Total
         .          .    337:		}
         .          .    338:
         .          .    339:		// dialTCP does not support cancelation (see golang.org/issue/11225),
         .          .    340:		// so if cancel fires, we'll continue trying to connect until the next
         .          .    341:		// timeout, or return a spurious connection for the caller to close.
         .       10ms    342:		dialer := func(d time.Time) (Conn, error) {
         .          .    343:			return dialSingle(ctx, ra, d)
         .          .    344:		}
         .      370ms    345:		c, err := dial(ctx.network, ra, dialer, partialDeadline)
         .          .    346:		if err == nil {
         .          .    347:			return c, nil
         .          .    348:		}
         .          .    349:		if firstErr == nil {
         .          .    350:			firstErr = err
ROUTINE ======================== net.dialSerial.func1 in /home/isucon/.local/go/src/net/dial.go
         0      370ms (flat, cum)  0.66% of Total
         .          .    338:
         .          .    339:		// dialTCP does not support cancelation (see golang.org/issue/11225),
         .          .    340:		// so if cancel fires, we'll continue trying to connect until the next
         .          .    341:		// timeout, or return a spurious connection for the caller to close.
         .          .    342:		dialer := func(d time.Time) (Conn, error) {
         .      370ms    343:			return dialSingle(ctx, ra, d)
         .          .    344:		}
         .          .    345:		c, err := dial(ctx.network, ra, dialer, partialDeadline)
         .          .    346:		if err == nil {
         .          .    347:			return c, nil
         .          .    348:		}
ROUTINE ======================== net.dialSingle in /home/isucon/.local/go/src/net/dial.go
         0      370ms (flat, cum)  0.66% of Total
         .          .    366:		return nil, &OpError{Op: "dial", Net: ctx.network, Source: la, Addr: ra, Err: errors.New("mismatched local address type " + la.Network())}
         .          .    367:	}
         .          .    368:	switch ra := ra.(type) {
         .          .    369:	case *TCPAddr:
         .          .    370:		la, _ := la.(*TCPAddr)
         .      370ms    371:		c, err = testHookDialTCP(ctx.network, la, ra, deadline, ctx.Cancel)
         .          .    372:	case *UDPAddr:
         .          .    373:		la, _ := la.(*UDPAddr)
         .          .    374:		c, err = dialUDP(ctx.network, la, ra, deadline)
         .          .    375:	case *IPAddr:
         .          .    376:		la, _ := la.(*IPAddr)
ROUTINE ======================== net.dialTCP in /home/isucon/.local/go/src/net/tcpsock_posix.go
         0      370ms (flat, cum)  0.66% of Total
         .          .    166:	}
         .          .    167:	return dialTCP(net, laddr, raddr, noDeadline, noCancel)
         .          .    168:}
         .          .    169:
         .          .    170:func dialTCP(net string, laddr, raddr *TCPAddr, deadline time.Time, cancel <-chan struct{}) (*TCPConn, error) {
         .      370ms    171:	fd, err := internetSocket(net, laddr, raddr, deadline, syscall.SOCK_STREAM, 0, "dial", cancel)
         .          .    172:
         .          .    173:	// TCP has a rarely used mechanism called a 'simultaneous connection' in
         .          .    174:	// which Dial("tcp", addr1, addr2) run on the machine at addr1 can
         .          .    175:	// connect to a simultaneous Dial("tcp", addr2, addr1) run on the machine
         .          .    176:	// at addr2, without either machine executing Listen.  If laddr == nil,
ROUTINE ======================== net.dialUDP in /home/isucon/.local/go/src/net/udpsock_posix.go
         0      140ms (flat, cum)  0.25% of Total
         .          .    187:	}
         .          .    188:	return dialUDP(net, laddr, raddr, noDeadline)
         .          .    189:}
         .          .    190:
         .          .    191:func dialUDP(net string, laddr, raddr *UDPAddr, deadline time.Time) (*UDPConn, error) {
         .      140ms    192:	fd, err := internetSocket(net, laddr, raddr, deadline, syscall.SOCK_DGRAM, 0, "dial", noCancel)
         .          .    193:	if err != nil {
         .          .    194:		return nil, &OpError{Op: "dial", Net: net, Source: laddr.opAddr(), Addr: raddr.opAddr(), Err: err}
         .          .    195:	}
         .          .    196:	return newUDPConn(fd), nil
         .          .    197:}
ROUTINE ======================== net.filterAddrList in /home/isucon/.local/go/src/net/ipsock.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     81:// The result contains at least one address when error is nil.
         .          .     82:func filterAddrList(filter func(IPAddr) bool, ips []IPAddr, inetaddr func(IPAddr) Addr) (addrList, error) {
         .          .     83:	var addrs addrList
         .          .     84:	for _, ip := range ips {
         .          .     85:		if filter == nil || filter(ip) {
         .       10ms     86:			addrs = append(addrs, inetaddr(ip))
         .          .     87:		}
         .          .     88:	}
         .          .     89:	if len(addrs) == 0 {
         .          .     90:		return nil, errNoSuitableAddress
         .          .     91:	}
ROUTINE ======================== net.glob.func16 in /home/isucon/.local/go/src/net/hook.go
         0      210ms (flat, cum)  0.38% of Total
         .          .      5:package net
         .          .      6:
         .          .      7:var (
         .          .      8:	testHookDialTCP      = dialTCP
         .          .      9:	testHookHostsPath    = "/etc/hosts"
         .      210ms     10:	testHookLookupIP     = func(fn func(string) ([]IPAddr, error), host string) ([]IPAddr, error) { return fn(host) }
         .          .     11:	testHookSetKeepAlive = func() {}
         .          .     12:)
ROUTINE ======================== net.goLookupIPFiles in /home/isucon/.local/go/src/net/dnsclient_unix.go
         0      190ms (flat, cum)  0.34% of Total
         .          .    415:	return
         .          .    416:}
         .          .    417:
         .          .    418:// lookup entries from /etc/hosts
         .          .    419:func goLookupIPFiles(name string) (addrs []IPAddr) {
         .       10ms    420:	for _, haddr := range lookupStaticHost(name) {
         .          .    421:		haddr, zone := splitHostZone(haddr)
         .          .    422:		if ip := ParseIP(haddr); ip != nil {
         .          .    423:			addr := IPAddr{IP: ip, Zone: zone}
         .          .    424:			addrs = append(addrs, addr)
         .          .    425:		}
         .          .    426:	}
         .      180ms    427:	sortByRFC6724(addrs)
         .          .    428:	return
         .          .    429:}
         .          .    430:
         .          .    431:// goLookupIP is the native Go implementation of LookupIP.
         .          .    432:// The libc versions are in cgo_*.go.
ROUTINE ======================== net.goLookupIPOrder in /home/isucon/.local/go/src/net/dnsclient_unix.go
         0      190ms (flat, cum)  0.34% of Total
         .          .    434:	return goLookupIPOrder(name, hostLookupFilesDNS)
         .          .    435:}
         .          .    436:
         .          .    437:func goLookupIPOrder(name string, order hostLookupOrder) (addrs []IPAddr, err error) {
         .          .    438:	if order == hostLookupFilesDNS || order == hostLookupFiles {
         .      190ms    439:		addrs = goLookupIPFiles(name)
         .          .    440:		if len(addrs) > 0 || order == hostLookupFiles {
         .          .    441:			return addrs, nil
         .          .    442:		}
         .          .    443:	}
         .          .    444:	if !isDomainName(name) {
ROUTINE ======================== net.internetAddrList in /home/isucon/.local/go/src/net/ipsock.go
      10ms      240ms (flat, cum)  0.43% of Total
         .          .    208:		portnum    int
         .          .    209:	)
         .          .    210:	switch net {
         .          .    211:	case "tcp", "tcp4", "tcp6", "udp", "udp4", "udp6":
         .          .    212:		if addr != "" {
         .       10ms    213:			if host, port, err = SplitHostPort(addr); err != nil {
         .          .    214:				return nil, err
         .          .    215:			}
         .          .    216:			if portnum, err = LookupPort(net, port); err != nil {
         .          .    217:				return nil, err
         .          .    218:			}
         .          .    219:		}
         .          .    220:	case "ip", "ip4", "ip6":
         .          .    221:		if addr != "" {
         .          .    222:			host = addr
         .          .    223:		}
         .          .    224:	default:
         .          .    225:		return nil, UnknownNetworkError(net)
         .          .    226:	}
         .          .    227:	inetaddr := func(ip IPAddr) Addr {
         .          .    228:		switch net {
         .          .    229:		case "tcp", "tcp4", "tcp6":
         .          .    230:			return &TCPAddr{IP: ip.IP, Port: portnum, Zone: ip.Zone}
         .          .    231:		case "udp", "udp4", "udp6":
         .          .    232:			return &UDPAddr{IP: ip.IP, Port: portnum, Zone: ip.Zone}
         .          .    233:		case "ip", "ip4", "ip6":
         .          .    234:			return &IPAddr{IP: ip.IP, Zone: ip.Zone}
         .          .    235:		default:
         .          .    236:			panic("unexpected network: " + net)
         .          .    237:		}
         .          .    238:	}
         .          .    239:	if host == "" {
         .          .    240:		return addrList{inetaddr(IPAddr{})}, nil
         .          .    241:	}
         .          .    242:	// Try as a literal IP address.
         .          .    243:	var ip IP
         .          .    244:	if ip = parseIPv4(host); ip != nil {
         .          .    245:		return addrList{inetaddr(IPAddr{IP: ip})}, nil
         .          .    246:	}
         .          .    247:	var zone string
      10ms       10ms    248:	if ip, zone = parseIPv6(host, true); ip != nil {
         .          .    249:		return addrList{inetaddr(IPAddr{IP: ip, Zone: zone})}, nil
         .          .    250:	}
         .          .    251:	// Try as a DNS name.
         .      210ms    252:	ips, err := lookupIPDeadline(host, deadline)
         .          .    253:	if err != nil {
         .          .    254:		return nil, err
         .          .    255:	}
         .          .    256:	var filter func(IPAddr) bool
         .          .    257:	if net != "" && net[len(net)-1] == '4' {
         .          .    258:		filter = ipv4only
         .          .    259:	}
         .          .    260:	if net != "" && net[len(net)-1] == '6' {
         .          .    261:		filter = ipv6only
         .          .    262:	}
         .       10ms    263:	return filterAddrList(filter, ips, inetaddr)
         .          .    264:}
         .          .    265:
         .          .    266:func zoneToString(zone int) string {
         .          .    267:	if zone == 0 {
         .          .    268:		return ""
ROUTINE ======================== net.internetSocket in /home/isucon/.local/go/src/net/ipsock_posix.go
         0      510ms (flat, cum)  0.92% of Total
         .          .    156:
         .          .    157:// Internet sockets (TCP, UDP, IP)
         .          .    158:
         .          .    159:func internetSocket(net string, laddr, raddr sockaddr, deadline time.Time, sotype, proto int, mode string, cancel <-chan struct{}) (fd *netFD, err error) {
         .          .    160:	family, ipv6only := favoriteAddrFamily(net, laddr, raddr, mode)
         .      510ms    161:	return socket(net, family, sotype, proto, ipv6only, laddr, raddr, deadline, cancel)
         .          .    162:}
         .          .    163:
         .          .    164:func ipToSockaddr(family int, ip IP, port int, zone string) (syscall.Sockaddr, error) {
         .          .    165:	switch family {
         .          .    166:	case syscall.AF_INET:
ROUTINE ======================== net.ipEmptyString in /home/isucon/.local/go/src/net/ip.go
         0      260ms (flat, cum)  0.47% of Total
         .          .    316:// an empty string when ip is unset.
         .          .    317:func ipEmptyString(ip IP) string {
         .          .    318:	if len(ip) == 0 {
         .          .    319:		return ""
         .          .    320:	}
         .      260ms    321:	return ip.String()
         .          .    322:}
         .          .    323:
         .          .    324:// MarshalText implements the encoding.TextMarshaler interface.
         .          .    325:// The encoding is the same as returned by String.
         .          .    326:func (ip IP) MarshalText() ([]byte, error) {
ROUTINE ======================== net.ipToSockaddr in /home/isucon/.local/go/src/net/ipsock_posix.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    181:			ip = IPv6zero
         .          .    182:		}
         .          .    183:		// IPv4 callers use 0.0.0.0 to mean "announce on any available address".
         .          .    184:		// In IPv6 mode, Linux treats that as meaning "announce on 0.0.0.0",
         .          .    185:		// which it refuses to do.  Rewrite to the IPv6 unspecified address.
         .       10ms    186:		if ip.Equal(IPv4zero) {
         .          .    187:			ip = IPv6zero
         .          .    188:		}
         .          .    189:		if ip = ip.To16(); ip == nil {
         .          .    190:			return nil, &AddrError{Err: "non-IPv6 address", Addr: ip.String()}
         .          .    191:		}
ROUTINE ======================== net.lookupIP in /home/isucon/.local/go/src/net/lookup_unix.go
         0      210ms (flat, cum)  0.38% of Total
         .          .     60:	}
         .          .     61:	return goLookupHostOrder(host, order)
         .          .     62:}
         .          .     63:
         .          .     64:func lookupIP(host string) (addrs []IPAddr, err error) {
         .       20ms     65:	order := systemConf().hostLookupOrder(host)
         .          .     66:	if order == hostLookupCgo {
         .          .     67:		if addrs, err, ok := cgoLookupIP(host); ok {
         .          .     68:			return addrs, err
         .          .     69:		}
         .          .     70:		// cgo not available (or netgo); fall back to Go's DNS resolver
         .          .     71:		order = hostLookupFilesDNS
         .          .     72:	}
         .      190ms     73:	return goLookupIPOrder(host, order)
         .          .     74:}
         .          .     75:
         .          .     76:func lookupPort(network, service string) (int, error) {
         .          .     77:	if systemConf().canUseCgo() {
         .          .     78:		if port, err, ok := cgoLookupPort(network, service); ok {
ROUTINE ======================== net.lookupIPDeadline in /home/isucon/.local/go/src/net/lookup.go
         0      210ms (flat, cum)  0.38% of Total
         .          .     86:}
         .          .     87:
         .          .     88:// lookupIPDeadline looks up a hostname with a deadline.
         .          .     89:func lookupIPDeadline(host string, deadline time.Time) (addrs []IPAddr, err error) {
         .          .     90:	if deadline.IsZero() {
         .      210ms     91:		return lookupIPMerge(host)
         .          .     92:	}
         .          .     93:
         .          .     94:	// We could push the deadline down into the name resolution
         .          .     95:	// functions.  However, the most commonly used implementation
         .          .     96:	// calls getaddrinfo, which has no timeout.
ROUTINE ======================== net.lookupIPMerge in /home/isucon/.local/go/src/net/lookup.go
         0      210ms (flat, cum)  0.38% of Total
         .          .     64:// host, only one lookup is in-flight at a time. The returned memory
         .          .     65:// is always owned by the caller.
         .          .     66:func lookupIPMerge(host string) (addrs []IPAddr, err error) {
         .          .     67:	addrsi, err, shared := lookupGroup.Do(host, func() (interface{}, error) {
         .          .     68:		return testHookLookupIP(lookupIP, host)
         .      210ms     69:	})
         .          .     70:	return lookupIPReturn(addrsi, err, shared)
         .          .     71:}
         .          .     72:
         .          .     73:// lookupIPReturn turns the return values from singleflight.Do into
         .          .     74:// the return values from LookupIP.
ROUTINE ======================== net.lookupIPMerge.func1 in /home/isucon/.local/go/src/net/lookup.go
         0      210ms (flat, cum)  0.38% of Total
         .          .     63:// lookupIPMerge wraps lookupIP, but makes sure that for any given
         .          .     64:// host, only one lookup is in-flight at a time. The returned memory
         .          .     65:// is always owned by the caller.
         .          .     66:func lookupIPMerge(host string) (addrs []IPAddr, err error) {
         .          .     67:	addrsi, err, shared := lookupGroup.Do(host, func() (interface{}, error) {
         .      210ms     68:		return testHookLookupIP(lookupIP, host)
         .          .     69:	})
         .          .     70:	return lookupIPReturn(addrsi, err, shared)
         .          .     71:}
         .          .     72:
         .          .     73:// lookupIPReturn turns the return values from singleflight.Do into
ROUTINE ======================== net.lookupStaticHost in /home/isucon/.local/go/src/net/hosts.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    105:	defer hosts.Unlock()
         .          .    106:	readHosts()
         .          .    107:	if len(hosts.byName) != 0 {
         .          .    108:		// TODO(jbd,bradfitz): avoid this alloc if host is already all lowercase?
         .          .    109:		// or linear scan the byName map if it's small enough?
         .       10ms    110:		lowerHost := []byte(host)
         .          .    111:		lowerASCIIBytes(lowerHost)
         .          .    112:		if ips, ok := hosts.byName[absDomainName(lowerHost)]; ok {
         .          .    113:			return ips
         .          .    114:		}
         .          .    115:	}
ROUTINE ======================== net.newTCPConn in /home/isucon/.local/go/src/net/tcpsock_posix.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     45:type TCPConn struct {
         .          .     46:	conn
         .          .     47:}
         .          .     48:
         .          .     49:func newTCPConn(fd *netFD) *TCPConn {
         .       10ms     50:	c := &TCPConn{conn{fd}}
         .          .     51:	setNoDelay(c.fd, true)
         .          .     52:	return c
         .          .     53:}
         .          .     54:
         .          .     55:// ReadFrom implements the io.ReaderFrom ReadFrom method.
ROUTINE ======================== net.resolveAddrList in /home/isucon/.local/go/src/net/dial.go
         0      240ms (flat, cum)  0.43% of Total
         .          .    153:		if err != nil {
         .          .    154:			return nil, err
         .          .    155:		}
         .          .    156:		return addrList{addr}, nil
         .          .    157:	}
         .      240ms    158:	return internetAddrList(afnet, addr, deadline)
         .          .    159:}
         .          .    160:
         .          .    161:// Dial connects to the address on the named network.
         .          .    162://
         .          .    163:// Known networks are "tcp", "tcp4" (IPv4-only), "tcp6" (IPv6-only),
ROUTINE ======================== net.runtime_pollClose in /home/isucon/.local/go/src/runtime/netpoll.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    120:		throw("netpollClose: blocked write on closing descriptor")
         .          .    121:	}
         .          .    122:	if pd.rg != 0 && pd.rg != pdReady {
         .          .    123:		throw("netpollClose: blocked read on closing descriptor")
         .          .    124:	}
         .       30ms    125:	netpollclose(uintptr(pd.fd))
         .          .    126:	pollcache.free(pd)
         .          .    127:}
         .          .    128:
         .          .    129:func (c *pollCache) free(pd *pollDesc) {
         .          .    130:	lock(&c.lock)
ROUTINE ======================== net.runtime_pollOpen in /home/isucon/.local/go/src/runtime/netpoll.go
         0       60ms (flat, cum)  0.11% of Total
         .          .     87:	return atomic.Load(&netpollInited) != 0
         .          .     88:}
         .          .     89:
         .          .     90://go:linkname net_runtime_pollOpen net.runtime_pollOpen
         .          .     91:func net_runtime_pollOpen(fd uintptr) (*pollDesc, int) {
         .       10ms     92:	pd := pollcache.alloc()
         .          .     93:	lock(&pd.lock)
         .          .     94:	if pd.wg != 0 && pd.wg != pdReady {
         .          .     95:		throw("netpollOpen: blocked write on free descriptor")
         .          .     96:	}
         .          .     97:	if pd.rg != 0 && pd.rg != pdReady {
         .          .     98:		throw("netpollOpen: blocked read on free descriptor")
         .          .     99:	}
         .          .    100:	pd.fd = fd
         .          .    101:	pd.closing = false
         .          .    102:	pd.seq++
         .          .    103:	pd.rg = 0
         .          .    104:	pd.rd = 0
         .          .    105:	pd.wg = 0
         .          .    106:	pd.wd = 0
         .       10ms    107:	unlock(&pd.lock)
         .          .    108:
         .          .    109:	var errno int32
         .       40ms    110:	errno = netpollopen(fd, pd)
         .          .    111:	return pd, int(errno)
         .          .    112:}
         .          .    113:
         .          .    114://go:linkname net_runtime_pollClose net.runtime_pollClose
         .          .    115:func net_runtime_pollClose(pd *pollDesc) {
ROUTINE ======================== net.runtime_pollReset in /home/isucon/.local/go/src/runtime/netpoll.go
      20ms       20ms (flat, cum) 0.036% of Total
         .          .    133:	unlock(&c.lock)
         .          .    134:}
         .          .    135:
         .          .    136://go:linkname net_runtime_pollReset net.runtime_pollReset
         .          .    137:func net_runtime_pollReset(pd *pollDesc, mode int) int {
      20ms       20ms    138:	err := netpollcheckerr(pd, int32(mode))
         .          .    139:	if err != 0 {
         .          .    140:		return err
         .          .    141:	}
         .          .    142:	if mode == 'r' {
         .          .    143:		pd.rg = 0
ROUTINE ======================== net.runtime_pollUnblock in /home/isucon/.local/go/src/runtime/netpoll.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    254:		throw("netpollUnblock: already closing")
         .          .    255:	}
         .          .    256:	pd.closing = true
         .          .    257:	pd.seq++
         .          .    258:	var rg, wg *g
         .       20ms    259:	atomicstorep(unsafe.Pointer(&rg), nil) // full memory barrier between store to closing and read of rg/wg in netpollunblock
         .          .    260:	rg = netpollunblock(pd, 'r', false)
         .          .    261:	wg = netpollunblock(pd, 'w', false)
         .          .    262:	if pd.rt.f != nil {
         .          .    263:		deltimer(&pd.rt)
         .          .    264:		pd.rt.f = nil
ROUTINE ======================== net.runtime_pollWait in /home/isucon/.local/go/src/runtime/netpoll.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .    146:	}
         .          .    147:	return 0
         .          .    148:}
         .          .    149:
         .          .    150://go:linkname net_runtime_pollWait net.runtime_pollWait
      10ms       10ms    151:func net_runtime_pollWait(pd *pollDesc, mode int) int {
         .          .    152:	err := netpollcheckerr(pd, int32(mode))
         .          .    153:	if err != 0 {
         .          .    154:		return err
         .          .    155:	}
         .          .    156:	// As for now only Solaris uses level-triggered IO.
         .          .    157:	if GOOS == "solaris" {
         .          .    158:		netpollarm(pd, mode)
         .          .    159:	}
         .       10ms    160:	for !netpollblock(pd, int32(mode), false) {
         .          .    161:		err = netpollcheckerr(pd, int32(mode))
         .          .    162:		if err != 0 {
         .          .    163:			return err
         .          .    164:		}
         .          .    165:		// Can happen if timeout has fired and unblocked us,
ROUTINE ======================== net.sendFile in /home/isucon/.local/go/src/net/sendfile_linux.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     46:	for remain > 0 {
         .          .     47:		n := maxSendfileSize
         .          .     48:		if int64(n) > remain {
         .          .     49:			n = int(remain)
         .          .     50:		}
         .       20ms     51:		n, err1 := syscall.Sendfile(dst, src, nil, n)
         .          .     52:		if n > 0 {
         .          .     53:			written += int64(n)
         .          .     54:			remain -= int64(n)
         .          .     55:		}
         .          .     56:		if n == 0 && err1 == nil {
ROUTINE ======================== net.setDefaultSockopts in /home/isucon/.local/go/src/net/sockopt_linux.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     15:		// is otherwise.  Note that some operating systems
         .          .     16:		// never admit this option.
         .          .     17:		syscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, boolint(ipv6only))
         .          .     18:	}
         .          .     19:	// Allow broadcast.
         .       20ms     20:	return os.NewSyscallError("setsockopt", syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1))
         .          .     21:}
         .          .     22:
         .          .     23:func setDefaultListenerSockopts(s int) error {
         .          .     24:	// Allow reuse of recently-used addresses.
         .          .     25:	return os.NewSyscallError("setsockopt", syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1))
ROUTINE ======================== net.setKeepAlive in /home/isucon/.local/go/src/net/sockopt_posix.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    119:func setKeepAlive(fd *netFD, keepalive bool) error {
         .          .    120:	if err := fd.incref(); err != nil {
         .          .    121:		return err
         .          .    122:	}
         .          .    123:	defer fd.decref()
         .       20ms    124:	return os.NewSyscallError("setsockopt", syscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_KEEPALIVE, boolint(keepalive)))
         .          .    125:}
         .          .    126:
         .          .    127:func setLinger(fd *netFD, sec int) error {
         .          .    128:	var l syscall.Linger
         .          .    129:	if sec >= 0 {
ROUTINE ======================== net.setKeepAlivePeriod in /home/isucon/.local/go/src/net/tcpsockopt_unix.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     21:	d += (time.Second - time.Nanosecond)
         .          .     22:	secs := int(d.Seconds())
         .          .     23:	if err := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_TCP, syscall.TCP_KEEPINTVL, secs); err != nil {
         .          .     24:		return os.NewSyscallError("setsockopt", err)
         .          .     25:	}
         .       10ms     26:	return os.NewSyscallError("setsockopt", syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_TCP, syscall.TCP_KEEPIDLE, secs))
         .          .     27:}
ROUTINE ======================== net.sockaddrToTCP in /home/isucon/.local/go/src/net/tcpsock_posix.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .     12:	"syscall"
         .          .     13:	"time"
         .          .     14:)
         .          .     15:
         .          .     16:func sockaddrToTCP(sa syscall.Sockaddr) Addr {
      10ms       10ms     17:	switch sa := sa.(type) {
         .          .     18:	case *syscall.SockaddrInet4:
         .       10ms     19:		return &TCPAddr{IP: sa.Addr[0:], Port: sa.Port}
         .          .     20:	case *syscall.SockaddrInet6:
         .          .     21:		return &TCPAddr{IP: sa.Addr[0:], Port: sa.Port, Zone: zoneToString(int(sa.ZoneId))}
         .          .     22:	}
         .          .     23:	return nil
         .          .     24:}
ROUTINE ======================== net.socket in /home/isucon/.local/go/src/net/sock_posix.go
         0      510ms (flat, cum)  0.92% of Total
         .          .     33:}
         .          .     34:
         .          .     35:// socket returns a network file descriptor that is ready for
         .          .     36:// asynchronous I/O using the network poller.
         .          .     37:func socket(net string, family, sotype, proto int, ipv6only bool, laddr, raddr sockaddr, deadline time.Time, cancel <-chan struct{}) (fd *netFD, err error) {
         .       60ms     38:	s, err := sysSocket(family, sotype, proto)
         .          .     39:	if err != nil {
         .          .     40:		return nil, err
         .          .     41:	}
         .       20ms     42:	if err = setDefaultSockopts(s, family, sotype, ipv6only); err != nil {
         .          .     43:		closeFunc(s)
         .          .     44:		return nil, err
         .          .     45:	}
         .       10ms     46:	if fd, err = newFD(s, family, sotype, net); err != nil {
         .          .     47:		closeFunc(s)
         .          .     48:		return nil, err
         .          .     49:	}
         .          .     50:
         .          .     51:	// This function makes a network file descriptor for the
         .          .     52:	// following applications:
         .          .     53:	//
         .          .     54:	// - An endpoint holder that opens a passive stream
         .          .     55:	//   connection, known as a stream listener
         .          .     56:	//
         .          .     57:	// - An endpoint holder that opens a destination-unspecific
         .          .     58:	//   datagram connection, known as a datagram listener
         .          .     59:	//
         .          .     60:	// - An endpoint holder that opens an active stream or a
         .          .     61:	//   destination-specific datagram connection, known as a
         .          .     62:	//   dialer
         .          .     63:	//
         .          .     64:	// - An endpoint holder that opens the other connection, such
         .          .     65:	//   as talking to the protocol stack inside the kernel
         .          .     66:	//
         .          .     67:	// For stream and datagram listeners, they will only require
         .          .     68:	// named sockets, so we can assume that it's just a request
         .          .     69:	// from stream or datagram listeners when laddr is not nil but
         .          .     70:	// raddr is nil. Otherwise we assume it's just for dialers or
         .          .     71:	// the other connection holders.
         .          .     72:
         .          .     73:	if laddr != nil && raddr == nil {
         .          .     74:		switch sotype {
         .          .     75:		case syscall.SOCK_STREAM, syscall.SOCK_SEQPACKET:
         .          .     76:			if err := fd.listenStream(laddr, listenerBacklog); err != nil {
         .          .     77:				fd.Close()
         .          .     78:				return nil, err
         .          .     79:			}
         .          .     80:			return fd, nil
         .          .     81:		case syscall.SOCK_DGRAM:
         .          .     82:			if err := fd.listenDatagram(laddr); err != nil {
         .          .     83:				fd.Close()
         .          .     84:				return nil, err
         .          .     85:			}
         .          .     86:			return fd, nil
         .          .     87:		}
         .          .     88:	}
         .      390ms     89:	if err := fd.dial(laddr, raddr, deadline, cancel); err != nil {
         .       30ms     90:		fd.Close()
         .          .     91:		return nil, err
         .          .     92:	}
         .          .     93:	return fd, nil
         .          .     94:}
         .          .     95:
ROUTINE ======================== net.sortByRFC6724 in /home/isucon/.local/go/src/net/addrselect.go
         0      180ms (flat, cum)  0.32% of Total
         .          .     12:
         .          .     13:func sortByRFC6724(addrs []IPAddr) {
         .          .     14:	if len(addrs) < 2 {
         .          .     15:		return
         .          .     16:	}
         .      180ms     17:	sortByRFC6724withSrcs(addrs, srcAddrs(addrs))
         .          .     18:}
         .          .     19:
         .          .     20:func sortByRFC6724withSrcs(addrs []IPAddr, srcs []IP) {
         .          .     21:	if len(addrs) != len(srcs) {
         .          .     22:		panic("internal error")
ROUTINE ======================== net.srcAddrs in /home/isucon/.local/go/src/net/addrselect.go
      10ms      180ms (flat, cum)  0.32% of Total
         .          .     37:
         .          .     38:// srcsAddrs tries to UDP-connect to each address to see if it has a
         .          .     39:// route. (This doesn't send any packets). The destination port
         .          .     40:// number is irrelevant.
         .          .     41:func srcAddrs(addrs []IPAddr) []IP {
         .       10ms     42:	srcs := make([]IP, len(addrs))
         .          .     43:	dst := UDPAddr{Port: 9}
         .          .     44:	for i := range addrs {
         .          .     45:		dst.IP = addrs[i].IP
         .          .     46:		dst.Zone = addrs[i].Zone
         .      140ms     47:		c, err := DialUDP("udp", nil, &dst)
      10ms       10ms     48:		if err == nil {
         .          .     49:			if src, ok := c.LocalAddr().(*UDPAddr); ok {
         .          .     50:				srcs[i] = src.IP
         .          .     51:			}
         .       20ms     52:			c.Close()
         .          .     53:		}
         .          .     54:	}
         .          .     55:	return srcs
         .          .     56:}
         .          .     57:
ROUTINE ======================== net.sysSocket in /home/isucon/.local/go/src/net/sock_cloexec.go
         0       60ms (flat, cum)  0.11% of Total
         .          .     15:)
         .          .     16:
         .          .     17:// Wrapper around the socket system call that marks the returned file
         .          .     18:// descriptor as nonblocking and close-on-exec.
         .          .     19:func sysSocket(family, sotype, proto int) (int, error) {
         .       60ms     20:	s, err := socketFunc(family, sotype|syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC, proto)
         .          .     21:	// On Linux the SOCK_NONBLOCK and SOCK_CLOEXEC flags were
         .          .     22:	// introduced in 2.6.27 kernel and on FreeBSD both flags were
         .          .     23:	// introduced in 10 kernel. If we get an EINVAL error on Linux
         .          .     24:	// or EPROTONOSUPPORT error on FreeBSD, fall back to using
         .          .     25:	// socket without them.
ROUTINE ======================== net.uitoa in /home/isucon/.local/go/src/net/parse.go
         0      240ms (flat, cum)  0.43% of Total
         .          .    211:		i--
         .          .    212:		val = q
         .          .    213:	}
         .          .    214:	// val < 10
         .          .    215:	buf[i] = byte('0' + val)
         .      240ms    216:	return string(buf[i:])
         .          .    217:}
         .          .    218:
         .          .    219:// Convert i to a hexadecimal string. Leading zeros are not printed.
         .          .    220:func appendHex(dst []byte, i uint32) []byte {
         .          .    221:	if i == 0 {
ROUTINE ======================== net/http.(*Cookie).String in /home/isucon/.local/go/src/net/http/cookie.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    142:		return ""
         .          .    143:	}
         .          .    144:	var b bytes.Buffer
         .          .    145:	fmt.Fprintf(&b, "%s=%s", sanitizeCookieName(c.Name), sanitizeCookieValue(c.Value))
         .          .    146:	if len(c.Path) > 0 {
         .       10ms    147:		fmt.Fprintf(&b, "; Path=%s", sanitizeCookiePath(c.Path))
         .          .    148:	}
         .          .    149:	if len(c.Domain) > 0 {
         .          .    150:		if validCookieDomain(c.Domain) {
         .          .    151:			// A c.Domain containing illegal characters is not
         .          .    152:			// sanitized but simply dropped which turns the cookie
ROUTINE ======================== net/http.(*Dir).Open in <autogenerated>
         0       20ms (flat, cum) 0.036% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== net/http.(*Request).Cookie in /home/isucon/.local/go/src/net/http/request.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    271:var ErrNoCookie = errors.New("http: named cookie not present")
         .          .    272:
         .          .    273:// Cookie returns the named cookie provided in the request or
         .          .    274:// ErrNoCookie if not found.
         .          .    275:func (r *Request) Cookie(name string) (*Cookie, error) {
         .       10ms    276:	for _, c := range readCookies(r.Header, name) {
         .          .    277:		return c, nil
         .          .    278:	}
         .          .    279:	return nil, ErrNoCookie
         .          .    280:}
         .          .    281:
ROUTINE ======================== net/http.(*Request).FormValue in /home/isucon/.local/go/src/net/http/request.go
         0       90ms (flat, cum)  0.16% of Total
         .          .   1010:// If key is not present, FormValue returns the empty string.
         .          .   1011:// To access multiple values of the same key, call ParseForm and
         .          .   1012:// then inspect Request.Form directly.
         .          .   1013:func (r *Request) FormValue(key string) string {
         .          .   1014:	if r.Form == nil {
         .       90ms   1015:		r.ParseMultipartForm(defaultMaxMemory)
         .          .   1016:	}
         .          .   1017:	if vs := r.Form[key]; len(vs) > 0 {
         .          .   1018:		return vs[0]
         .          .   1019:	}
         .          .   1020:	return ""
ROUTINE ======================== net/http.(*Request).ParseMultipartForm in /home/isucon/.local/go/src/net/http/request.go
         0       90ms (flat, cum)  0.16% of Total
         .          .    984:	}
         .          .    985:	if r.MultipartForm != nil {
         .          .    986:		return nil
         .          .    987:	}
         .          .    988:
         .       10ms    989:	mr, err := r.multipartReader()
         .          .    990:	if err != nil {
         .          .    991:		return err
         .          .    992:	}
         .          .    993:
         .       80ms    994:	f, err := mr.ReadForm(maxMemory)
         .          .    995:	if err != nil {
         .          .    996:		return err
         .          .    997:	}
         .          .    998:	for k, v := range f.Value {
         .          .    999:		r.Form[k] = append(r.Form[k], v...)
ROUTINE ======================== net/http.(*Request).multipartReader in /home/isucon/.local/go/src/net/http/request.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    330:func (r *Request) multipartReader() (*multipart.Reader, error) {
         .          .    331:	v := r.Header.Get("Content-Type")
         .          .    332:	if v == "" {
         .          .    333:		return nil, ErrNotMultipart
         .          .    334:	}
         .       10ms    335:	d, params, err := mime.ParseMediaType(v)
         .          .    336:	if err != nil || d != "multipart/form-data" {
         .          .    337:		return nil, ErrNotMultipart
         .          .    338:	}
         .          .    339:	boundary, ok := params["boundary"]
         .          .    340:	if !ok {
ROUTINE ======================== net/http.(*ServeMux).ServeHTTP in /home/isucon/.local/go/src/net/http/server.go
         0     46.70s (flat, cum) 83.92% of Total
         .          .   1905:		}
         .          .   1906:		w.WriteHeader(StatusBadRequest)
         .          .   1907:		return
         .          .   1908:	}
         .          .   1909:	h, _ := mux.Handler(r)
         .     46.70s   1910:	h.ServeHTTP(w, r)
         .          .   1911:}
         .          .   1912:
         .          .   1913:// Handle registers the handler for the given pattern.
         .          .   1914:// If a handler already exists for pattern, Handle panics.
         .          .   1915:func (mux *ServeMux) Handle(pattern string, handler Handler) {
ROUTINE ======================== net/http.(*Server).Serve in /home/isucon/.local/go/src/net/http/server.go
         0      380ms (flat, cum)  0.68% of Total
         .          .   2112:	var tempDelay time.Duration // how long to sleep on accept failure
         .          .   2113:	if err := srv.setupHTTP2(); err != nil {
         .          .   2114:		return err
         .          .   2115:	}
         .          .   2116:	for {
         .      370ms   2117:		rw, e := l.Accept()
         .          .   2118:		if e != nil {
         .          .   2119:			if ne, ok := e.(net.Error); ok && ne.Temporary() {
         .          .   2120:				if tempDelay == 0 {
         .          .   2121:					tempDelay = 5 * time.Millisecond
         .          .   2122:				} else {
         .          .   2123:					tempDelay *= 2
         .          .   2124:				}
         .          .   2125:				if max := 1 * time.Second; tempDelay > max {
         .          .   2126:					tempDelay = max
         .          .   2127:				}
         .          .   2128:				srv.logf("http: Accept error: %v; retrying in %v", e, tempDelay)
         .          .   2129:				time.Sleep(tempDelay)
         .          .   2130:				continue
         .          .   2131:			}
         .          .   2132:			return e
         .          .   2133:		}
         .          .   2134:		tempDelay = 0
         .          .   2135:		c := srv.newConn(rw)
         .          .   2136:		c.setState(c.rwc, StateNew) // before Serve can return
         .       10ms   2137:		go c.serve()
         .          .   2138:	}
         .          .   2139:}
         .          .   2140:
         .          .   2141:func (s *Server) doKeepAlives() bool {
         .          .   2142:	return atomic.LoadInt32(&s.disableKeepAlives) == 0
ROUTINE ======================== net/http.(*body).Read in /home/isucon/.local/go/src/net/http/transfer.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .    634:// ResponseWriter.
         .          .    635:var ErrBodyReadAfterClose = errors.New("http: invalid Read on closed Body")
         .          .    636:
         .          .    637:func (b *body) Read(p []byte) (n int, err error) {
         .          .    638:	b.mu.Lock()
         .       10ms    639:	defer b.mu.Unlock()
         .          .    640:	if b.closed {
         .          .    641:		return 0, ErrBodyReadAfterClose
         .          .    642:	}
      10ms       10ms    643:	return b.readLocked(p)
         .          .    644:}
         .          .    645:
         .          .    646:// Must hold b.mu.
         .          .    647:func (b *body) readLocked(p []byte) (n int, err error) {
         .          .    648:	if b.sawEOF {
ROUTINE ======================== net/http.(*chunkWriter).Write in /home/isucon/.local/go/src/net/http/server.go
         0      600ms (flat, cum)  1.08% of Total
         .          .    249:	colonSpace = []byte(": ")
         .          .    250:)
         .          .    251:
         .          .    252:func (cw *chunkWriter) Write(p []byte) (n int, err error) {
         .          .    253:	if !cw.wroteHeader {
         .       20ms    254:		cw.writeHeader(p)
         .          .    255:	}
         .          .    256:	if cw.res.req.Method == "HEAD" {
         .          .    257:		// Eat writes.
         .          .    258:		return len(p), nil
         .          .    259:	}
         .          .    260:	if cw.chunking {
         .          .    261:		_, err = fmt.Fprintf(cw.res.conn.bufw, "%x\r\n", len(p))
         .          .    262:		if err != nil {
         .          .    263:			cw.res.conn.rwc.Close()
         .          .    264:			return
         .          .    265:		}
         .          .    266:	}
         .      580ms    267:	n, err = cw.res.conn.bufw.Write(p)
         .          .    268:	if cw.chunking && err == nil {
         .          .    269:		_, err = cw.res.conn.bufw.Write(crlf)
         .          .    270:	}
         .          .    271:	if err != nil {
         .          .    272:		cw.res.conn.rwc.Close()
ROUTINE ======================== net/http.(*chunkWriter).close in /home/isucon/.local/go/src/net/http/server.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    281:	cw.res.conn.bufw.Flush()
         .          .    282:}
         .          .    283:
         .          .    284:func (cw *chunkWriter) close() {
         .          .    285:	if !cw.wroteHeader {
         .       10ms    286:		cw.writeHeader(nil)
         .          .    287:	}
         .          .    288:	if cw.chunking {
         .          .    289:		bw := cw.res.conn.bufw // conn's bufio writer
         .          .    290:		// zero chunk to mark EOF
         .          .    291:		bw.WriteString("0\r\n")
ROUTINE ======================== net/http.(*chunkWriter).flush in /home/isucon/.local/go/src/net/http/server.go
         0       50ms (flat, cum)  0.09% of Total
         .          .    274:	return
         .          .    275:}
         .          .    276:
         .          .    277:func (cw *chunkWriter) flush() {
         .          .    278:	if !cw.wroteHeader {
         .       10ms    279:		cw.writeHeader(nil)
         .          .    280:	}
         .       40ms    281:	cw.res.conn.bufw.Flush()
         .          .    282:}
         .          .    283:
         .          .    284:func (cw *chunkWriter) close() {
         .          .    285:	if !cw.wroteHeader {
         .          .    286:		cw.writeHeader(nil)
ROUTINE ======================== net/http.(*chunkWriter).writeHeader in /home/isucon/.local/go/src/net/http/server.go
         0       40ms (flat, cum) 0.072% of Total
         .          .   1026:	code := w.status
         .          .   1027:	if bodyAllowedForStatus(code) {
         .          .   1028:		// If no content type, apply sniffing algorithm to body.
         .          .   1029:		_, haveType := header["Content-Type"]
         .          .   1030:		if !haveType && !hasTE {
         .       10ms   1031:			setHeader.contentType = DetectContentType(p)
         .          .   1032:		}
         .          .   1033:	} else {
         .          .   1034:		for _, k := range suppressedHeaders(code) {
         .          .   1035:			delHeader(k)
         .          .   1036:		}
         .          .   1037:	}
         .          .   1038:
         .          .   1039:	if _, ok := header["Date"]; !ok {
         .       10ms   1040:		setHeader.date = appendTime(cw.res.dateBuf[:0], time.Now())
         .          .   1041:	}
         .          .   1042:
         .          .   1043:	if hasCL && hasTE && te != "identity" {
         .          .   1044:		// TODO: return an error if WriteHeader gets a return parameter
         .          .   1045:		// For now just ignore the Content-Length.
         .          .   1046:		w.conn.server.logf("http: WriteHeader called with both Transfer-Encoding of %q and a Content-Length of %d",
         .          .   1047:			te, w.contentLength)
         .          .   1048:		delHeader("Content-Length")
         .          .   1049:		hasCL = false
         .          .   1050:	}
         .          .   1051:
         .          .   1052:	if w.req.Method == "HEAD" || !bodyAllowedForStatus(code) {
         .          .   1053:		// do nothing
         .          .   1054:	} else if code == StatusNoContent {
         .          .   1055:		delHeader("Transfer-Encoding")
         .          .   1056:	} else if hasCL {
         .          .   1057:		delHeader("Transfer-Encoding")
         .          .   1058:	} else if w.req.ProtoAtLeast(1, 1) {
         .          .   1059:		// HTTP/1.1 or greater: Transfer-Encoding has been set to identity,  and no
         .          .   1060:		// content-length has been provided. The connection must be closed after the
         .          .   1061:		// reply is written, and no chunking is to be done. This is the setup
         .          .   1062:		// recommended in the Server-Sent Events candidate recommendation 11,
         .          .   1063:		// section 8.
         .          .   1064:		if hasTE && te == "identity" {
         .          .   1065:			cw.chunking = false
         .          .   1066:			w.closeAfterReply = true
         .          .   1067:		} else {
         .          .   1068:			// HTTP/1.1 or greater: use chunked transfer encoding
         .          .   1069:			// to avoid closing the connection at EOF.
         .          .   1070:			cw.chunking = true
         .          .   1071:			setHeader.transferEncoding = "chunked"
         .          .   1072:		}
         .          .   1073:	} else {
         .          .   1074:		// HTTP version < 1.1: cannot do chunked transfer
         .          .   1075:		// encoding and we don't know the Content-Length so
         .          .   1076:		// signal EOF by closing connection.
         .          .   1077:		w.closeAfterReply = true
         .          .   1078:		delHeader("Transfer-Encoding") // in case already set
         .          .   1079:	}
         .          .   1080:
         .          .   1081:	// Cannot use Content-Length with non-identity Transfer-Encoding.
         .          .   1082:	if cw.chunking {
         .          .   1083:		delHeader("Content-Length")
         .          .   1084:	}
         .          .   1085:	if !w.req.ProtoAtLeast(1, 0) {
         .          .   1086:		return
         .          .   1087:	}
         .          .   1088:
         .          .   1089:	if w.closeAfterReply && (!keepAlivesEnabled || !hasToken(cw.header.get("Connection"), "close")) {
         .          .   1090:		delHeader("Connection")
         .          .   1091:		if w.req.ProtoAtLeast(1, 1) {
         .          .   1092:			setHeader.connection = "close"
         .          .   1093:		}
         .          .   1094:	}
         .          .   1095:
         .       10ms   1096:	w.conn.bufw.WriteString(statusLine(w.req, code))
         .       10ms   1097:	cw.header.WriteSubset(w.conn.bufw, excludeHeader)
         .          .   1098:	setHeader.Write(w.conn.bufw)
         .          .   1099:	w.conn.bufw.Write(crlf)
         .          .   1100:}
         .          .   1101:
         .          .   1102:// foreachHeaderElement splits v according to the "#rule" construction
ROUTINE ======================== net/http.(*conn).close in /home/isucon/.local/go/src/net/http/server.go
         0      180ms (flat, cum)  0.32% of Total
         .          .   1319:	}
         .          .   1320:}
         .          .   1321:
         .          .   1322:// Close the connection.
         .          .   1323:func (c *conn) close() {
         .       10ms   1324:	c.finalFlush()
         .      170ms   1325:	c.rwc.Close()
         .          .   1326:}
         .          .   1327:
         .          .   1328:// rstAvoidanceDelay is the amount of time we sleep after closing the
         .          .   1329:// write side of a TCP connection before closing the entire socket.
         .          .   1330:// By sleeping, we increase the chances that the client sees our FIN
ROUTINE ======================== net/http.(*conn).finalFlush in /home/isucon/.local/go/src/net/http/server.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   1312:
         .          .   1313:	if c.bufw != nil {
         .          .   1314:		c.bufw.Flush()
         .          .   1315:		// Steal the bufio.Writer (~4KB worth of memory) and its associated
         .          .   1316:		// writer for a future connection.
         .       10ms   1317:		putBufioWriter(c.bufw)
         .          .   1318:		c.bufw = nil
         .          .   1319:	}
         .          .   1320:}
         .          .   1321:
         .          .   1322:// Close the connection.
ROUTINE ======================== net/http.(*conn).hijacked in /home/isucon/.local/go/src/net/http/server.go
      10ms      140ms (flat, cum)  0.25% of Total
         .          .    193:	// It is guarded by mu.
         .          .    194:	hijackedv bool
         .          .    195:}
         .          .    196:
         .          .    197:func (c *conn) hijacked() bool {
         .       20ms    198:	c.mu.Lock()
         .       50ms    199:	defer c.mu.Unlock()
      10ms       70ms    200:	return c.hijackedv
         .          .    201:}
         .          .    202:
         .          .    203:// c.mu must be held.
         .          .    204:func (c *conn) hijackLocked() (rwc net.Conn, buf *bufio.ReadWriter, err error) {
         .          .    205:	if c.hijackedv {
ROUTINE ======================== net/http.(*conn).readRequest in /home/isucon/.local/go/src/net/http/server.go
         0      320ms (flat, cum)  0.58% of Total
         .          .    700:	if c.lastMethod == "POST" {
         .          .    701:		// RFC 2616 section 4.1 tolerance for old buggy clients.
         .          .    702:		peek, _ := c.bufr.Peek(4) // ReadRequest will get err below
         .          .    703:		c.bufr.Discard(numLeadingCRorLF(peek))
         .          .    704:	}
         .      230ms    705:	req, err := readRequest(c.bufr, keepHostHeader)
         .          .    706:	c.mu.Unlock()
         .          .    707:	if err != nil {
         .          .    708:		if c.r.hitReadLimit() {
         .          .    709:			return nil, errTooLarge
         .          .    710:		}
         .          .    711:		return nil, err
         .          .    712:	}
         .       10ms    713:	c.lastMethod = req.Method
         .          .    714:	c.r.setInfiniteReadLimit()
         .          .    715:
         .          .    716:	hosts, haveHost := req.Header["Host"]
         .          .    717:	if req.ProtoAtLeast(1, 1) && (!haveHost || len(hosts) == 0) {
         .          .    718:		return nil, badRequestError("missing required Host header")
         .          .    719:	}
         .          .    720:	if len(hosts) > 1 {
         .          .    721:		return nil, badRequestError("too many Host headers")
         .          .    722:	}
         .          .    723:	if len(hosts) == 1 && !validHostHeader(hosts[0]) {
         .          .    724:		return nil, badRequestError("malformed Host header")
         .          .    725:	}
         .       10ms    726:	for k, vv := range req.Header {
         .       10ms    727:		if !validHeaderName(k) {
         .          .    728:			return nil, badRequestError("invalid header name")
         .          .    729:		}
         .          .    730:		for _, v := range vv {
         .          .    731:			if !validHeaderValue(v) {
         .          .    732:				return nil, badRequestError("invalid header value")
         .          .    733:			}
         .          .    734:		}
         .          .    735:	}
         .       10ms    736:	delete(req.Header, "Host")
         .          .    737:
         .          .    738:	req.RemoteAddr = c.remoteAddr
         .          .    739:	req.TLS = c.tlsState
         .          .    740:	if body, ok := req.Body.(*body); ok {
         .          .    741:		body.doEarlyClose = true
         .          .    742:	}
         .          .    743:
         .          .    744:	w = &response{
         .          .    745:		conn:          c,
         .          .    746:		req:           req,
         .          .    747:		reqBody:       req.Body,
         .          .    748:		handlerHeader: make(Header),
         .          .    749:		contentLength: -1,
         .          .    750:	}
         .          .    751:	w.cw.res = w
         .       50ms    752:	w.w = newBufioWriterSize(&w.cw, bufferBeforeChunkingSize)
         .          .    753:	return w, nil
         .          .    754:}
         .          .    755:
         .          .    756:func (w *response) Header() Header {
         .          .    757:	if w.cw.header == nil && w.wroteHeader && !w.cw.wroteHeader {
ROUTINE ======================== net/http.(*conn).serve in /home/isucon/.local/go/src/net/http/server.go
      20ms     47.56s (flat, cum) 85.46% of Total
         .          .   1379:
         .          .   1380:func (e badRequestError) Error() string { return "Bad Request: " + string(e) }
         .          .   1381:
         .          .   1382:// Serve a new connection.
         .          .   1383:func (c *conn) serve() {
      10ms      260ms   1384:	c.remoteAddr = c.rwc.RemoteAddr().String()
         .          .   1385:	defer func() {
         .          .   1386:		if err := recover(); err != nil {
         .          .   1387:			const size = 64 << 10
         .          .   1388:			buf := make([]byte, size)
         .          .   1389:			buf = buf[:runtime.Stack(buf, false)]
         .          .   1390:			c.server.logf("http: panic serving %v: %v\n%s", c.remoteAddr, err, buf)
         .          .   1391:		}
         .          .   1392:		if !c.hijacked() {
         .          .   1393:			c.close()
         .          .   1394:			c.setState(c.rwc, StateClosed)
         .          .   1395:		}
         .          .   1396:	}()
         .          .   1397:
         .          .   1398:	if tlsConn, ok := c.rwc.(*tls.Conn); ok {
         .          .   1399:		if d := c.server.ReadTimeout; d != 0 {
         .          .   1400:			c.rwc.SetReadDeadline(time.Now().Add(d))
         .          .   1401:		}
         .          .   1402:		if d := c.server.WriteTimeout; d != 0 {
         .          .   1403:			c.rwc.SetWriteDeadline(time.Now().Add(d))
         .          .   1404:		}
         .          .   1405:		if err := tlsConn.Handshake(); err != nil {
         .          .   1406:			c.server.logf("http: TLS handshake error from %s: %v", c.rwc.RemoteAddr(), err)
         .          .   1407:			return
         .          .   1408:		}
         .          .   1409:		c.tlsState = new(tls.ConnectionState)
         .          .   1410:		*c.tlsState = tlsConn.ConnectionState()
         .          .   1411:		if proto := c.tlsState.NegotiatedProtocol; validNPN(proto) {
         .          .   1412:			if fn := c.server.TLSNextProto[proto]; fn != nil {
         .          .   1413:				h := initNPNRequest{tlsConn, serverHandler{c.server}}
         .          .   1414:				fn(c.server, tlsConn, h)
         .          .   1415:			}
         .          .   1416:			return
         .          .   1417:		}
         .          .   1418:	}
         .          .   1419:
         .       10ms   1420:	c.r = &connReader{r: c.rwc}
         .       20ms   1421:	c.bufr = newBufioReader(c.r)
         .       20ms   1422:	c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4<<10)
         .          .   1423:
         .          .   1424:	for {
         .      320ms   1425:		w, err := c.readRequest()
         .          .   1426:		if c.r.remain != c.server.initialReadLimitSize() {
         .          .   1427:			// If we read any bytes off the wire, we're active.
         .          .   1428:			c.setState(c.rwc, StateActive)
         .          .   1429:		}
         .          .   1430:		if err != nil {
         .          .   1431:			if err == errTooLarge {
         .          .   1432:				// Their HTTP client may or may not be
         .          .   1433:				// able to read this if we're
         .          .   1434:				// responding to them and hanging up
         .          .   1435:				// while they're still writing their
         .          .   1436:				// request.  Undefined behavior.
         .          .   1437:				io.WriteString(c.rwc, "HTTP/1.1 431 Request Header Fields Too Large\r\nContent-Type: text/plain\r\nConnection: close\r\n\r\n431 Request Header Fields Too Large")
         .          .   1438:				c.closeWriteAndWait()
         .          .   1439:				return
         .          .   1440:			}
         .          .   1441:			if err == io.EOF {
         .          .   1442:				return // don't reply
         .          .   1443:			}
         .          .   1444:			if neterr, ok := err.(net.Error); ok && neterr.Timeout() {
         .          .   1445:				return // don't reply
         .          .   1446:			}
         .          .   1447:			var publicErr string
         .          .   1448:			if v, ok := err.(badRequestError); ok {
         .          .   1449:				publicErr = ": " + string(v)
         .          .   1450:			}
         .          .   1451:			io.WriteString(c.rwc, "HTTP/1.1 400 Bad Request\r\nContent-Type: text/plain\r\nConnection: close\r\n\r\n400 Bad Request"+publicErr)
         .          .   1452:			return
         .          .   1453:		}
         .          .   1454:
         .          .   1455:		// Expect 100 Continue support
         .          .   1456:		req := w.req
         .          .   1457:		if req.expectsContinue() {
         .          .   1458:			if req.ProtoAtLeast(1, 1) && req.ContentLength != 0 {
         .          .   1459:				// Wrap the Body reader with one that replies on the connection
         .          .   1460:				req.Body = &expectContinueReader{readCloser: req.Body, resp: w}
         .          .   1461:			}
      10ms       10ms   1462:		} else if req.Header.get("Expect") != "" {
         .          .   1463:			w.sendExpectationFailed()
         .          .   1464:			return
         .          .   1465:		}
         .          .   1466:
         .          .   1467:		// HTTP cannot have multiple simultaneous active requests.[*]
         .          .   1468:		// Until the server replies to this request, it can't read another,
         .          .   1469:		// so we might as well run the handler in this goroutine.
         .          .   1470:		// [*] Not strictly true: HTTP pipelining.  We could let them all process
         .          .   1471:		// in parallel even if their responses need to be serialized.
         .     46.70s   1472:		serverHandler{c.server}.ServeHTTP(w, w.req)
         .          .   1473:		if c.hijacked() {
         .          .   1474:			return
         .          .   1475:		}
         .       30ms   1476:		w.finishRequest()
         .          .   1477:		if !w.shouldReuseConnection() {
         .          .   1478:			if w.requestBodyLimitHit || w.closedRequestBodyEarly() {
         .          .   1479:				c.closeWriteAndWait()
         .          .   1480:			}
         .      190ms   1481:			return
         .          .   1482:		}
         .          .   1483:		c.setState(c.rwc, StateIdle)
         .          .   1484:	}
         .          .   1485:}
         .          .   1486:
ROUTINE ======================== net/http.(*conn).serve.func1 in /home/isucon/.local/go/src/net/http/server.go
      10ms      190ms (flat, cum)  0.34% of Total
         .          .   1380:func (e badRequestError) Error() string { return "Bad Request: " + string(e) }
         .          .   1381:
         .          .   1382:// Serve a new connection.
         .          .   1383:func (c *conn) serve() {
         .          .   1384:	c.remoteAddr = c.rwc.RemoteAddr().String()
      10ms       10ms   1385:	defer func() {
         .          .   1386:		if err := recover(); err != nil {
         .          .   1387:			const size = 64 << 10
         .          .   1388:			buf := make([]byte, size)
         .          .   1389:			buf = buf[:runtime.Stack(buf, false)]
         .          .   1390:			c.server.logf("http: panic serving %v: %v\n%s", c.remoteAddr, err, buf)
         .          .   1391:		}
         .          .   1392:		if !c.hijacked() {
         .      180ms   1393:			c.close()
         .          .   1394:			c.setState(c.rwc, StateClosed)
         .          .   1395:		}
         .          .   1396:	}()
         .          .   1397:
         .          .   1398:	if tlsConn, ok := c.rwc.(*tls.Conn); ok {
ROUTINE ======================== net/http.(*connReader).Read in /home/isucon/.local/go/src/net/http/server.go
         0       70ms (flat, cum)  0.13% of Total
         .          .    521:			p[0] = res.b
         .          .    522:			cr.remain -= 1
         .          .    523:		}
         .          .    524:		return res.n, res.err
         .          .    525:	}
         .       70ms    526:	n, err = cr.r.Read(p)
         .          .    527:	cr.remain -= int64(n)
         .          .    528:	return
         .          .    529:}
         .          .    530:
         .          .    531:func (cr *connReader) startBackgroundRead(onReadComplete func()) {
ROUTINE ======================== net/http.(*exactSig).match in /home/isucon/.local/go/src/net/http/sniff.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    111:	sig []byte
         .          .    112:	ct  string
         .          .    113:}
         .          .    114:
         .          .    115:func (e *exactSig) match(data []byte, firstNonWS int) string {
         .       10ms    116:	if bytes.HasPrefix(data, e.sig) {
         .          .    117:		return e.ct
         .          .    118:	}
         .          .    119:	return ""
         .          .    120:}
         .          .    121:
ROUTINE ======================== net/http.(*fileHandler).ServeHTTP in /home/isucon/.local/go/src/net/http/fs.go
         0      150ms (flat, cum)  0.27% of Total
         .          .    512:	upath := r.URL.Path
         .          .    513:	if !strings.HasPrefix(upath, "/") {
         .          .    514:		upath = "/" + upath
         .          .    515:		r.URL.Path = upath
         .          .    516:	}
         .      150ms    517:	serveFile(w, r, f.root, path.Clean(upath), true)
         .          .    518:}
         .          .    519:
         .          .    520:// httpRange specifies the byte range to be sent to the client.
         .          .    521:type httpRange struct {
         .          .    522:	start, length int64
ROUTINE ======================== net/http.(*response).ReadFrom in /home/isucon/.local/go/src/net/http/server.go
         0       70ms (flat, cum)  0.13% of Total
         .          .    443:			return n, err
         .          .    444:		}
         .          .    445:	}
         .          .    446:
         .          .    447:	w.w.Flush()  // get rid of any previous writes
         .       50ms    448:	w.cw.flush() // make sure Header is written; flush data to rwc
         .          .    449:
         .          .    450:	// Now that cw has been flushed, its chunking field is guaranteed initialized.
         .          .    451:	if !w.cw.chunking && w.bodyAllowed() {
         .       20ms    452:		n0, err := rf.ReadFrom(src)
         .          .    453:		n += n0
         .          .    454:		w.written += n0
         .          .    455:		return n, err
         .          .    456:	}
         .          .    457:
ROUTINE ======================== net/http.(*response).Write in /home/isucon/.local/go/src/net/http/server.go
      10ms      780ms (flat, cum)  1.40% of Total
         .          .   1204:// (3) even in chunking mode if the write size from (1) is over some
         .          .   1205:// threshold and nothing is in (2).  The answer might be mostly making
         .          .   1206:// bufferBeforeChunkingSize smaller and having bufio's fast-paths deal
         .          .   1207:// with this instead.
         .          .   1208:func (w *response) Write(data []byte) (n int, err error) {
      10ms      780ms   1209:	return w.write(len(data), data, "")
         .          .   1210:}
         .          .   1211:
         .          .   1212:func (w *response) WriteString(data string) (n int, err error) {
         .          .   1213:	return w.write(len(data), nil, data)
         .          .   1214:}
ROUTINE ======================== net/http.(*response).WriteHeader in /home/isucon/.local/go/src/net/http/server.go
         0       50ms (flat, cum)  0.09% of Total
         .          .    774:// size is anyway.  (if we have the bytes on the machine, we might as
         .          .    775:// well read them)
         .          .    776:const maxPostHandlerReadBytes = 256 << 10
         .          .    777:
         .          .    778:func (w *response) WriteHeader(code int) {
         .       20ms    779:	if w.conn.hijacked() {
         .          .    780:		w.conn.server.logf("http: response.WriteHeader on hijacked connection")
         .          .    781:		return
         .          .    782:	}
         .          .    783:	if w.wroteHeader {
         .          .    784:		w.conn.server.logf("http: multiple response.WriteHeader calls")
         .          .    785:		return
         .          .    786:	}
         .          .    787:	w.wroteHeader = true
         .          .    788:	w.status = code
         .          .    789:
         .          .    790:	if w.calledHeader && w.cw.header == nil {
         .       30ms    791:		w.cw.header = w.handlerHeader.clone()
         .          .    792:	}
         .          .    793:
         .          .    794:	if cl := w.handlerHeader.get("Content-Length"); cl != "" {
         .          .    795:		v, err := strconv.ParseInt(cl, 10, 64)
         .          .    796:		if err == nil && v >= 0 {
ROUTINE ======================== net/http.(*response).finishRequest in /home/isucon/.local/go/src/net/http/server.go
         0       30ms (flat, cum) 0.054% of Total
         .          .   1247:		w.WriteHeader(StatusOK)
         .          .   1248:	}
         .          .   1249:
         .          .   1250:	w.w.Flush()
         .          .   1251:	putBufioWriter(w.w)
         .       10ms   1252:	w.cw.close()
         .       20ms   1253:	w.conn.bufw.Flush()
         .          .   1254:
         .          .   1255:	// Close the body (regardless of w.closeAfterReply) so we can
         .          .   1256:	// re-use its bufio.Reader later safely.
         .          .   1257:	w.reqBody.Close()
         .          .   1258:
ROUTINE ======================== net/http.(*response).write in /home/isucon/.local/go/src/net/http/server.go
      30ms      770ms (flat, cum)  1.38% of Total
         .          .   1212:func (w *response) WriteString(data string) (n int, err error) {
         .          .   1213:	return w.write(len(data), nil, data)
         .          .   1214:}
         .          .   1215:
         .          .   1216:// either dataB or dataS is non-zero.
      10ms       10ms   1217:func (w *response) write(lenData int, dataB []byte, dataS string) (n int, err error) {
      10ms      130ms   1218:	if w.conn.hijacked() {
         .          .   1219:		w.conn.server.logf("http: response.Write on hijacked connection")
         .          .   1220:		return 0, ErrHijacked
         .          .   1221:	}
         .          .   1222:	if !w.wroteHeader {
         .          .   1223:		w.WriteHeader(StatusOK)
         .          .   1224:	}
         .          .   1225:	if lenData == 0 {
         .          .   1226:		return 0, nil
         .          .   1227:	}
         .          .   1228:	if !w.bodyAllowed() {
         .          .   1229:		return 0, ErrBodyNotAllowed
         .          .   1230:	}
         .          .   1231:
         .          .   1232:	w.written += int64(lenData) // ignoring errors, for errorKludge
         .          .   1233:	if w.contentLength != -1 && w.written > w.contentLength {
         .          .   1234:		return 0, ErrContentLength
         .          .   1235:	}
         .          .   1236:	if dataB != nil {
      10ms      630ms   1237:		return w.w.Write(dataB)
         .          .   1238:	} else {
         .          .   1239:		return w.w.WriteString(dataS)
         .          .   1240:	}
         .          .   1241:}
         .          .   1242:
ROUTINE ======================== net/http.DetectContentType in /home/isucon/.local/go/src/net/http/sniff.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     27:	firstNonWS := 0
         .          .     28:	for ; firstNonWS < len(data) && isWS(data[firstNonWS]); firstNonWS++ {
         .          .     29:	}
         .          .     30:
         .          .     31:	for _, sig := range sniffSignatures {
         .       10ms     32:		if ct := sig.match(data, firstNonWS); ct != "" {
         .          .     33:			return ct
         .          .     34:		}
         .          .     35:	}
         .          .     36:
         .          .     37:	return "application/octet-stream" // fallback
ROUTINE ======================== net/http.Dir.Open in /home/isucon/.local/go/src/net/http/fs.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     40:	}
         .          .     41:	dir := string(d)
         .          .     42:	if dir == "" {
         .          .     43:		dir = "."
         .          .     44:	}
         .       20ms     45:	f, err := os.Open(filepath.Join(dir, filepath.FromSlash(path.Clean("/"+name))))
         .          .     46:	if err != nil {
         .          .     47:		return nil, err
         .          .     48:	}
         .          .     49:	return f, nil
         .          .     50:}
ROUTINE ======================== net/http.HandlerFunc.ServeHTTP in /home/isucon/.local/go/src/net/http/server.go
         0     46.69s (flat, cum) 83.90% of Total
         .          .   1613:// Handler that calls f.
         .          .   1614:type HandlerFunc func(ResponseWriter, *Request)
         .          .   1615:
         .          .   1616:// ServeHTTP calls f(w, r).
         .          .   1617:func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
         .     46.69s   1618:	f(w, r)
         .          .   1619:}
         .          .   1620:
         .          .   1621:// Helper handlers
         .          .   1622:
         .          .   1623:// Error replies to the request with the specified error message and HTTP code.
ROUTINE ======================== net/http.Header.Set in /home/isucon/.local/go/src/net/http/header.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     26:
         .          .     27:// Set sets the header entries associated with key to
         .          .     28:// the single element value.  It replaces any existing
         .          .     29:// values associated with key.
         .          .     30:func (h Header) Set(key, value string) {
         .       20ms     31:	textproto.MIMEHeader(h).Set(key, value)
         .          .     32:}
         .          .     33:
         .          .     34:// Get gets the first value associated with the given key.
         .          .     35:// If there are no values associated with the key, Get returns "".
         .          .     36:// To access multiple values of a key, access the map directly
ROUTINE ======================== net/http.Header.WriteSubset in /home/isucon/.local/go/src/net/http/header.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    148:		ws = stringWriter{w}
         .          .    149:	}
         .          .    150:	kvs, sorter := h.sortedKeyValues(exclude)
         .          .    151:	for _, kv := range kvs {
         .          .    152:		for _, v := range kv.values {
         .       10ms    153:			v = headerNewlineToSpace.Replace(v)
         .          .    154:			v = textproto.TrimString(v)
         .          .    155:			for _, s := range []string{kv.key, ": ", v, "\r\n"} {
         .          .    156:				if _, err := ws.WriteString(s); err != nil {
         .          .    157:					return err
         .          .    158:				}
ROUTINE ======================== net/http.Header.clone in /home/isucon/.local/go/src/net/http/header.go
         0       30ms (flat, cum) 0.054% of Total
         .          .     56:func (h Header) Write(w io.Writer) error {
         .          .     57:	return h.WriteSubset(w, nil)
         .          .     58:}
         .          .     59:
         .          .     60:func (h Header) clone() Header {
         .       20ms     61:	h2 := make(Header, len(h))
         .          .     62:	for k, vv := range h {
         .          .     63:		vv2 := make([]string, len(vv))
         .          .     64:		copy(vv2, vv)
         .       10ms     65:		h2[k] = vv2
         .          .     66:	}
         .          .     67:	return h2
         .          .     68:}
         .          .     69:
         .          .     70:var timeFormats = []string{
ROUTINE ======================== net/http.Redirect in /home/isucon/.local/go/src/net/http/server.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   1705:			urlStr += query
         .          .   1706:		}
         .          .   1707:	}
         .          .   1708:
         .          .   1709:	w.Header().Set("Location", urlStr)
         .       10ms   1710:	w.WriteHeader(code)
         .          .   1711:
         .          .   1712:	// RFC2616 recommends that a short note "SHOULD" be included in the
         .          .   1713:	// response because older user agents may not understand 301/307.
         .          .   1714:	// Shouldn't send the response for POST or HEAD; that leaves GET.
         .          .   1715:	if r.Method == "GET" {
ROUTINE ======================== net/http.SetCookie in /home/isucon/.local/go/src/net/http/cookie.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    126:
         .          .    127:// SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.
         .          .    128:// The provided cookie must have a valid Name. Invalid cookies may be
         .          .    129:// silently dropped.
         .          .    130:func SetCookie(w ResponseWriter, cookie *Cookie) {
         .       10ms    131:	if v := cookie.String(); v != "" {
         .          .    132:		w.Header().Add("Set-Cookie", v)
         .          .    133:	}
         .          .    134:}
         .          .    135:
         .          .    136:// String returns the serialization of the cookie for use in a Cookie
ROUTINE ======================== net/http.appendTime in /home/isucon/.local/go/src/net/http/server.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    673:		mon[0], mon[1], mon[2], ' ',
         .          .    674:		byte('0'+yy/1000), byte('0'+(yy/100)%10), byte('0'+(yy/10)%10), byte('0'+yy%10), ' ',
         .          .    675:		byte('0'+hh/10), byte('0'+hh%10), ':',
         .          .    676:		byte('0'+mn/10), byte('0'+mn%10), ':',
         .          .    677:		byte('0'+ss/10), byte('0'+ss%10), ' ',
      10ms       10ms    678:		'G', 'M', 'T')
         .          .    679:}
         .          .    680:
         .          .    681:var errTooLarge = errors.New("http: request too large")
         .          .    682:
         .          .    683:// Read next request from connection.
ROUTINE ======================== net/http.checkConnErrorWriter.Write in /home/isucon/.local/go/src/net/http/server.go
         0      630ms (flat, cum)  1.13% of Total
         .          .   2537:type checkConnErrorWriter struct {
         .          .   2538:	c *conn
         .          .   2539:}
         .          .   2540:
         .          .   2541:func (w checkConnErrorWriter) Write(p []byte) (n int, err error) {
         .      630ms   2542:	n, err = w.c.rwc.Write(p)
         .          .   2543:	if err != nil && w.c.werr == nil {
         .          .   2544:		w.c.werr = err
         .          .   2545:	}
         .          .   2546:	return
         .          .   2547:}
ROUTINE ======================== net/http.fixLength in /home/isucon/.local/go/src/net/http/transfer.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    489:
         .          .    490:// Determine the expected body length, using RFC 2616 Section 4.4. This
         .          .    491:// function is not a method, because ultimately it should be shared by
         .          .    492:// ReadResponse and ReadRequest.
         .          .    493:func fixLength(isResponse bool, status int, requestMethod string, header Header, te []string) (int64, error) {
         .       10ms    494:	contentLens := header["Content-Length"]
         .          .    495:	isRequest := !isResponse
         .          .    496:	// Logic based on response type or status
         .          .    497:	if noBodyExpected(requestMethod) {
         .          .    498:		// For HTTP requests, as part of hardening against request
         .          .    499:		// smuggling (RFC 7230), don't allow a Content-Length header for
ROUTINE ======================== net/http.isNotToken in /home/isucon/.local/go/src/net/http/lex.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .     95:	i := int(r)
         .          .     96:	return i < len(isTokenTable) && isTokenTable[i]
         .          .     97:}
         .          .     98:
         .          .     99:func isNotToken(r rune) bool {
      10ms       10ms    100:	return !isToken(r)
         .          .    101:}
         .          .    102:
         .          .    103:// headerValuesContainsToken reports whether any string in values
         .          .    104:// contains the provided token, ASCII case-insensitively.
         .          .    105:func headerValuesContainsToken(values []string, token string) bool {
ROUTINE ======================== net/http.newBufioReader in /home/isucon/.local/go/src/net/http/server.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    573:		br.Reset(r)
         .          .    574:		return br
         .          .    575:	}
         .          .    576:	// Note: if this reader size is every changed, update
         .          .    577:	// TestHandlerBodyClose's assumptions.
         .       20ms    578:	return bufio.NewReader(r)
         .          .    579:}
         .          .    580:
         .          .    581:func putBufioReader(br *bufio.Reader) {
         .          .    582:	br.Reset(nil)
         .          .    583:	bufioReaderPool.Put(br)
ROUTINE ======================== net/http.newBufioWriterSize in /home/isucon/.local/go/src/net/http/server.go
         0       70ms (flat, cum)  0.13% of Total
         .          .    590:			bw := v.(*bufio.Writer)
         .          .    591:			bw.Reset(w)
         .          .    592:			return bw
         .          .    593:		}
         .          .    594:	}
         .       70ms    595:	return bufio.NewWriterSize(w, size)
         .          .    596:}
         .          .    597:
         .          .    598:func putBufioWriter(bw *bufio.Writer) {
         .          .    599:	bw.Reset(nil)
         .          .    600:	if pool := bufioWriterPool(bw.Available()); pool != nil {
ROUTINE ======================== net/http.newTextprotoReader in /home/isucon/.local/go/src/net/http/request.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    688:}
         .          .    689:
         .          .    690:var textprotoReaderPool sync.Pool
         .          .    691:
         .          .    692:func newTextprotoReader(br *bufio.Reader) *textproto.Reader {
         .       10ms    693:	if v := textprotoReaderPool.Get(); v != nil {
         .          .    694:		tr := v.(*textproto.Reader)
         .          .    695:		tr.R = br
         .          .    696:		return tr
         .          .    697:	}
         .       10ms    698:	return textproto.NewReader(br)
         .          .    699:}
         .          .    700:
         .          .    701:func putTextprotoReader(r *textproto.Reader) {
         .          .    702:	r.R = nil
         .          .    703:	textprotoReaderPool.Put(r)
ROUTINE ======================== net/http.putBufioWriter in /home/isucon/.local/go/src/net/http/server.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    596:}
         .          .    597:
         .          .    598:func putBufioWriter(bw *bufio.Writer) {
         .          .    599:	bw.Reset(nil)
         .          .    600:	if pool := bufioWriterPool(bw.Available()); pool != nil {
         .       10ms    601:		pool.Put(bw)
         .          .    602:	}
         .          .    603:}
         .          .    604:
         .          .    605:// DefaultMaxHeaderBytes is the maximum permitted size of the headers
         .          .    606:// in an HTTP request.
ROUTINE ======================== net/http.readCookies in /home/isucon/.local/go/src/net/http/cookie.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    214:			}
         .          .    215:			val, success := parseCookieValue(val, true)
         .          .    216:			if !success {
         .          .    217:				continue
         .          .    218:			}
         .       10ms    219:			cookies = append(cookies, &Cookie{Name: name, Value: val})
         .          .    220:			parsedPairs++
         .          .    221:		}
         .          .    222:	}
         .          .    223:	return cookies
         .          .    224:}
ROUTINE ======================== net/http.readRequest in /home/isucon/.local/go/src/net/http/request.go
         0      230ms (flat, cum)  0.41% of Total
         .          .    711:	deleteHostHeader = true
         .          .    712:	keepHostHeader   = false
         .          .    713:)
         .          .    714:
         .          .    715:func readRequest(b *bufio.Reader, deleteHostHeader bool) (req *Request, err error) {
         .       20ms    716:	tp := newTextprotoReader(b)
         .       10ms    717:	req = new(Request)
         .          .    718:
         .          .    719:	// First line: GET /index.html HTTP/1.0
         .          .    720:	var s string
         .       70ms    721:	if s, err = tp.ReadLine(); err != nil {
         .          .    722:		return nil, err
         .          .    723:	}
         .          .    724:	defer func() {
         .          .    725:		putTextprotoReader(tp)
         .          .    726:		if err == io.EOF {
         .          .    727:			err = io.ErrUnexpectedEOF
         .          .    728:		}
         .          .    729:	}()
         .          .    730:
         .          .    731:	var ok bool
         .          .    732:	req.Method, req.RequestURI, req.Proto, ok = parseRequestLine(s)
         .          .    733:	if !ok {
         .          .    734:		return nil, &badStringError{"malformed HTTP request", s}
         .          .    735:	}
         .          .    736:	rawurl := req.RequestURI
         .          .    737:	if req.ProtoMajor, req.ProtoMinor, ok = ParseHTTPVersion(req.Proto); !ok {
         .          .    738:		return nil, &badStringError{"malformed HTTP version", req.Proto}
         .          .    739:	}
         .          .    740:
         .          .    741:	// CONNECT requests are used two different ways, and neither uses a full URL:
         .          .    742:	// The standard use is to tunnel HTTPS through an HTTP proxy.
         .          .    743:	// It looks like "CONNECT www.google.com:443 HTTP/1.1", and the parameter is
         .          .    744:	// just the authority section of a URL. This information should go in req.URL.Host.
         .          .    745:	//
         .          .    746:	// The net/rpc package also uses CONNECT, but there the parameter is a path
         .          .    747:	// that starts with a slash. It can be parsed with the regular URL parser,
         .          .    748:	// and the path will end up in req.URL.Path, where it needs to be in order for
         .          .    749:	// RPC to work.
         .          .    750:	justAuthority := req.Method == "CONNECT" && !strings.HasPrefix(rawurl, "/")
         .          .    751:	if justAuthority {
         .          .    752:		rawurl = "http://" + rawurl
         .          .    753:	}
         .          .    754:
         .       20ms    755:	if req.URL, err = url.ParseRequestURI(rawurl); err != nil {
         .          .    756:		return nil, err
         .          .    757:	}
         .          .    758:
         .          .    759:	if justAuthority {
         .          .    760:		// Strip the bogus "http://" back off.
         .          .    761:		req.URL.Scheme = ""
         .          .    762:	}
         .          .    763:
         .          .    764:	// Subsequent lines: Key: value.
         .       70ms    765:	mimeHeader, err := tp.ReadMIMEHeader()
         .          .    766:	if err != nil {
         .          .    767:		return nil, err
         .          .    768:	}
         .          .    769:	req.Header = Header(mimeHeader)
         .          .    770:
         .          .    771:	// RFC2616: Must treat
         .          .    772:	//	GET /index.html HTTP/1.1
         .          .    773:	//	Host: www.google.com
         .          .    774:	// and
         .          .    775:	//	GET http://www.google.com/index.html HTTP/1.1
         .          .    776:	//	Host: doesntmatter
         .          .    777:	// the same.  In the second case, any Host line is ignored.
         .          .    778:	req.Host = req.URL.Host
         .          .    779:	if req.Host == "" {
         .          .    780:		req.Host = req.Header.get("Host")
         .          .    781:	}
         .          .    782:	if deleteHostHeader {
         .          .    783:		delete(req.Header, "Host")
         .          .    784:	}
         .          .    785:
         .       10ms    786:	fixPragmaCacheControl(req.Header)
         .          .    787:
         .          .    788:	req.Close = shouldClose(req.ProtoMajor, req.ProtoMinor, req.Header, false)
         .          .    789:
         .       20ms    790:	err = readTransfer(req, b)
         .          .    791:	if err != nil {
         .          .    792:		return nil, err
         .          .    793:	}
         .          .    794:
         .       10ms    795:	return req, nil
         .          .    796:}
         .          .    797:
         .          .    798:// MaxBytesReader is similar to io.LimitReader but is intended for
         .          .    799:// limiting the size of incoming request bodies. In contrast to
         .          .    800:// io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a
ROUTINE ======================== net/http.readTransfer in /home/isucon/.local/go/src/net/http/transfer.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .    334:	default:
         .          .    335:		panic("unexpected type")
         .          .    336:	}
         .          .    337:
         .          .    338:	// Default to HTTP/1.1
      10ms       10ms    339:	if t.ProtoMajor == 0 && t.ProtoMinor == 0 {
         .          .    340:		t.ProtoMajor, t.ProtoMinor = 1, 1
         .          .    341:	}
         .          .    342:
         .          .    343:	// Transfer encoding, content length
         .          .    344:	err = t.fixTransferEncoding()
         .          .    345:	if err != nil {
         .          .    346:		return err
         .          .    347:	}
         .          .    348:
         .       10ms    349:	realLength, err := fixLength(isResponse, t.StatusCode, t.RequestMethod, t.Header, t.TransferEncoding)
         .          .    350:	if err != nil {
         .          .    351:		return err
         .          .    352:	}
         .          .    353:	if isResponse && t.RequestMethod == "HEAD" {
         .          .    354:		if n, err := parseContentLength(t.Header.get("Content-Length")); err != nil {
ROUTINE ======================== net/http.serveContent in /home/isucon/.local/go/src/net/http/fs.go
         0      110ms (flat, cum)   0.2% of Total
         .          .    155:
         .          .    156:	code := StatusOK
         .          .    157:
         .          .    158:	// If Content-Type isn't set, use the file's extension to find it, but
         .          .    159:	// if the Content-Type is unset explicitly, do not sniff the type.
         .       10ms    160:	ctypes, haveType := w.Header()["Content-Type"]
         .          .    161:	var ctype string
         .          .    162:	if !haveType {
         .       10ms    163:		ctype = mime.TypeByExtension(filepath.Ext(name))
         .          .    164:		if ctype == "" {
         .          .    165:			// read a chunk to decide between utf-8 text and binary
         .          .    166:			var buf [sniffLen]byte
         .          .    167:			n, _ := io.ReadFull(content, buf[:])
         .          .    168:			ctype = DetectContentType(buf[:n])
         .          .    169:			_, err := content.Seek(0, os.SEEK_SET) // rewind to output whole file
         .          .    170:			if err != nil {
         .          .    171:				Error(w, "seeker can't seek", StatusInternalServerError)
         .          .    172:				return
         .          .    173:			}
         .          .    174:		}
         .       10ms    175:		w.Header().Set("Content-Type", ctype)
         .          .    176:	} else if len(ctypes) > 0 {
         .          .    177:		ctype = ctypes[0]
         .          .    178:	}
         .          .    179:
         .          .    180:	size, err := sizeFunc()
         .          .    181:	if err != nil {
         .          .    182:		Error(w, err.Error(), StatusInternalServerError)
         .          .    183:		return
         .          .    184:	}
         .          .    185:
         .          .    186:	// handle Content-Range header.
         .          .    187:	sendSize := size
         .          .    188:	var sendContent io.Reader = content
         .          .    189:	if size >= 0 {
         .          .    190:		ranges, err := parseRange(rangeReq, size)
         .          .    191:		if err != nil {
         .          .    192:			Error(w, err.Error(), StatusRequestedRangeNotSatisfiable)
         .          .    193:			return
         .          .    194:		}
         .          .    195:		if sumRangesSize(ranges) > size {
         .          .    196:			// The total number of bytes in all the ranges
         .          .    197:			// is larger than the size of the file by
         .          .    198:			// itself, so this is probably an attack, or a
         .          .    199:			// dumb client.  Ignore the range request.
         .          .    200:			ranges = nil
         .          .    201:		}
         .          .    202:		switch {
         .          .    203:		case len(ranges) == 1:
         .          .    204:			// RFC 2616, Section 14.16:
         .          .    205:			// "When an HTTP message includes the content of a single
         .          .    206:			// range (for example, a response to a request for a
         .          .    207:			// single range, or to a request for a set of ranges
         .          .    208:			// that overlap without any holes), this content is
         .          .    209:			// transmitted with a Content-Range header, and a
         .          .    210:			// Content-Length header showing the number of bytes
         .          .    211:			// actually transferred.
         .          .    212:			// ...
         .          .    213:			// A response to a request for a single range MUST NOT
         .          .    214:			// be sent using the multipart/byteranges media type."
         .          .    215:			ra := ranges[0]
         .          .    216:			if _, err := content.Seek(ra.start, os.SEEK_SET); err != nil {
         .          .    217:				Error(w, err.Error(), StatusRequestedRangeNotSatisfiable)
         .          .    218:				return
         .          .    219:			}
         .          .    220:			sendSize = ra.length
         .          .    221:			code = StatusPartialContent
         .          .    222:			w.Header().Set("Content-Range", ra.contentRange(size))
         .          .    223:		case len(ranges) > 1:
         .          .    224:			sendSize = rangesMIMESize(ranges, ctype, size)
         .          .    225:			code = StatusPartialContent
         .          .    226:
         .          .    227:			pr, pw := io.Pipe()
         .          .    228:			mw := multipart.NewWriter(pw)
         .          .    229:			w.Header().Set("Content-Type", "multipart/byteranges; boundary="+mw.Boundary())
         .          .    230:			sendContent = pr
         .          .    231:			defer pr.Close() // cause writing goroutine to fail and exit if CopyN doesn't finish.
         .          .    232:			go func() {
         .          .    233:				for _, ra := range ranges {
         .          .    234:					part, err := mw.CreatePart(ra.mimeHeader(ctype, size))
         .          .    235:					if err != nil {
         .          .    236:						pw.CloseWithError(err)
         .          .    237:						return
         .          .    238:					}
         .          .    239:					if _, err := content.Seek(ra.start, os.SEEK_SET); err != nil {
         .          .    240:						pw.CloseWithError(err)
         .          .    241:						return
         .          .    242:					}
         .          .    243:					if _, err := io.CopyN(part, content, ra.length); err != nil {
         .          .    244:						pw.CloseWithError(err)
         .          .    245:						return
         .          .    246:					}
         .          .    247:				}
         .          .    248:				mw.Close()
         .          .    249:				pw.Close()
         .          .    250:			}()
         .          .    251:		}
         .          .    252:
         .          .    253:		w.Header().Set("Accept-Ranges", "bytes")
         .          .    254:		if w.Header().Get("Content-Encoding") == "" {
         .          .    255:			w.Header().Set("Content-Length", strconv.FormatInt(sendSize, 10))
         .          .    256:		}
         .          .    257:	}
         .          .    258:
         .       10ms    259:	w.WriteHeader(code)
         .          .    260:
         .          .    261:	if r.Method != "HEAD" {
         .       70ms    262:		io.CopyN(w, sendContent, sendSize)
         .          .    263:	}
         .          .    264:}
         .          .    265:
         .          .    266:var unixEpochTime = time.Unix(0, 0)
         .          .    267:
ROUTINE ======================== net/http.serveFile in /home/isucon/.local/go/src/net/http/fs.go
         0      150ms (flat, cum)  0.27% of Total
         .          .    359:	if strings.HasSuffix(r.URL.Path, indexPage) {
         .          .    360:		localRedirect(w, r, "./")
         .          .    361:		return
         .          .    362:	}
         .          .    363:
         .       20ms    364:	f, err := fs.Open(name)
         .          .    365:	if err != nil {
         .          .    366:		msg, code := toHTTPError(err)
         .          .    367:		Error(w, msg, code)
         .          .    368:		return
         .          .    369:	}
         .          .    370:	defer f.Close()
         .          .    371:
         .          .    372:	d, err := f.Stat()
         .          .    373:	if err != nil {
         .          .    374:		msg, code := toHTTPError(err)
         .          .    375:		Error(w, msg, code)
         .          .    376:		return
         .          .    377:	}
         .          .    378:
         .          .    379:	if redirect {
         .          .    380:		// redirect to canonical path: / at end of directory url
         .          .    381:		// r.URL.Path always begins with /
         .          .    382:		url := r.URL.Path
         .          .    383:		if d.IsDir() {
         .          .    384:			if url[len(url)-1] != '/' {
         .          .    385:				localRedirect(w, r, path.Base(url)+"/")
         .          .    386:				return
         .          .    387:			}
         .          .    388:		} else {
         .          .    389:			if url[len(url)-1] == '/' {
         .          .    390:				localRedirect(w, r, "../"+path.Base(url))
         .          .    391:				return
         .          .    392:			}
         .          .    393:		}
         .          .    394:	}
         .          .    395:
         .          .    396:	// use contents of index.html for directory, if present
         .          .    397:	if d.IsDir() {
         .          .    398:		index := strings.TrimSuffix(name, "/") + indexPage
         .          .    399:		ff, err := fs.Open(index)
         .          .    400:		if err == nil {
         .          .    401:			defer ff.Close()
         .          .    402:			dd, err := ff.Stat()
         .          .    403:			if err == nil {
         .          .    404:				name = index
         .          .    405:				d = dd
         .          .    406:				f = ff
         .          .    407:			}
         .          .    408:		}
         .          .    409:	}
         .          .    410:
         .          .    411:	// Still a directory? (we didn't find an index.html file)
         .          .    412:	if d.IsDir() {
         .          .    413:		if checkLastModified(w, r, d.ModTime()) {
         .          .    414:			return
         .          .    415:		}
         .          .    416:		dirList(w, f)
         .          .    417:		return
         .          .    418:	}
         .          .    419:
         .          .    420:	// serveContent will check modification time
         .          .    421:	sizeFunc := func() (int64, error) { return d.Size(), nil }
         .      110ms    422:	serveContent(w, r, d.Name(), d.ModTime(), sizeFunc, f)
         .       20ms    423:}
         .          .    424:
         .          .    425:// toHTTPError returns a non-specific HTTP error message and status code
         .          .    426:// for a given non-nil error value. It's important that toHTTPError does not
         .          .    427:// actually return err.Error(), since msg and httpStatus are returned to users,
         .          .    428:// and historically Go's ServeContent always returned just "404 Not Found" for
ROUTINE ======================== net/http.serverHandler.ServeHTTP in /home/isucon/.local/go/src/net/http/server.go
         0     46.70s (flat, cum) 83.92% of Total
         .          .   2076:		handler = DefaultServeMux
         .          .   2077:	}
         .          .   2078:	if req.RequestURI == "*" && req.Method == "OPTIONS" {
         .          .   2079:		handler = globalOptionsHandler{}
         .          .   2080:	}
         .     46.70s   2081:	handler.ServeHTTP(rw, req)
         .          .   2082:}
         .          .   2083:
         .          .   2084:// ListenAndServe listens on the TCP network address srv.Addr and then
         .          .   2085:// calls Serve to handle requests on incoming connections.
         .          .   2086:// Accepted connections are configured to enable TCP keep-alives.
ROUTINE ======================== net/http.validHeaderName in /home/isucon/.local/go/src/net/http/request.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   1145:
         .          .   1146:func validHeaderName(v string) bool {
         .          .   1147:	if len(v) == 0 {
         .          .   1148:		return false
         .          .   1149:	}
         .       10ms   1150:	return strings.IndexFunc(v, isNotToken) == -1
         .          .   1151:}
         .          .   1152:
         .          .   1153:// validHeaderValue reports whether v is a valid "field-value" according to
         .          .   1154:// http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2 :
         .          .   1155://
ROUTINE ======================== net/textproto.(*Reader).ReadLine in /home/isucon/.local/go/src/net/textproto/reader.go
         0       70ms (flat, cum)  0.13% of Total
         .          .     31:}
         .          .     32:
         .          .     33:// ReadLine reads a single line from r,
         .          .     34:// eliding the final \n or \r\n from the returned string.
         .          .     35:func (r *Reader) ReadLine() (string, error) {
         .       70ms     36:	line, err := r.readLineSlice()
         .          .     37:	return string(line), err
         .          .     38:}
         .          .     39:
         .          .     40:// ReadLineBytes is like ReadLine but returns a []byte instead of a string.
         .          .     41:func (r *Reader) ReadLineBytes() ([]byte, error) {
ROUTINE ======================== net/textproto.(*Reader).ReadMIMEHeader in /home/isucon/.local/go/src/net/textproto/reader.go
         0       70ms (flat, cum)  0.13% of Total
         .          .    470:	// large one ahead of time which we'll cut up into smaller
         .          .    471:	// slices. If this isn't big enough later, we allocate small ones.
         .          .    472:	var strs []string
         .          .    473:	hint := r.upcomingHeaderNewlines()
         .          .    474:	if hint > 0 {
         .       20ms    475:		strs = make([]string, hint)
         .          .    476:	}
         .          .    477:
         .          .    478:	m := make(MIMEHeader, hint)
         .          .    479:	for {
         .          .    480:		kv, err := r.readContinuedLineSlice()
         .          .    481:		if len(kv) == 0 {
         .          .    482:			return m, err
         .          .    483:		}
         .          .    484:
         .          .    485:		// Key ends at first colon; should not have spaces but
         .          .    486:		// they appear in the wild, violating specs, so we
         .          .    487:		// remove them if present.
         .          .    488:		i := bytes.IndexByte(kv, ':')
         .          .    489:		if i < 0 {
         .          .    490:			return m, ProtocolError("malformed MIME header line: " + string(kv))
         .          .    491:		}
         .          .    492:		endKey := i
         .          .    493:		for endKey > 0 && kv[endKey-1] == ' ' {
         .          .    494:			endKey--
         .          .    495:		}
         .       10ms    496:		key := canonicalMIMEHeaderKey(kv[:endKey])
         .          .    497:
         .          .    498:		// As per RFC 7230 field-name is a token, tokens consist of one or more chars.
         .          .    499:		// We could return a ProtocolError here, but better to be liberal in what we
         .          .    500:		// accept, so if we get an empty key, skip it.
         .          .    501:		if key == "" {
         .          .    502:			continue
         .          .    503:		}
         .          .    504:
         .          .    505:		// Skip initial spaces in value.
         .          .    506:		i++ // skip colon
         .          .    507:		for i < len(kv) && (kv[i] == ' ' || kv[i] == '\t') {
         .          .    508:			i++
         .          .    509:		}
         .       20ms    510:		value := string(kv[i:])
         .          .    511:
         .          .    512:		vv := m[key]
         .          .    513:		if vv == nil && len(strs) > 0 {
         .          .    514:			// More than likely this will be a single-element key.
         .          .    515:			// Most headers aren't multi-valued.
         .          .    516:			// Set the capacity on strs[0] to 1, so any future append
         .          .    517:			// won't extend the slice into the other strings.
         .          .    518:			vv, strs = strs[:1:1], strs[1:]
         .          .    519:			vv[0] = value
         .       20ms    520:			m[key] = vv
         .          .    521:		} else {
         .          .    522:			m[key] = append(vv, value)
         .          .    523:		}
         .          .    524:
         .          .    525:		if err != nil {
ROUTINE ======================== net/textproto.(*Reader).readLineSlice in /home/isucon/.local/go/src/net/textproto/reader.go
         0       70ms (flat, cum)  0.13% of Total
         .          .     50:
         .          .     51:func (r *Reader) readLineSlice() ([]byte, error) {
         .          .     52:	r.closeDot()
         .          .     53:	var line []byte
         .          .     54:	for {
         .       70ms     55:		l, more, err := r.R.ReadLine()
         .          .     56:		if err != nil {
         .          .     57:			return nil, err
         .          .     58:		}
         .          .     59:		// Avoid the copy if the first call produced a full line.
         .          .     60:		if line == nil && !more {
ROUTINE ======================== net/textproto.CanonicalMIMEHeaderKey in /home/isucon/.local/go/src/net/textproto/reader.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    571:			return canonicalMIMEHeaderKey([]byte(s))
         .          .    572:		}
         .          .    573:		if !upper && 'A' <= c && c <= 'Z' {
         .          .    574:			return canonicalMIMEHeaderKey([]byte(s))
         .          .    575:		}
      10ms       10ms    576:		upper = c == '-'
         .          .    577:	}
         .          .    578:	return s
         .          .    579:}
         .          .    580:
         .          .    581:const toLower = 'a' - 'A'
ROUTINE ======================== net/textproto.MIMEHeader.Set in /home/isucon/.local/go/src/net/textproto/header.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     17:
         .          .     18:// Set sets the header entries associated with key to
         .          .     19:// the single element value.  It replaces any existing
         .          .     20:// values associated with key.
         .          .     21:func (h MIMEHeader) Set(key, value string) {
         .       20ms     22:	h[CanonicalMIMEHeaderKey(key)] = []string{value}
         .          .     23:}
         .          .     24:
         .          .     25:// Get gets the first value associated with the given key.
         .          .     26:// If there are no values associated with the key, Get returns "".
         .          .     27:// Get is a convenience method.  For more complex queries,
ROUTINE ======================== net/textproto.canonicalMIMEHeaderKey in /home/isucon/.local/go/src/net/textproto/reader.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    609:		}
         .          .    610:		// Don't canonicalize.
         .          .    611:		return string(a)
         .          .    612:	}
         .          .    613:
      10ms       10ms    614:	upper := true
         .          .    615:	for i, c := range a {
         .          .    616:		// Canonicalize: first letter upper case
         .          .    617:		// and upper case after each dash.
         .          .    618:		// (Host, User-Agent, If-Modified-Since).
         .          .    619:		// MIME headers are ASCII only, so no Unicode issues.
ROUTINE ======================== net/url.(*URL).EscapedPath in /home/isucon/.local/go/src/net/url/url.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .    592:		}
         .          .    593:	}
         .          .    594:	if u.Path == "*" {
         .          .    595:		return "*" // don't escape (Issue 11202)
         .          .    596:	}
      10ms       20ms    597:	return escape(u.Path, encodePath)
         .          .    598:}
         .          .    599:
         .          .    600:// validEncodedPath reports whether s is a valid encoded path.
         .          .    601:// It must not contain any bytes that require escaping during path encoding.
         .          .    602:func validEncodedPath(s string) bool {
ROUTINE ======================== net/url.(*URL).String in /home/isucon/.local/go/src/net/url/url.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    676:			}
         .          .    677:			if h := u.Host; h != "" {
         .          .    678:				buf.WriteString(escape(h, encodeHost))
         .          .    679:			}
         .          .    680:		}
         .       10ms    681:		path := u.EscapedPath()
         .          .    682:		if path != "" && path[0] != '/' && u.Host != "" {
         .          .    683:			buf.WriteByte('/')
         .          .    684:		}
         .          .    685:		buf.WriteString(path)
         .          .    686:	}
ROUTINE ======================== net/url.ParseRequestURI in /home/isucon/.local/go/src/net/url/url.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    429:// rawurl was received in an HTTP request, so the rawurl is interpreted
         .          .    430:// only as an absolute URI or an absolute path.
         .          .    431:// The string rawurl is assumed not to have a #fragment suffix.
         .          .    432:// (Web browsers strip #fragment before sending the URL to a web server.)
         .          .    433:func ParseRequestURI(rawurl string) (url *URL, err error) {
         .       20ms    434:	return parse(rawurl, true)
         .          .    435:}
         .          .    436:
         .          .    437:// parse parses a URL from a string in one of two contexts.  If
         .          .    438:// viaRequest is true, the URL is assumed to have arrived via an HTTP request,
         .          .    439:// in which case only absolute URLs or path-absolute relative URLs are allowed.
ROUTINE ======================== net/url.escape in /home/isucon/.local/go/src/net/url/url.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    248:
         .          .    249:func escape(s string, mode encoding) string {
         .          .    250:	spaceCount, hexCount := 0, 0
         .          .    251:	for i := 0; i < len(s); i++ {
         .          .    252:		c := s[i]
         .       10ms    253:		if shouldEscape(c, mode) {
         .          .    254:			if c == ' ' && mode == encodeQueryComponent {
         .          .    255:				spaceCount++
         .          .    256:			} else {
         .          .    257:				hexCount++
         .          .    258:			}
ROUTINE ======================== net/url.parse in /home/isucon/.local/go/src/net/url/url.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    443:
         .          .    444:	if rawurl == "" && viaRequest {
         .          .    445:		err = errors.New("empty url")
         .          .    446:		goto Error
         .          .    447:	}
         .       10ms    448:	url = new(URL)
         .          .    449:
         .          .    450:	if rawurl == "*" {
         .          .    451:		url.Path = "*"
         .          .    452:		return
         .          .    453:	}
         .          .    454:
         .          .    455:	// Split off possible leading "http:", "mailto:", etc.
         .          .    456:	// Cannot contain escaped characters.
         .          .    457:	if url.Scheme, rest, err = getscheme(rawurl); err != nil {
         .          .    458:		goto Error
         .          .    459:	}
         .          .    460:	url.Scheme = strings.ToLower(url.Scheme)
         .          .    461:
         .          .    462:	rest, url.RawQuery = split(rest, "?", true)
         .          .    463:
         .          .    464:	if !strings.HasPrefix(rest, "/") {
         .          .    465:		if url.Scheme != "" {
         .          .    466:			// We consider rootless paths per RFC 3986 as opaque.
         .          .    467:			url.Opaque = rest
         .          .    468:			return url, nil
         .          .    469:		}
         .          .    470:		if viaRequest {
         .          .    471:			err = errors.New("invalid URI for request")
         .          .    472:			goto Error
         .          .    473:		}
         .          .    474:	}
         .          .    475:
         .          .    476:	if (url.Scheme != "" || !viaRequest && !strings.HasPrefix(rest, "///")) && strings.HasPrefix(rest, "//") {
         .          .    477:		var authority string
         .          .    478:		authority, rest = split(rest[2:], "/", false)
         .          .    479:		url.User, url.Host, err = parseAuthority(authority)
         .          .    480:		if err != nil {
         .          .    481:			goto Error
         .          .    482:		}
         .          .    483:	}
         .          .    484:	if url.Path, err = unescape(rest, encodePath); err != nil {
         .          .    485:		goto Error
         .          .    486:	}
         .          .    487:	// RawPath is a hint as to the encoding of Path to use
         .          .    488:	// in url.EscapedPath. If that method already gets the
         .          .    489:	// right answer without RawPath, leave it empty.
         .          .    490:	// This will help make sure that people don't rely on it in general.
         .       10ms    491:	if url.EscapedPath() != rest && validEncodedPath(rest) {
         .          .    492:		url.RawPath = rest
         .          .    493:	}
         .          .    494:	return url, nil
         .          .    495:
         .          .    496:Error:
ROUTINE ======================== net/url.shouldEscape in /home/isucon/.local/go/src/net/url/url.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    115:			return false
         .          .    116:		}
         .          .    117:	}
         .          .    118:
         .          .    119:	switch c {
      10ms       10ms    120:	case '-', '_', '.', '~': // §2.3 Unreserved characters (mark)
         .          .    121:		return false
         .          .    122:
         .          .    123:	case '$', '&', '+', ',', '/', ':', ';', '=', '?', '@': // §2.2 Reserved characters (reserved)
         .          .    124:		// Different sections of the URL allow a few of
         .          .    125:		// the reserved characters to appear unescaped.
ROUTINE ======================== os.(*File).Close in /home/isucon/.local/go/src/os/file_unix.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    127:// It returns an error, if any.
         .          .    128:func (f *File) Close() error {
         .          .    129:	if f == nil {
         .          .    130:		return ErrInvalid
         .          .    131:	}
         .       20ms    132:	return f.file.close()
         .          .    133:}
         .          .    134:
         .          .    135:func (file *file) close() error {
         .          .    136:	if file == nil || file.fd < 0 {
         .          .    137:		return syscall.EINVAL
ROUTINE ======================== os.(*File).Read in /home/isucon/.local/go/src/os/file.go
      10ms       40ms (flat, cum) 0.072% of Total
         .          .     86:}
         .          .     87:
         .          .     88:// Read reads up to len(b) bytes from the File.
         .          .     89:// It returns the number of bytes read and an error, if any.
         .          .     90:// EOF is signaled by a zero count with err set to io.EOF.
      10ms       10ms     91:func (f *File) Read(b []byte) (n int, err error) {
         .          .     92:	if f == nil {
         .          .     93:		return 0, ErrInvalid
         .          .     94:	}
         .       30ms     95:	n, e := f.read(b)
         .          .     96:	if n == 0 && len(b) > 0 && e == nil {
         .          .     97:		return 0, io.EOF
         .          .     98:	}
         .          .     99:	if e != nil {
         .          .    100:		err = &PathError{"read", f.name, e}
ROUTINE ======================== os.(*File).Write in /home/isucon/.local/go/src/os/file.go
         0       90ms (flat, cum)  0.16% of Total
         .          .    131:// Write returns a non-nil error when n != len(b).
         .          .    132:func (f *File) Write(b []byte) (n int, err error) {
         .          .    133:	if f == nil {
         .          .    134:		return 0, ErrInvalid
         .          .    135:	}
         .       90ms    136:	n, e := f.write(b)
         .          .    137:	if n < 0 {
         .          .    138:		n = 0
         .          .    139:	}
         .          .    140:	if n != len(b) {
         .          .    141:		err = io.ErrShortWrite
ROUTINE ======================== os.(*File).read in /home/isucon/.local/go/src/os/file_unix.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    223:// It returns the number of bytes read and an error, if any.
         .          .    224:func (f *File) read(b []byte) (n int, err error) {
         .          .    225:	if needsMaxRW && len(b) > maxRW {
         .          .    226:		b = b[:maxRW]
         .          .    227:	}
         .       30ms    228:	return fixCount(syscall.Read(f.fd, b))
         .          .    229:}
         .          .    230:
         .          .    231:// pread reads len(b) bytes from the File starting at byte offset off.
         .          .    232:// It returns the number of bytes read and the error, if any.
         .          .    233:// EOF is signaled by a zero count with err set to nil.
ROUTINE ======================== os.(*File).write in /home/isucon/.local/go/src/os/file_unix.go
      10ms       90ms (flat, cum)  0.16% of Total
         .          .    244:	for {
         .          .    245:		bcap := b
         .          .    246:		if needsMaxRW && len(bcap) > maxRW {
         .          .    247:			bcap = bcap[:maxRW]
         .          .    248:		}
      10ms       90ms    249:		m, err := fixCount(syscall.Write(f.fd, bcap))
         .          .    250:		n += m
         .          .    251:
         .          .    252:		// If the syscall wrote some data but not all (short write)
         .          .    253:		// or it returned EINTR, then assume it stopped early for
         .          .    254:		// reasons that are uninteresting to the caller, and try again.
ROUTINE ======================== os.(*Process).Wait in /home/isucon/.local/go/src/os/doc.go
         0      130ms (flat, cum)  0.23% of Total
         .          .     44:// ProcessState describing its status and an error, if any.
         .          .     45:// Wait releases any resources associated with the Process.
         .          .     46:// On most operating systems, the Process must be a child
         .          .     47:// of the current process or an error will be returned.
         .          .     48:func (p *Process) Wait() (*ProcessState, error) {
         .      130ms     49:	return p.wait()
         .          .     50:}
         .          .     51:
         .          .     52:// Signal sends a signal to the Process.
         .          .     53:// Sending Interrupt on Windows is not implemented.
         .          .     54:func (p *Process) Signal(sig Signal) error {
ROUTINE ======================== os.(*Process).wait in /home/isucon/.local/go/src/os/exec_unix.go
         0      130ms (flat, cum)  0.23% of Total
         .          .     17:	if p.Pid == -1 {
         .          .     18:		return nil, syscall.EINVAL
         .          .     19:	}
         .          .     20:	var status syscall.WaitStatus
         .          .     21:	var rusage syscall.Rusage
         .      120ms     22:	pid1, e := syscall.Wait4(p.Pid, &status, 0, &rusage)
         .          .     23:	if e != nil {
         .          .     24:		return nil, NewSyscallError("wait", e)
         .          .     25:	}
         .          .     26:	if pid1 != 0 {
         .          .     27:		p.setDone()
         .          .     28:	}
         .          .     29:	ps = &ProcessState{
         .          .     30:		pid:    pid1,
         .          .     31:		status: status,
         .       10ms     32:		rusage: &rusage,
         .          .     33:	}
         .          .     34:	return ps, nil
         .          .     35:}
         .          .     36:
         .          .     37:var errFinished = errors.New("os: process already finished")
ROUTINE ======================== os.(*file).close in /home/isucon/.local/go/src/os/file_unix.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    135:func (file *file) close() error {
         .          .    136:	if file == nil || file.fd < 0 {
         .          .    137:		return syscall.EINVAL
         .          .    138:	}
         .          .    139:	var err error
         .       10ms    140:	if e := syscall.Close(file.fd); e != nil {
         .          .    141:		err = &PathError{"close", file.name, e}
         .          .    142:	}
         .          .    143:	file.fd = -1 // so it can't be closed again
         .          .    144:
         .          .    145:	// no need for a finalizer anymore
         .       10ms    146:	runtime.SetFinalizer(file, nil)
         .          .    147:	return err
         .          .    148:}
         .          .    149:
         .          .    150:// Stat returns the FileInfo structure describing file.
         .          .    151:// If there is an error, it will be of type *PathError.
ROUTINE ======================== os.NewFile in /home/isucon/.local/go/src/os/file_unix.go
         0       30ms (flat, cum) 0.054% of Total
         .          .     51:func NewFile(fd uintptr, name string) *File {
         .          .     52:	fdi := int(fd)
         .          .     53:	if fdi < 0 {
         .          .     54:		return nil
         .          .     55:	}
         .       20ms     56:	f := &File{&file{fd: fdi, name: name}}
         .       10ms     57:	runtime.SetFinalizer(f.file, (*file).close)
         .          .     58:	return f
         .          .     59:}
         .          .     60:
         .          .     61:// Auxiliary information if the File describes a directory
         .          .     62:type dirInfo struct {
ROUTINE ======================== os.Open in /home/isucon/.local/go/src/os/file.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    239:// Open opens the named file for reading.  If successful, methods on
         .          .    240:// the returned file can be used for reading; the associated file
         .          .    241:// descriptor has mode O_RDONLY.
         .          .    242:// If there is an error, it will be of type *PathError.
         .          .    243:func Open(name string) (*File, error) {
         .       10ms    244:	return OpenFile(name, O_RDONLY, 0)
         .          .    245:}
         .          .    246:
         .          .    247:// Create creates the named file with mode 0666 (before umask), truncating
         .          .    248:// it if it already exists. If successful, methods on the returned
         .          .    249:// File can be used for I/O; the associated file descriptor has mode
ROUTINE ======================== os.OpenFile in /home/isucon/.local/go/src/os/file_unix.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    118:	// content to live with.  See ../syscall/exec_unix.go.
         .          .    119:	if !supportsCloseOnExec {
         .          .    120:		syscall.CloseOnExec(r)
         .          .    121:	}
         .          .    122:
         .       10ms    123:	return NewFile(uintptr(r), name), nil
         .          .    124:}
         .          .    125:
         .          .    126:// Close closes the File, rendering it unusable for I/O.
         .          .    127:// It returns an error, if any.
         .          .    128:func (f *File) Close() error {
ROUTINE ======================== os.Pipe in /home/isucon/.local/go/src/os/pipe_linux.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     27:		syscall.ForkLock.RUnlock()
         .          .     28:	} else if e != nil {
         .          .     29:		return nil, nil, NewSyscallError("pipe2", e)
         .          .     30:	}
         .          .     31:
         .       20ms     32:	return NewFile(uintptr(p[0]), "|0"), NewFile(uintptr(p[1]), "|1"), nil
         .          .     33:}
ROUTINE ======================== os.StartProcess in /home/isucon/.local/go/src/os/doc.go
         0       60ms (flat, cum)  0.11% of Total
         .          .     23:// StartProcess is a low-level interface. The os/exec package provides
         .          .     24:// higher-level interfaces.
         .          .     25://
         .          .     26:// If there is an error, it will be of type *PathError.
         .          .     27:func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error) {
         .       60ms     28:	return startProcess(name, argv, attr)
         .          .     29:}
         .          .     30:
         .          .     31:// Release releases any resources associated with the Process p,
         .          .     32:// rendering it unusable in the future.
         .          .     33:// Release only needs to be called if Wait is not.
ROUTINE ======================== os.newProcess in /home/isucon/.local/go/src/os/exec.go
         0       40ms (flat, cum) 0.072% of Total
         .          .     16:	handle uintptr // handle is accessed atomically on Windows
         .          .     17:	isdone uint32  // process has been successfully waited on, non zero if true
         .          .     18:}
         .          .     19:
         .          .     20:func newProcess(pid int, handle uintptr) *Process {
         .       40ms     21:	p := &Process{Pid: pid, handle: handle}
         .          .     22:	runtime.SetFinalizer(p, (*Process).Release)
         .          .     23:	return p
         .          .     24:}
         .          .     25:
         .          .     26:func (p *Process) setDone() {
ROUTINE ======================== os.startProcess in /home/isucon/.local/go/src/os/exec_posix.go
         0       60ms (flat, cum)  0.11% of Total
         .          .     40:	}
         .          .     41:	for _, f := range attr.Files {
         .          .     42:		sysattr.Files = append(sysattr.Files, f.Fd())
         .          .     43:	}
         .          .     44:
         .       20ms     45:	pid, h, e := syscall.StartProcess(name, argv, sysattr)
         .          .     46:	if e != nil {
         .          .     47:		return nil, &PathError{"fork/exec", name, e}
         .          .     48:	}
         .       40ms     49:	return newProcess(pid, h), nil
         .          .     50:}
         .          .     51:
         .          .     52:func (p *Process) kill() error {
         .          .     53:	return p.Signal(Kill)
         .          .     54:}
ROUTINE ======================== os/exec.(*Cmd).Output in /home/isucon/.local/go/src/os/exec/exec.go
         0      220ms (flat, cum)   0.4% of Total
         .          .    427:	captureErr := c.Stderr == nil
         .          .    428:	if captureErr {
         .          .    429:		c.Stderr = &prefixSuffixSaver{N: 32 << 10}
         .          .    430:	}
         .          .    431:
         .      220ms    432:	err := c.Run()
         .          .    433:	if err != nil && captureErr {
         .          .    434:		if ee, ok := err.(*ExitError); ok {
         .          .    435:			ee.Stderr = c.Stderr.(*prefixSuffixSaver).Bytes()
         .          .    436:		}
         .          .    437:	}
ROUTINE ======================== os/exec.(*Cmd).Run in /home/isucon/.local/go/src/os/exec/exec.go
         0      220ms (flat, cum)   0.4% of Total
         .          .    254://
         .          .    255:// If the command fails to run or doesn't complete successfully, the
         .          .    256:// error is of type *ExitError. Other error types may be
         .          .    257:// returned for I/O problems.
         .          .    258:func (c *Cmd) Run() error {
         .       90ms    259:	if err := c.Start(); err != nil {
         .          .    260:		return err
         .          .    261:	}
         .      130ms    262:	return c.Wait()
         .          .    263:}
         .          .    264:
         .          .    265:// lookExtensions finds windows executable by its dir and path.
         .          .    266:// It uses LookPath to try appropriate extensions.
         .          .    267:// lookExtensions does not search PATH, instead it converts `prog` into `.\prog`.
ROUTINE ======================== os/exec.(*Cmd).Start in /home/isucon/.local/go/src/os/exec/exec.go
         0       90ms (flat, cum)  0.16% of Total
         .          .    311:		return errors.New("exec: already started")
         .          .    312:	}
         .          .    313:
         .          .    314:	type F func(*Cmd) (*os.File, error)
         .          .    315:	for _, setupFd := range []F{(*Cmd).stdin, (*Cmd).stdout, (*Cmd).stderr} {
         .       20ms    316:		fd, err := setupFd(c)
         .          .    317:		if err != nil {
         .          .    318:			c.closeDescriptors(c.closeAfterStart)
         .          .    319:			c.closeDescriptors(c.closeAfterWait)
         .          .    320:			return err
         .          .    321:		}
         .          .    322:		c.childFiles = append(c.childFiles, fd)
         .          .    323:	}
         .          .    324:	c.childFiles = append(c.childFiles, c.ExtraFiles...)
         .          .    325:
         .          .    326:	var err error
         .          .    327:	c.Process, err = os.StartProcess(c.Path, c.argv(), &os.ProcAttr{
         .          .    328:		Dir:   c.Dir,
         .          .    329:		Files: c.childFiles,
         .          .    330:		Env:   c.envv(),
         .          .    331:		Sys:   c.SysProcAttr,
         .       60ms    332:	})
         .          .    333:	if err != nil {
         .          .    334:		c.closeDescriptors(c.closeAfterStart)
         .          .    335:		c.closeDescriptors(c.closeAfterWait)
         .          .    336:		return err
         .          .    337:	}
         .          .    338:
         .       10ms    339:	c.closeDescriptors(c.closeAfterStart)
         .          .    340:
         .          .    341:	c.errch = make(chan error, len(c.goroutine))
         .          .    342:	for _, fn := range c.goroutine {
         .          .    343:		go func(fn func() error) {
         .          .    344:			c.errch <- fn()
ROUTINE ======================== os/exec.(*Cmd).Start.func1 in /home/isucon/.local/go/src/os/exec/exec.go
         0      120ms (flat, cum)  0.22% of Total
         .          .    339:	c.closeDescriptors(c.closeAfterStart)
         .          .    340:
         .          .    341:	c.errch = make(chan error, len(c.goroutine))
         .          .    342:	for _, fn := range c.goroutine {
         .          .    343:		go func(fn func() error) {
         .      120ms    344:			c.errch <- fn()
         .          .    345:		}(fn)
         .          .    346:	}
         .          .    347:
         .          .    348:	return nil
         .          .    349:}
ROUTINE ======================== os/exec.(*Cmd).Wait in /home/isucon/.local/go/src/os/exec/exec.go
         0      130ms (flat, cum)  0.23% of Total
         .          .    391:	}
         .          .    392:	if c.finished {
         .          .    393:		return errors.New("exec: Wait was already called")
         .          .    394:	}
         .          .    395:	c.finished = true
         .      130ms    396:	state, err := c.Process.Wait()
         .          .    397:	c.ProcessState = state
         .          .    398:
         .          .    399:	var copyError error
         .          .    400:	for range c.goroutine {
         .          .    401:		if err := <-c.errch; err != nil && copyError == nil {
ROUTINE ======================== os/exec.(*Cmd).closeDescriptors in /home/isucon/.local/go/src/os/exec/exec.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    240:	return pw, nil
         .          .    241:}
         .          .    242:
         .          .    243:func (c *Cmd) closeDescriptors(closers []io.Closer) {
         .          .    244:	for _, fd := range closers {
         .       10ms    245:		fd.Close()
         .          .    246:	}
         .          .    247:}
         .          .    248:
         .          .    249:// Run starts the specified command and waits for it to complete.
         .          .    250://
ROUTINE ======================== os/exec.(*Cmd).stderr in /home/isucon/.local/go/src/os/exec/exec.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    206:
         .          .    207:func (c *Cmd) stderr() (f *os.File, err error) {
         .          .    208:	if c.Stderr != nil && interfaceEqual(c.Stderr, c.Stdout) {
         .          .    209:		return c.childFiles[1], nil
         .          .    210:	}
         .       10ms    211:	return c.writerDescriptor(c.Stderr)
         .          .    212:}
         .          .    213:
         .          .    214:func (c *Cmd) writerDescriptor(w io.Writer) (f *os.File, err error) {
         .          .    215:	if w == nil {
         .          .    216:		f, err = os.OpenFile(os.DevNull, os.O_WRONLY, 0)
ROUTINE ======================== os/exec.(*Cmd).stdout in /home/isucon/.local/go/src/os/exec/exec.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    199:	})
         .          .    200:	return pr, nil
         .          .    201:}
         .          .    202:
         .          .    203:func (c *Cmd) stdout() (f *os.File, err error) {
         .       10ms    204:	return c.writerDescriptor(c.Stdout)
         .          .    205:}
         .          .    206:
         .          .    207:func (c *Cmd) stderr() (f *os.File, err error) {
         .          .    208:	if c.Stderr != nil && interfaceEqual(c.Stderr, c.Stdout) {
         .          .    209:		return c.childFiles[1], nil
ROUTINE ======================== os/exec.(*Cmd).writerDescriptor in /home/isucon/.local/go/src/os/exec/exec.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    223:
         .          .    224:	if f, ok := w.(*os.File); ok {
         .          .    225:		return f, nil
         .          .    226:	}
         .          .    227:
         .       20ms    228:	pr, pw, err := os.Pipe()
         .          .    229:	if err != nil {
         .          .    230:		return
         .          .    231:	}
         .          .    232:
         .          .    233:	c.closeAfterStart = append(c.closeAfterStart, pw)
ROUTINE ======================== os/exec.(*Cmd).writerDescriptor.func1 in /home/isucon/.local/go/src/os/exec/exec.go
         0      120ms (flat, cum)  0.22% of Total
         .          .    231:	}
         .          .    232:
         .          .    233:	c.closeAfterStart = append(c.closeAfterStart, pw)
         .          .    234:	c.closeAfterWait = append(c.closeAfterWait, pr)
         .          .    235:	c.goroutine = append(c.goroutine, func() error {
         .      120ms    236:		_, err := io.Copy(w, pr)
         .          .    237:		pr.Close() // in case io.Copy stopped due to write error
         .          .    238:		return err
         .          .    239:	})
         .          .    240:	return pw, nil
         .          .    241:}
ROUTINE ======================== path.Clean in /home/isucon/.local/go/src/path/path.go
      20ms       20ms (flat, cum) 0.036% of Total
         .          .    114:				dotdot = out.w
         .          .    115:			}
         .          .    116:		default:
         .          .    117:			// real path element.
         .          .    118:			// add slash if needed
      10ms       10ms    119:			if rooted && out.w != 1 || !rooted && out.w != 0 {
      10ms       10ms    120:				out.append('/')
         .          .    121:			}
         .          .    122:			// copy element
         .          .    123:			for ; r < n && path[r] != '/'; r++ {
         .          .    124:				out.append(path[r])
         .          .    125:			}
ROUTINE ======================== path.Join in /home/isucon/.local/go/src/path/path.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    148:// separating slash if necessary. The result is Cleaned; in particular,
         .          .    149:// all empty strings are ignored.
         .          .    150:func Join(elem ...string) string {
         .          .    151:	for i, e := range elem {
         .          .    152:		if e != "" {
         .       10ms    153:			return Clean(strings.Join(elem[i:], "/"))
         .          .    154:		}
         .          .    155:	}
         .          .    156:	return ""
         .          .    157:}
         .          .    158:
ROUTINE ======================== path/filepath.Ext in /home/isucon/.local/go/src/path/filepath/path.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    209:// Ext returns the file name extension used by path.
         .          .    210:// The extension is the suffix beginning at the final dot
         .          .    211:// in the final element of path; it is empty if there is
         .          .    212:// no dot.
         .          .    213:func Ext(path string) string {
      10ms       10ms    214:	for i := len(path) - 1; i >= 0 && !os.IsPathSeparator(path[i]); i-- {
         .          .    215:		if path[i] == '.' {
         .          .    216:			return path[i:]
         .          .    217:		}
         .          .    218:	}
         .          .    219:	return ""
ROUTINE ======================== reflect.(*rtype).AssignableTo in /home/isucon/.local/go/src/reflect/type.go
     170ms      500ms (flat, cum)   0.9% of Total
         .          .   1110:		panic("reflect: non-interface type passed to Type.Implements")
         .          .   1111:	}
         .          .   1112:	return implements(u.(*rtype), t)
         .          .   1113:}
         .          .   1114:
      30ms       30ms   1115:func (t *rtype) AssignableTo(u Type) bool {
         .          .   1116:	if u == nil {
         .          .   1117:		panic("reflect: nil type passed to Type.AssignableTo")
         .          .   1118:	}
      20ms       20ms   1119:	uu := u.(*rtype)
     120ms      450ms   1120:	return directlyAssignable(uu, t) || implements(uu, t)
         .          .   1121:}
         .          .   1122:
         .          .   1123:func (t *rtype) ConvertibleTo(u Type) bool {
         .          .   1124:	if u == nil {
         .          .   1125:		panic("reflect: nil type passed to Type.ConvertibleTo")
ROUTINE ======================== reflect.(*rtype).Bits in /home/isucon/.local/go/src/reflect/type.go
      80ms       80ms (flat, cum)  0.14% of Total
         .          .    462:
         .          .    463:func (t *rtype) String() string { return *t.string }
         .          .    464:
         .          .    465:func (t *rtype) Size() uintptr { return t.size }
         .          .    466:
      30ms       30ms    467:func (t *rtype) Bits() int {
         .          .    468:	if t == nil {
         .          .    469:		panic("reflect: Bits of nil Type")
         .          .    470:	}
      50ms       50ms    471:	k := t.Kind()
         .          .    472:	if k < Int || k > Complex128 {
         .          .    473:		panic("reflect: Bits of non-arithmetic Type " + t.String())
         .          .    474:	}
         .          .    475:	return int(t.size) * 8
         .          .    476:}
ROUTINE ======================== reflect.(*rtype).Elem in /home/isucon/.local/go/src/reflect/type.go
      20ms       20ms (flat, cum) 0.036% of Total
         .          .    576:	}
         .          .    577:	tt := (*funcType)(unsafe.Pointer(t))
         .          .    578:	return tt.dotdotdot
         .          .    579:}
         .          .    580:
      10ms       10ms    581:func (t *rtype) Elem() Type {
         .          .    582:	switch t.Kind() {
         .          .    583:	case Array:
         .          .    584:		tt := (*arrayType)(unsafe.Pointer(t))
         .          .    585:		return toType(tt.elem)
         .          .    586:	case Chan:
         .          .    587:		tt := (*chanType)(unsafe.Pointer(t))
         .          .    588:		return toType(tt.elem)
         .          .    589:	case Map:
         .          .    590:		tt := (*mapType)(unsafe.Pointer(t))
         .          .    591:		return toType(tt.elem)
         .          .    592:	case Ptr:
         .          .    593:		tt := (*ptrType)(unsafe.Pointer(t))
         .          .    594:		return toType(tt.elem)
         .          .    595:	case Slice:
         .          .    596:		tt := (*sliceType)(unsafe.Pointer(t))
      10ms       10ms    597:		return toType(tt.elem)
         .          .    598:	}
         .          .    599:	panic("reflect: Elem of invalid type")
         .          .    600:}
         .          .    601:
         .          .    602:func (t *rtype) Field(i int) StructField {
ROUTINE ======================== reflect.(*rtype).FieldByName in /home/isucon/.local/go/src/reflect/type.go
         0       50ms (flat, cum)  0.09% of Total
         .          .    618:func (t *rtype) FieldByName(name string) (StructField, bool) {
         .          .    619:	if t.Kind() != Struct {
         .          .    620:		panic("reflect: FieldByName of non-struct type")
         .          .    621:	}
         .          .    622:	tt := (*structType)(unsafe.Pointer(t))
         .       50ms    623:	return tt.FieldByName(name)
         .          .    624:}
         .          .    625:
         .          .    626:func (t *rtype) FieldByNameFunc(match func(string) bool) (StructField, bool) {
         .          .    627:	if t.Kind() != Struct {
         .          .    628:		panic("reflect: FieldByNameFunc of non-struct type")
ROUTINE ======================== reflect.(*rtype).Implements in /home/isucon/.local/go/src/reflect/type.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .   1107:		panic("reflect: nil type passed to Type.Implements")
         .          .   1108:	}
         .          .   1109:	if u.Kind() != Interface {
         .          .   1110:		panic("reflect: non-interface type passed to Type.Implements")
         .          .   1111:	}
      10ms       10ms   1112:	return implements(u.(*rtype), t)
         .          .   1113:}
         .          .   1114:
         .          .   1115:func (t *rtype) AssignableTo(u Type) bool {
         .          .   1116:	if u == nil {
         .          .   1117:		panic("reflect: nil type passed to Type.AssignableTo")
ROUTINE ======================== reflect.(*rtype).In in /home/isucon/.local/go/src/reflect/type.go
      20ms       20ms (flat, cum) 0.036% of Total
         .          .    634:func (t *rtype) In(i int) Type {
         .          .    635:	if t.Kind() != Func {
         .          .    636:		panic("reflect: In of non-func type")
         .          .    637:	}
         .          .    638:	tt := (*funcType)(unsafe.Pointer(t))
      20ms       20ms    639:	return toType(tt.in[i])
         .          .    640:}
         .          .    641:
         .          .    642:func (t *rtype) Key() Type {
         .          .    643:	if t.Kind() != Map {
         .          .    644:		panic("reflect: Key of non-map type")
ROUTINE ======================== reflect.(*rtype).IsVariadic in /home/isucon/.local/go/src/reflect/type.go
      20ms       20ms (flat, cum) 0.036% of Total
         .          .    568:	}
         .          .    569:	tt := (*chanType)(unsafe.Pointer(t))
         .          .    570:	return ChanDir(tt.dir)
         .          .    571:}
         .          .    572:
      10ms       10ms    573:func (t *rtype) IsVariadic() bool {
      10ms       10ms    574:	if t.Kind() != Func {
         .          .    575:		panic("reflect: IsVariadic of non-func type")
         .          .    576:	}
         .          .    577:	tt := (*funcType)(unsafe.Pointer(t))
         .          .    578:	return tt.dotdotdot
         .          .    579:}
ROUTINE ======================== reflect.(*rtype).Kind in /home/isucon/.local/go/src/reflect/type.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    477:
         .          .    478:func (t *rtype) Align() int { return int(t.align) }
         .          .    479:
         .          .    480:func (t *rtype) FieldAlign() int { return int(t.fieldAlign) }
         .          .    481:
      10ms       10ms    482:func (t *rtype) Kind() Kind { return Kind(t.kind & kindMask) }
         .          .    483:
         .          .    484:func (t *rtype) pointers() bool { return t.kind&kindNoPointers == 0 }
         .          .    485:
         .          .    486:func (t *rtype) common() *rtype { return t }
         .          .    487:
ROUTINE ======================== reflect.(*rtype).MethodByName in /home/isucon/.local/go/src/reflect/type.go
      20ms       30ms (flat, cum) 0.054% of Total
         .          .    545:	}
         .          .    546:	return t.uncommonType.Method(i)
         .          .    547:}
         .          .    548:
         .          .    549:func (t *rtype) MethodByName(name string) (m Method, ok bool) {
      10ms       10ms    550:	if t.Kind() == Interface {
         .          .    551:		tt := (*interfaceType)(unsafe.Pointer(t))
         .          .    552:		return tt.MethodByName(name)
         .          .    553:	}
      10ms       20ms    554:	return t.uncommonType.MethodByName(name)
         .          .    555:}
         .          .    556:
         .          .    557:func (t *rtype) PkgPath() string {
         .          .    558:	return t.uncommonType.PkgPath()
         .          .    559:}
ROUTINE ======================== reflect.(*rtype).Out in /home/isucon/.local/go/src/reflect/type.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    682:func (t *rtype) Out(i int) Type {
         .          .    683:	if t.Kind() != Func {
         .          .    684:		panic("reflect: Out of non-func type")
         .          .    685:	}
         .          .    686:	tt := (*funcType)(unsafe.Pointer(t))
      10ms       10ms    687:	return toType(tt.out[i])
         .          .    688:}
         .          .    689:
         .          .    690:func (d ChanDir) String() string {
         .          .    691:	switch d {
         .          .    692:	case SendDir:
ROUTINE ======================== reflect.(*rtype).Size in /home/isucon/.local/go/src/reflect/type.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    460:	return *t.name
         .          .    461:}
         .          .    462:
         .          .    463:func (t *rtype) String() string { return *t.string }
         .          .    464:
      10ms       10ms    465:func (t *rtype) Size() uintptr { return t.size }
         .          .    466:
         .          .    467:func (t *rtype) Bits() int {
         .          .    468:	if t == nil {
         .          .    469:		panic("reflect: Bits of nil Type")
         .          .    470:	}
ROUTINE ======================== reflect.(*rtype).common in /home/isucon/.local/go/src/reflect/type.go
      20ms       20ms (flat, cum) 0.036% of Total
         .          .    481:
         .          .    482:func (t *rtype) Kind() Kind { return Kind(t.kind & kindMask) }
         .          .    483:
         .          .    484:func (t *rtype) pointers() bool { return t.kind&kindNoPointers == 0 }
         .          .    485:
      20ms       20ms    486:func (t *rtype) common() *rtype { return t }
         .          .    487:
         .          .    488:func (t *uncommonType) Method(i int) (m Method) {
         .          .    489:	if t == nil || i < 0 || i >= len(t.methods) {
         .          .    490:		panic("reflect: Method index out of range")
         .          .    491:	}
ROUTINE ======================== reflect.(*rtype).ptrTo in /home/isucon/.local/go/src/reflect/type.go
     100ms      100ms (flat, cum)  0.18% of Total
         .          .   1027:// For example, if t represents type Foo, PtrTo(t) represents *Foo.
         .          .   1028:func PtrTo(t Type) Type {
         .          .   1029:	return t.(*rtype).ptrTo()
         .          .   1030:}
         .          .   1031:
      60ms       60ms   1032:func (t *rtype) ptrTo() *rtype {
      20ms       20ms   1033:	if p := t.ptrToThis; p != nil {
      20ms       20ms   1034:		return p
         .          .   1035:	}
         .          .   1036:
         .          .   1037:	// Otherwise, synthesize one.
         .          .   1038:	// This only happens for pointers with no methods.
         .          .   1039:	// We keep the mapping in a map on the side, because
ROUTINE ======================== reflect.(*structType).Field in /home/isucon/.local/go/src/reflect/type.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    846:	// at least in the common cases, but we need to make sure
         .          .    847:	// that misbehaving clients of reflect cannot affect other
         .          .    848:	// uses of reflect.  One possibility is CL 5371098, but we
         .          .    849:	// postponed that ugliness until there is a demonstrated
         .          .    850:	// need for the performance.  This is issue 2320.
         .       20ms    851:	f.Index = []int{i}
         .          .    852:	return
         .          .    853:}
         .          .    854:
         .          .    855:// TODO(gri): Should there be an error/bool indicator if the index
         .          .    856://            is wrong for FieldByIndex?
ROUTINE ======================== reflect.(*structType).FieldByName in /home/isucon/.local/go/src/reflect/type.go
      10ms       40ms (flat, cum) 0.072% of Total
         .          .    997:			tf := &t.fields[i]
         .          .    998:			if tf.name == nil {
         .          .    999:				hasAnon = true
         .          .   1000:				continue
         .          .   1001:			}
      10ms       20ms   1002:			if *tf.name == name {
         .       20ms   1003:				return t.Field(i), true
         .          .   1004:			}
         .          .   1005:		}
         .          .   1006:	}
         .          .   1007:	if !hasAnon {
         .          .   1008:		return
ROUTINE ======================== reflect.(*uncommonType).MethodByName in /home/isucon/.local/go/src/reflect/type.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    511:		return 0
         .          .    512:	}
         .          .    513:	return len(t.methods)
         .          .    514:}
         .          .    515:
         .       10ms    516:func (t *uncommonType) MethodByName(name string) (m Method, ok bool) {
         .          .    517:	if t == nil {
         .          .    518:		return
         .          .    519:	}
         .          .    520:	var p *method
         .          .    521:	for i := range t.methods {
ROUTINE ======================== reflect.Append in /home/isucon/.local/go/src/reflect/value.go
      70ms      6.65s (flat, cum) 11.95% of Total
         .          .   1809:}
         .          .   1810:
         .          .   1811:// Append appends the values x to a slice s and returns the resulting slice.
         .          .   1812:// As in Go, each x's value must be assignable to the slice's element type.
         .          .   1813:func Append(s Value, x ...Value) Value {
      10ms       20ms   1814:	s.mustBe(Slice)
      50ms      6.19s   1815:	s, i0, i1 := grow(s, len(x))
         .          .   1816:	for i, j := i0, 0; i < i1; i, j = i+1, j+1 {
      10ms      440ms   1817:		s.Index(i).Set(x[j])
         .          .   1818:	}
         .          .   1819:	return s
         .          .   1820:}
         .          .   1821:
         .          .   1822:// AppendSlice appends a slice t to a slice s and returns the resulting slice.
ROUTINE ======================== reflect.Copy in /home/isucon/.local/go/src/reflect/value.go
      10ms      1.60s (flat, cum)  2.88% of Total
         .          .   1866:	if sk == Array {
         .          .   1867:		ss.Data = src.ptr
         .          .   1868:		ss.Len = src.Len()
         .          .   1869:		ss.Cap = ss.Len
         .          .   1870:	} else {
      10ms       10ms   1871:		ss = *(*sliceHeader)(src.ptr)
         .          .   1872:	}
         .          .   1873:
         .      1.59s   1874:	return typedslicecopy(de.common(), ds, ss)
         .          .   1875:}
         .          .   1876:
         .          .   1877:// A runtimeSelect is a single case passed to rselect.
         .          .   1878:// This must match ../runtime/select.go:/runtimeSelect
         .          .   1879:type runtimeSelect struct {
ROUTINE ======================== reflect.Indirect in /home/isucon/.local/go/src/reflect/value.go
     380ms      530ms (flat, cum)  0.95% of Total
         .          .   2070:}
         .          .   2071:
         .          .   2072:// Indirect returns the value that v points to.
         .          .   2073:// If v is a nil pointer, Indirect returns a zero Value.
         .          .   2074:// If v is not a pointer, Indirect returns v.
     190ms      190ms   2075:func Indirect(v Value) Value {
      40ms       40ms   2076:	if v.Kind() != Ptr {
      70ms       70ms   2077:		return v
         .          .   2078:	}
      80ms      230ms   2079:	return v.Elem()
         .          .   2080:}
         .          .   2081:
         .          .   2082:// ValueOf returns a new Value initialized to the concrete value
         .          .   2083:// stored in the interface i.  ValueOf(nil) returns the zero Value.
         .          .   2084:func ValueOf(i interface{}) Value {
ROUTINE ======================== reflect.MakeSlice in /home/isucon/.local/go/src/reflect/value.go
      20ms      3.58s (flat, cum)  6.43% of Total
         .          .   2032:		panic("reflect.MakeSlice of non-slice type")
         .          .   2033:	}
         .          .   2034:	if len < 0 {
         .          .   2035:		panic("reflect.MakeSlice: negative len")
         .          .   2036:	}
      10ms       10ms   2037:	if cap < 0 {
         .          .   2038:		panic("reflect.MakeSlice: negative cap")
         .          .   2039:	}
         .          .   2040:	if len > cap {
         .          .   2041:		panic("reflect.MakeSlice: len > cap")
         .          .   2042:	}
         .          .   2043:
         .      3.56s   2044:	s := sliceHeader{unsafe_NewArray(typ.Elem().(*rtype), cap), len, cap}
      10ms       10ms   2045:	return Value{typ.common(), unsafe.Pointer(&s), flagIndir | flag(Slice)}
         .          .   2046:}
         .          .   2047:
         .          .   2048:// MakeChan creates a new channel with the specified type and buffer size.
         .          .   2049:func MakeChan(typ Type, buffer int) Value {
         .          .   2050:	if typ.Kind() != Chan {
ROUTINE ======================== reflect.New in /home/isucon/.local/go/src/reflect/value.go
     100ms      1.64s (flat, cum)  2.95% of Total
         .          .   2112:	return Value{t, nil, fl}
         .          .   2113:}
         .          .   2114:
         .          .   2115:// New returns a Value representing a pointer to a new zero value
         .          .   2116:// for the specified type.  That is, the returned Value's Type is PtrTo(typ).
      30ms       30ms   2117:func New(typ Type) Value {
         .          .   2118:	if typ == nil {
         .          .   2119:		panic("reflect: New(nil)")
         .          .   2120:	}
      20ms      1.52s   2121:	ptr := unsafe_New(typ.(*rtype))
         .          .   2122:	fl := flag(Ptr)
      50ms       90ms   2123:	return Value{typ.common().ptrTo(), ptr, fl}
         .          .   2124:}
         .          .   2125:
         .          .   2126:// NewAt returns a Value representing a pointer to a value of the
         .          .   2127:// specified type, using p as that pointer.
         .          .   2128:func NewAt(typ Type, p unsafe.Pointer) Value {
ROUTINE ======================== reflect.PtrTo in /home/isucon/.local/go/src/reflect/type.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .   1024:}
         .          .   1025:
         .          .   1026:// PtrTo returns the pointer type with element t.
         .          .   1027:// For example, if t represents type Foo, PtrTo(t) represents *Foo.
         .          .   1028:func PtrTo(t Type) Type {
      10ms       10ms   1029:	return t.(*rtype).ptrTo()
         .          .   1030:}
         .          .   1031:
         .          .   1032:func (t *rtype) ptrTo() *rtype {
         .          .   1033:	if p := t.ptrToThis; p != nil {
         .          .   1034:		return p
ROUTINE ======================== reflect.Value.Addr in /home/isucon/.local/go/src/reflect/value.go
     170ms      250ms (flat, cum)  0.45% of Total
         .          .    233:// Addr returns a pointer value representing the address of v.
         .          .    234:// It panics if CanAddr() returns false.
         .          .    235:// Addr is typically used to obtain a pointer to a struct field
         .          .    236:// or slice element in order to call a method that requires a
         .          .    237:// pointer receiver.
     100ms      100ms    238:func (v Value) Addr() Value {
      40ms       40ms    239:	if v.flag&flagAddr == 0 {
         .          .    240:		panic("reflect.Value.Addr of unaddressable value")
         .          .    241:	}
      30ms      110ms    242:	return Value{v.typ.ptrTo(), v.ptr, (v.flag & flagRO) | flag(Ptr)}
         .          .    243:}
         .          .    244:
         .          .    245:// Bool returns v's underlying value.
         .          .    246:// It panics if v's kind is not Bool.
         .          .    247:func (v Value) Bool() bool {
ROUTINE ======================== reflect.Value.Call in /home/isucon/.local/go/src/reflect/value.go
         0      850ms (flat, cum)  1.53% of Total
         .          .    298:// If v is a variadic function, Call creates the variadic slice parameter
         .          .    299:// itself, copying in the corresponding values.
         .          .    300:func (v Value) Call(in []Value) []Value {
         .          .    301:	v.mustBe(Func)
         .          .    302:	v.mustBeExported()
         .      850ms    303:	return v.call("Call", in)
         .          .    304:}
         .          .    305:
         .          .    306:// CallSlice calls the variadic function v with the input arguments in,
         .          .    307:// assigning the slice in[len(in)-1] to v's final variadic argument.
         .          .    308:// For example, if len(in) == 3, v.CallSlice(in) represents the Go call v(in[0], in[1], in[2]...).
ROUTINE ======================== reflect.Value.Cap in /home/isucon/.local/go/src/reflect/value.go
      20ms       20ms (flat, cum) 0.036% of Total
         .          .    666:	switch k {
         .          .    667:	case Array:
         .          .    668:		return v.typ.Len()
         .          .    669:	case Chan:
         .          .    670:		return int(chancap(v.pointer()))
      10ms       10ms    671:	case Slice:
         .          .    672:		// Slice is always bigger than a word; assume flagIndir.
      10ms       10ms    673:		return (*sliceHeader)(v.ptr).Cap
         .          .    674:	}
         .          .    675:	panic(&ValueError{"reflect.Value.Cap", v.kind()})
         .          .    676:}
         .          .    677:
         .          .    678:// Close closes the channel v.
ROUTINE ======================== reflect.Value.Elem in /home/isucon/.local/go/src/reflect/value.go
     150ms      150ms (flat, cum)  0.27% of Total
         .          .    698:
         .          .    699:// Elem returns the value that the interface v contains
         .          .    700:// or that the pointer v points to.
         .          .    701:// It panics if v's Kind is not Interface or Ptr.
         .          .    702:// It returns the zero Value if v is nil.
      40ms       40ms    703:func (v Value) Elem() Value {
         .          .    704:	k := v.kind()
         .          .    705:	switch k {
         .          .    706:	case Interface:
         .          .    707:		var eface interface{}
         .          .    708:		if v.typ.NumMethod() == 0 {
         .          .    709:			eface = *(*interface{})(v.ptr)
         .          .    710:		} else {
         .          .    711:			eface = (interface{})(*(*interface {
         .          .    712:				M()
         .          .    713:			})(v.ptr))
         .          .    714:		}
         .          .    715:		x := unpackEface(eface)
         .          .    716:		if x.flag != 0 {
         .          .    717:			x.flag |= v.flag & flagRO
         .          .    718:		}
         .          .    719:		return x
         .          .    720:	case Ptr:
         .          .    721:		ptr := v.ptr
         .          .    722:		if v.flag&flagIndir != 0 {
         .          .    723:			ptr = *(*unsafe.Pointer)(ptr)
         .          .    724:		}
         .          .    725:		// The returned value's address is v's value.
         .          .    726:		if ptr == nil {
         .          .    727:			return Value{}
         .          .    728:		}
         .          .    729:		tt := (*ptrType)(unsafe.Pointer(v.typ))
      20ms       20ms    730:		typ := tt.elem
      20ms       20ms    731:		fl := v.flag&flagRO | flagIndir | flagAddr
      60ms       60ms    732:		fl |= flag(typ.Kind())
      10ms       10ms    733:		return Value{typ, ptr, fl}
         .          .    734:	}
         .          .    735:	panic(&ValueError{"reflect.Value.Elem", v.kind()})
         .          .    736:}
         .          .    737:
         .          .    738:// Field returns the i'th field of the struct v.
ROUTINE ======================== reflect.Value.Field in /home/isucon/.local/go/src/reflect/value.go
     400ms      400ms (flat, cum)  0.72% of Total
         .          .    735:	panic(&ValueError{"reflect.Value.Elem", v.kind()})
         .          .    736:}
         .          .    737:
         .          .    738:// Field returns the i'th field of the struct v.
         .          .    739:// It panics if v's Kind is not Struct or i is out of range.
     130ms      130ms    740:func (v Value) Field(i int) Value {
         .          .    741:	if v.kind() != Struct {
         .          .    742:		panic(&ValueError{"reflect.Value.Field", v.kind()})
         .          .    743:	}
         .          .    744:	tt := (*structType)(unsafe.Pointer(v.typ))
      20ms       20ms    745:	if uint(i) >= uint(len(tt.fields)) {
         .          .    746:		panic("reflect: Field index out of range")
         .          .    747:	}
      20ms       20ms    748:	field := &tt.fields[i]
         .          .    749:	typ := field.typ
         .          .    750:
         .          .    751:	// Inherit permission bits from v, but clear flagEmbedRO.
     180ms      180ms    752:	fl := v.flag&(flagStickyRO|flagIndir|flagAddr) | flag(typ.Kind())
         .          .    753:	// Using an unexported field forces flagRO.
         .          .    754:	if field.pkgPath != nil {
         .          .    755:		if field.name == nil {
         .          .    756:			fl |= flagEmbedRO
         .          .    757:		} else {
         .          .    758:			fl |= flagStickyRO
         .          .    759:		}
         .          .    760:	}
         .          .    761:	// Either flagIndir is set and v.ptr points at struct,
         .          .    762:	// or flagIndir is not set and v.ptr is the actual struct data.
         .          .    763:	// In the former case, we want v.ptr + offset.
         .          .    764:	// In the latter case, we must have field.offset = 0,
         .          .    765:	// so v.ptr + field.offset is still okay.
      40ms       40ms    766:	ptr := unsafe.Pointer(uintptr(v.ptr) + field.offset)
      10ms       10ms    767:	return Value{typ, ptr, fl}
         .          .    768:}
         .          .    769:
         .          .    770:// FieldByIndex returns the nested field corresponding to index.
         .          .    771:// It panics if v's Kind is not struct.
         .          .    772:func (v Value) FieldByIndex(index []int) Value {
ROUTINE ======================== reflect.Value.FieldByIndex in /home/isucon/.local/go/src/reflect/value.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .    767:	return Value{typ, ptr, fl}
         .          .    768:}
         .          .    769:
         .          .    770:// FieldByIndex returns the nested field corresponding to index.
         .          .    771:// It panics if v's Kind is not struct.
      10ms       10ms    772:func (v Value) FieldByIndex(index []int) Value {
         .          .    773:	if len(index) == 1 {
         .       10ms    774:		return v.Field(index[0])
         .          .    775:	}
         .          .    776:	v.mustBe(Struct)
         .          .    777:	for i, x := range index {
         .          .    778:		if i > 0 {
         .          .    779:			if v.Kind() == Ptr && v.typ.Elem().Kind() == Struct {
ROUTINE ======================== reflect.Value.Index in /home/isucon/.local/go/src/reflect/value.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    825:
         .          .    826:var uint8Type = TypeOf(uint8(0)).(*rtype)
         .          .    827:
         .          .    828:// Index returns v's i'th element.
         .          .    829:// It panics if v's Kind is not Array, Slice, or String or i is out of range.
      10ms       10ms    830:func (v Value) Index(i int) Value {
         .          .    831:	switch v.kind() {
         .          .    832:	case Array:
         .          .    833:		tt := (*arrayType)(unsafe.Pointer(v.typ))
         .          .    834:		if uint(i) >= uint(tt.len) {
         .          .    835:			panic("reflect: array index out of range")
ROUTINE ======================== reflect.Value.Int in /home/isucon/.local/go/src/reflect/value.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    871:	panic(&ValueError{"reflect.Value.Index", v.kind()})
         .          .    872:}
         .          .    873:
         .          .    874:// Int returns v's underlying value, as an int64.
         .          .    875:// It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.
      10ms       10ms    876:func (v Value) Int() int64 {
         .          .    877:	k := v.kind()
         .          .    878:	p := v.ptr
         .          .    879:	switch k {
         .          .    880:	case Int:
         .          .    881:		return int64(*(*int)(p))
ROUTINE ======================== reflect.Value.Interface in /home/isucon/.local/go/src/reflect/value.go
     170ms      870ms (flat, cum)  1.56% of Total
         .          .    902:// Interface returns v's current value as an interface{}.
         .          .    903:// It is equivalent to:
         .          .    904://	var i interface{} = (v's underlying value)
         .          .    905:// It panics if the Value was obtained by accessing
         .          .    906:// unexported struct fields.
      80ms       80ms    907:func (v Value) Interface() (i interface{}) {
      90ms      790ms    908:	return valueInterface(v, true)
         .          .    909:}
         .          .    910:
         .          .    911:func valueInterface(v Value, safe bool) interface{} {
         .          .    912:	if v.flag == 0 {
         .          .    913:		panic(&ValueError{"reflect.Value.Interface", 0})
ROUTINE ======================== reflect.Value.IsNil in /home/isucon/.local/go/src/reflect/value.go
      90ms       90ms (flat, cum)  0.16% of Total
         .          .    956:// not, IsNil panics. Note that IsNil is not always equivalent to a
         .          .    957:// regular comparison with nil in Go. For example, if v was created
         .          .    958:// by calling ValueOf with an uninitialized interface variable i,
         .          .    959:// i==nil will be true but v.IsNil will panic as v will be the zero
         .          .    960:// Value.
      10ms       10ms    961:func (v Value) IsNil() bool {
      20ms       20ms    962:	k := v.kind()
         .          .    963:	switch k {
      10ms       10ms    964:	case Chan, Func, Map, Ptr:
         .          .    965:		if v.flag&flagMethod != 0 {
         .          .    966:			return false
         .          .    967:		}
      10ms       10ms    968:		ptr := v.ptr
      10ms       10ms    969:		if v.flag&flagIndir != 0 {
         .          .    970:			ptr = *(*unsafe.Pointer)(ptr)
         .          .    971:		}
      30ms       30ms    972:		return ptr == nil
         .          .    973:	case Interface, Slice:
         .          .    974:		// Both interface and slice are nil if first word is 0.
         .          .    975:		// Both are always bigger than a word; assume flagIndir.
         .          .    976:		return *(*unsafe.Pointer)(v.ptr) == nil
         .          .    977:	}
ROUTINE ======================== reflect.Value.Len in /home/isucon/.local/go/src/reflect/value.go
      50ms       50ms (flat, cum)  0.09% of Total
         .          .    993:	return v.kind()
         .          .    994:}
         .          .    995:
         .          .    996:// Len returns v's length.
         .          .    997:// It panics if v's Kind is not Array, Chan, Map, Slice, or String.
      10ms       10ms    998:func (v Value) Len() int {
         .          .    999:	k := v.kind()
         .          .   1000:	switch k {
         .          .   1001:	case Array:
         .          .   1002:		tt := (*arrayType)(unsafe.Pointer(v.typ))
         .          .   1003:		return int(tt.len)
         .          .   1004:	case Chan:
         .          .   1005:		return chanlen(v.pointer())
         .          .   1006:	case Map:
         .          .   1007:		return maplen(v.pointer())
         .          .   1008:	case Slice:
         .          .   1009:		// Slice is bigger than a word; assume flagIndir.
      40ms       40ms   1010:		return (*sliceHeader)(v.ptr).Len
         .          .   1011:	case String:
         .          .   1012:		// String is bigger than a word; assume flagIndir.
         .          .   1013:		return (*stringHeader)(v.ptr).Len
         .          .   1014:	}
         .          .   1015:	panic(&ValueError{"reflect.Value.Len", v.kind()})
ROUTINE ======================== reflect.Value.MapKeys in /home/isucon/.local/go/src/reflect/value.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   1070:	m := v.pointer()
         .          .   1071:	mlen := int(0)
         .          .   1072:	if m != nil {
         .          .   1073:		mlen = maplen(m)
         .          .   1074:	}
         .       10ms   1075:	it := mapiterinit(v.typ, m)
         .          .   1076:	a := make([]Value, mlen)
         .          .   1077:	var i int
         .          .   1078:	for i = 0; i < len(a); i++ {
         .          .   1079:		key := mapiterkey(it)
         .          .   1080:		if key == nil {
ROUTINE ======================== reflect.Value.MethodByName in /home/isucon/.local/go/src/reflect/value.go
         0       30ms (flat, cum) 0.054% of Total
         .          .   1138:		panic(&ValueError{"reflect.Value.MethodByName", Invalid})
         .          .   1139:	}
         .          .   1140:	if v.flag&flagMethod != 0 {
         .          .   1141:		return Value{}
         .          .   1142:	}
         .       30ms   1143:	m, ok := v.typ.MethodByName(name)
         .          .   1144:	if !ok {
         .          .   1145:		return Value{}
         .          .   1146:	}
         .          .   1147:	return v.Method(m.Index)
         .          .   1148:}
ROUTINE ======================== reflect.Value.Set in /home/isucon/.local/go/src/reflect/value.go
     280ms      1.31s (flat, cum)  2.35% of Total
         .          .   1322:}
         .          .   1323:
         .          .   1324:// Set assigns x to the value v.
         .          .   1325:// It panics if CanSet returns false.
         .          .   1326:// As in Go, x's value must be assignable to v's type.
      20ms       20ms   1327:func (v Value) Set(x Value) {
         .       50ms   1328:	v.mustBeAssignable()
      20ms       80ms   1329:	x.mustBeExported() // do not let unexported x leak
         .          .   1330:	var target unsafe.Pointer
      20ms       20ms   1331:	if v.kind() == Interface {
         .          .   1332:		target = v.ptr
         .          .   1333:	}
     170ms      480ms   1334:	x = x.assignTo("reflect.Set", v.typ, target)
      10ms       10ms   1335:	if x.flag&flagIndir != 0 {
      20ms      630ms   1336:		typedmemmove(v.typ, v.ptr, x.ptr)
         .          .   1337:	} else {
         .          .   1338:		*(*unsafe.Pointer)(v.ptr) = x.ptr
         .          .   1339:	}
      20ms       20ms   1340:}
         .          .   1341:
         .          .   1342:// SetBool sets v's underlying value.
         .          .   1343:// It panics if v's Kind is not Bool or if CanSet() is false.
         .          .   1344:func (v Value) SetBool(x bool) {
         .          .   1345:	v.mustBeAssignable()
ROUTINE ======================== reflect.Value.SetInt in /home/isucon/.local/go/src/reflect/value.go
     130ms      170ms (flat, cum)  0.31% of Total
         .          .   1397:	}
         .          .   1398:}
         .          .   1399:
         .          .   1400:// SetInt sets v's underlying value to x.
         .          .   1401:// It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false.
      20ms       20ms   1402:func (v Value) SetInt(x int64) {
      40ms       80ms   1403:	v.mustBeAssignable()
      20ms       20ms   1404:	switch k := v.kind(); k {
         .          .   1405:	default:
         .          .   1406:		panic(&ValueError{"reflect.Value.SetInt", v.kind()})
         .          .   1407:	case Int:
         .          .   1408:		*(*int)(v.ptr) = int(x)
         .          .   1409:	case Int8:
         .          .   1410:		*(*int8)(v.ptr) = int8(x)
         .          .   1411:	case Int16:
         .          .   1412:		*(*int16)(v.ptr) = int16(x)
         .          .   1413:	case Int32:
         .          .   1414:		*(*int32)(v.ptr) = int32(x)
         .          .   1415:	case Int64:
         .          .   1416:		*(*int64)(v.ptr) = x
         .          .   1417:	}
      50ms       50ms   1418:}
         .          .   1419:
         .          .   1420:// SetLen sets v's length to n.
         .          .   1421:// It panics if v's Kind is not Slice or if n is negative or
         .          .   1422:// greater than the capacity of the slice.
         .          .   1423:func (v Value) SetLen(n int) {
ROUTINE ======================== reflect.Value.Slice in /home/isucon/.local/go/src/reflect/value.go
     150ms      850ms (flat, cum)  1.53% of Total
         .          .   1515:}
         .          .   1516:
         .          .   1517:// Slice returns v[i:j].
         .          .   1518:// It panics if v's Kind is not Array, Slice or String, or if v is an unaddressable array,
         .          .   1519:// or if the indexes are out of bounds.
      30ms       30ms   1520:func (v Value) Slice(i, j int) Value {
         .          .   1521:	var (
         .          .   1522:		cap  int
         .          .   1523:		typ  *sliceType
         .          .   1524:		base unsafe.Pointer
         .          .   1525:	)
         .          .   1526:	switch kind := v.kind(); kind {
         .          .   1527:	default:
         .          .   1528:		panic(&ValueError{"reflect.Value.Slice", v.kind()})
         .          .   1529:
         .          .   1530:	case Array:
         .          .   1531:		if v.flag&flagAddr == 0 {
         .          .   1532:			panic("reflect.Value.Slice: slice of unaddressable array")
         .          .   1533:		}
         .          .   1534:		tt := (*arrayType)(unsafe.Pointer(v.typ))
         .          .   1535:		cap = int(tt.len)
         .          .   1536:		typ = (*sliceType)(unsafe.Pointer(tt.slice))
         .          .   1537:		base = v.ptr
         .          .   1538:
      10ms       10ms   1539:	case Slice:
         .          .   1540:		typ = (*sliceType)(unsafe.Pointer(v.typ))
         .          .   1541:		s := (*sliceHeader)(v.ptr)
         .          .   1542:		base = unsafe.Pointer(s.Data)
         .          .   1543:		cap = s.Cap
         .          .   1544:
         .          .   1545:	case String:
         .          .   1546:		s := (*stringHeader)(v.ptr)
         .          .   1547:		if i < 0 || j < i || j > s.Len {
         .          .   1548:			panic("reflect.Value.Slice: string slice index out of bounds")
         .          .   1549:		}
         .          .   1550:		t := stringHeader{arrayAt(s.Data, i, 1), j - i}
         .          .   1551:		return Value{v.typ, unsafe.Pointer(&t), v.flag}
         .          .   1552:	}
         .          .   1553:
      20ms       20ms   1554:	if i < 0 || j < i || j > cap {
         .          .   1555:		panic("reflect.Value.Slice: slice index out of bounds")
         .          .   1556:	}
         .          .   1557:
         .          .   1558:	// Declare slice so that gc can see the base pointer in it.
      10ms      710ms   1559:	var x []unsafe.Pointer
         .          .   1560:
         .          .   1561:	// Reinterpret as *sliceHeader to edit.
         .          .   1562:	s := (*sliceHeader)(unsafe.Pointer(&x))
         .          .   1563:	s.Len = j - i
      10ms       10ms   1564:	s.Cap = cap - i
         .          .   1565:	if cap-i > 0 {
      60ms       60ms   1566:		s.Data = arrayAt(base, i, typ.elem.Size())
         .          .   1567:	} else {
         .          .   1568:		// do not advance pointer, to avoid pointing beyond end of slice
         .          .   1569:		s.Data = base
         .          .   1570:	}
         .          .   1571:
         .          .   1572:	fl := v.flag&flagRO | flagIndir | flag(Slice)
      10ms       10ms   1573:	return Value{typ.common(), unsafe.Pointer(&x), fl}
         .          .   1574:}
         .          .   1575:
         .          .   1576:// Slice3 is the 3-index form of the slice operation: it returns v[i:j:k].
         .          .   1577:// It panics if v's Kind is not Array or Slice, or if v is an unaddressable array,
         .          .   1578:// or if the indexes are out of bounds.
ROUTINE ======================== reflect.Value.Type in /home/isucon/.local/go/src/reflect/value.go
     190ms      190ms (flat, cum)  0.34% of Total
         .          .   1663:	v.mustBeExported()
         .          .   1664:	return v.send(x, true)
         .          .   1665:}
         .          .   1666:
         .          .   1667:// Type returns v's type.
      50ms       50ms   1668:func (v Value) Type() Type {
      20ms       20ms   1669:	f := v.flag
         .          .   1670:	if f == 0 {
         .          .   1671:		panic(&ValueError{"reflect.Value.Type", Invalid})
         .          .   1672:	}
         .          .   1673:	if f&flagMethod == 0 {
         .          .   1674:		// Easy case
     120ms      120ms   1675:		return v.typ
         .          .   1676:	}
         .          .   1677:
         .          .   1678:	// Method value.
         .          .   1679:	// v.typ describes the receiver, not the method type.
         .          .   1680:	i := int(v.flag) >> flagMethodShift
ROUTINE ======================== reflect.Value.assignTo in /home/isucon/.local/go/src/reflect/value.go
     180ms      320ms (flat, cum)  0.58% of Total
         .          .   2131:}
         .          .   2132:
         .          .   2133:// assignTo returns a value v that can be assigned directly to typ.
         .          .   2134:// It panics if v is not assignable to typ.
         .          .   2135:// For a conversion to an interface type, target is a suggested scratch space to use.
      50ms       50ms   2136:func (v Value) assignTo(context string, dst *rtype, target unsafe.Pointer) Value {
         .          .   2137:	if v.flag&flagMethod != 0 {
         .          .   2138:		v = makeMethodValue(context, v)
         .          .   2139:	}
         .          .   2140:
         .          .   2141:	switch {
      30ms      100ms   2142:	case directlyAssignable(dst, v.typ):
         .          .   2143:		// Overwrite type so that they match.
         .          .   2144:		// Same memory layout, so no harm done.
         .          .   2145:		v.typ = dst
      10ms       10ms   2146:		fl := v.flag & (flagRO | flagAddr | flagIndir)
      70ms       70ms   2147:		fl |= flag(dst.Kind())
      20ms       20ms   2148:		return Value{dst, v.ptr, fl}
         .          .   2149:
         .          .   2150:	case implements(dst, v.typ):
         .          .   2151:		if target == nil {
         .          .   2152:			target = unsafe_New(dst)
         .          .   2153:		}
         .       60ms   2154:		x := valueInterface(v, false)
         .          .   2155:		if dst.NumMethod() == 0 {
         .       10ms   2156:			*(*interface{})(target) = x
         .          .   2157:		} else {
         .          .   2158:			ifaceE2I(dst, x, target)
         .          .   2159:		}
         .          .   2160:		return Value{dst, target, flagIndir | flag(Interface)}
         .          .   2161:	}
ROUTINE ======================== reflect.Value.call in /home/isucon/.local/go/src/reflect/value.go
     120ms      850ms (flat, cum)  1.53% of Total
         .          .    318:
         .          .    319:var callGC bool // for testing; see TestCallMethodJump
         .          .    320:
         .          .    321:func (v Value) call(op string, in []Value) []Value {
         .          .    322:	// Get function pointer, type.
      10ms       10ms    323:	t := v.typ
         .          .    324:	var (
         .          .    325:		fn       unsafe.Pointer
         .          .    326:		rcvr     Value
         .          .    327:		rcvrtype *rtype
         .          .    328:	)
         .          .    329:	if v.flag&flagMethod != 0 {
         .          .    330:		rcvr = v
         .          .    331:		rcvrtype, t, fn = methodReceiver(op, v, int(v.flag)>>flagMethodShift)
         .          .    332:	} else if v.flag&flagIndir != 0 {
         .          .    333:		fn = *(*unsafe.Pointer)(v.ptr)
         .          .    334:	} else {
         .          .    335:		fn = v.ptr
         .          .    336:	}
         .          .    337:
         .          .    338:	if fn == nil {
         .          .    339:		panic("reflect.Value.Call: call of nil function")
         .          .    340:	}
         .          .    341:
         .          .    342:	isSlice := op == "CallSlice"
         .          .    343:	n := t.NumIn()
         .          .    344:	if isSlice {
         .          .    345:		if !t.IsVariadic() {
         .          .    346:			panic("reflect: CallSlice of non-variadic function")
         .          .    347:		}
         .          .    348:		if len(in) < n {
         .          .    349:			panic("reflect: CallSlice with too few input arguments")
         .          .    350:		}
         .          .    351:		if len(in) > n {
         .          .    352:			panic("reflect: CallSlice with too many input arguments")
         .          .    353:		}
         .          .    354:	} else {
      10ms       20ms    355:		if t.IsVariadic() {
         .          .    356:			n--
         .          .    357:		}
         .          .    358:		if len(in) < n {
         .          .    359:			panic("reflect: Call with too few input arguments")
         .          .    360:		}
         .       10ms    361:		if !t.IsVariadic() && len(in) > n {
         .          .    362:			panic("reflect: Call with too many input arguments")
         .          .    363:		}
         .          .    364:	}
         .          .    365:	for _, x := range in {
         .          .    366:		if x.Kind() == Invalid {
         .          .    367:			panic("reflect: " + op + " using zero Value argument")
         .          .    368:		}
         .          .    369:	}
         .          .    370:	for i := 0; i < n; i++ {
         .          .    371:		if xt, targ := in[i].Type(), t.In(i); !xt.AssignableTo(targ) {
         .          .    372:			panic("reflect: " + op + " using " + xt.String() + " as type " + targ.String())
         .          .    373:		}
         .          .    374:	}
         .          .    375:	if !isSlice && t.IsVariadic() {
         .          .    376:		// prepare slice for remaining values
         .          .    377:		m := len(in) - n
         .       60ms    378:		slice := MakeSlice(t.In(n), m, m)
      10ms       10ms    379:		elem := t.In(n).Elem()
      10ms       10ms    380:		for i := 0; i < m; i++ {
         .          .    381:			x := in[n+i]
         .       10ms    382:			if xt := x.Type(); !xt.AssignableTo(elem) {
         .          .    383:				panic("reflect: cannot use " + xt.String() + " as type " + elem.String() + " in " + op)
         .          .    384:			}
         .       70ms    385:			slice.Index(i).Set(x)
         .          .    386:		}
         .          .    387:		origIn := in
         .       70ms    388:		in = make([]Value, n+1)
      20ms       20ms    389:		copy(in[:n], origIn)
         .       20ms    390:		in[n] = slice
         .          .    391:	}
         .          .    392:
         .          .    393:	nin := len(in)
      10ms       10ms    394:	if nin != t.NumIn() {
         .          .    395:		panic("reflect.Value.Call: wrong argument count")
         .          .    396:	}
         .          .    397:	nout := t.NumOut()
         .          .    398:
         .          .    399:	// Compute frame type.
         .       30ms    400:	frametype, _, retOffset, _, framePool := funcLayout(t, rcvrtype)
         .          .    401:
         .          .    402:	// Allocate a chunk of memory for frame.
         .          .    403:	var args unsafe.Pointer
         .          .    404:	if nout == 0 {
         .          .    405:		args = framePool.Get().(unsafe.Pointer)
         .          .    406:	} else {
         .          .    407:		// Can't use pool if the function has return values.
         .          .    408:		// We will leak pointer to args in ret, so its lifetime is not scoped.
         .       60ms    409:		args = unsafe_New(frametype)
         .          .    410:	}
         .          .    411:	off := uintptr(0)
         .          .    412:
         .          .    413:	// Copy inputs into args.
         .          .    414:	if rcvrtype != nil {
         .          .    415:		storeRcvr(rcvr, args)
         .          .    416:		off = ptrSize
         .          .    417:	}
      20ms       20ms    418:	for i, v := range in {
         .          .    419:		v.mustBeExported()
         .       20ms    420:		targ := t.In(i).(*rtype)
         .          .    421:		a := uintptr(targ.align)
         .          .    422:		off = (off + a - 1) &^ (a - 1)
         .          .    423:		n := targ.size
         .          .    424:		addr := unsafe.Pointer(uintptr(args) + off)
         .       10ms    425:		v = v.assignTo("reflect.Value.Call", targ, addr)
         .          .    426:		if v.flag&flagIndir != 0 {
      20ms       20ms    427:			typedmemmove(targ, addr, v.ptr)
         .          .    428:		} else {
         .          .    429:			*(*unsafe.Pointer)(addr) = v.ptr
         .          .    430:		}
         .          .    431:		off += n
         .          .    432:	}
         .          .    433:
         .          .    434:	// Call.
         .      310ms    435:	call(frametype, fn, args, uint32(frametype.size), uint32(retOffset))
         .          .    436:
         .          .    437:	// For testing; see TestCallMethodJump.
         .          .    438:	if callGC {
         .          .    439:		runtime.GC()
         .          .    440:	}
         .          .    441:
         .          .    442:	var ret []Value
         .          .    443:	if nout == 0 {
         .          .    444:		memclr(args, frametype.size)
         .          .    445:		framePool.Put(args)
         .          .    446:	} else {
         .          .    447:		// Zero the now unused input area of args,
         .          .    448:		// because the Values returned by this function contain pointers to the args object,
         .          .    449:		// and will thus keep the args object alive indefinitely.
         .          .    450:		memclr(args, retOffset)
         .          .    451:		// Copy return values out of args.
         .       10ms    452:		ret = make([]Value, nout)
         .          .    453:		off = retOffset
         .          .    454:		for i := 0; i < nout; i++ {
         .       10ms    455:			tv := t.Out(i)
         .          .    456:			a := uintptr(tv.Align())
         .          .    457:			off = (off + a - 1) &^ (a - 1)
         .          .    458:			fl := flagIndir | flag(tv.Kind())
      10ms       30ms    459:			ret[i] = Value{tv.common(), unsafe.Pointer(uintptr(args) + off), fl}
         .       10ms    460:			off += tv.Size()
         .          .    461:		}
         .          .    462:	}
         .          .    463:
         .          .    464:	return ret
         .          .    465:}
ROUTINE ======================== reflect.ValueOf in /home/isucon/.local/go/src/reflect/value.go
     420ms      420ms (flat, cum)  0.75% of Total
         .          .   2079:	return v.Elem()
         .          .   2080:}
         .          .   2081:
         .          .   2082:// ValueOf returns a new Value initialized to the concrete value
         .          .   2083:// stored in the interface i.  ValueOf(nil) returns the zero Value.
      80ms       80ms   2084:func ValueOf(i interface{}) Value {
         .          .   2085:	if i == nil {
         .          .   2086:		return Value{}
         .          .   2087:	}
         .          .   2088:
         .          .   2089:	// TODO: Maybe allow contents of a Value to live on the stack.
         .          .   2090:	// For now we make the contents always escape to the heap.  It
         .          .   2091:	// makes life easier in a few places (see chanrecv/mapassign
         .          .   2092:	// comment below).
      20ms       20ms   2093:	escapes(i)
         .          .   2094:
     320ms      320ms   2095:	return unpackEface(i)
         .          .   2096:}
         .          .   2097:
         .          .   2098:// Zero returns a Value representing the zero value for the specified type.
         .          .   2099:// The result is different from the zero value of the Value struct,
         .          .   2100:// which represents no value at all.
ROUTINE ======================== reflect.directlyAssignable in /home/isucon/.local/go/src/reflect/type.go
     340ms      340ms (flat, cum)  0.61% of Total
         .          .   1189:// directlyAssignable reports whether a value x of type V can be directly
         .          .   1190:// assigned (using memmove) to a value of type T.
         .          .   1191:// https://golang.org/doc/go_spec.html#Assignability
         .          .   1192:// Ignoring the interface rules (implemented elsewhere)
         .          .   1193:// and the ideal constant rules (no ideal constants at run time).
      70ms       70ms   1194:func directlyAssignable(T, V *rtype) bool {
         .          .   1195:	// x's type V is identical to T?
      10ms       10ms   1196:	if T == V {
      40ms       40ms   1197:		return true
         .          .   1198:	}
         .          .   1199:
         .          .   1200:	// Otherwise at least one of T and V must be unnamed
         .          .   1201:	// and they must have the same kind.
     220ms      220ms   1202:	if T.Name() != "" && V.Name() != "" || T.Kind() != V.Kind() {
         .          .   1203:		return false
         .          .   1204:	}
         .          .   1205:
         .          .   1206:	// x's type T and V must  have identical underlying types.
         .          .   1207:	return haveIdenticalUnderlyingType(T, V)
ROUTINE ======================== reflect.flag.mustBe in /home/isucon/.local/go/src/reflect/value.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    196:// (and embedding flag in Value) means that we can write
         .          .    197:// the very clear v.mustBe(Bool) and have it compile into
         .          .    198:// v.flag.mustBe(Bool), which will only bother to copy the
         .          .    199:// single important word for the receiver.
         .          .    200:func (f flag) mustBe(expected Kind) {
      10ms       10ms    201:	if f.kind() != expected {
         .          .    202:		panic(&ValueError{methodName(), f.kind()})
         .          .    203:	}
         .          .    204:}
         .          .    205:
         .          .    206:// mustBeExported panics if f records that the value was obtained using
ROUTINE ======================== reflect.flag.mustBeAssignable in /home/isucon/.local/go/src/reflect/value.go
      90ms       90ms (flat, cum)  0.16% of Total
         .          .    215:}
         .          .    216:
         .          .    217:// mustBeAssignable panics if f records that the value is not assignable,
         .          .    218:// which is to say that either it was obtained using an unexported field
         .          .    219:// or it is not addressable.
      40ms       40ms    220:func (f flag) mustBeAssignable() {
      10ms       10ms    221:	if f == 0 {
         .          .    222:		panic(&ValueError{methodName(), Invalid})
         .          .    223:	}
         .          .    224:	// Assignable if addressable and not read-only.
      10ms       10ms    225:	if f&flagRO != 0 {
         .          .    226:		panic("reflect: " + methodName() + " using value obtained using unexported field")
         .          .    227:	}
      10ms       10ms    228:	if f&flagAddr == 0 {
         .          .    229:		panic("reflect: " + methodName() + " using unaddressable value")
         .          .    230:	}
      20ms       20ms    231:}
         .          .    232:
         .          .    233:// Addr returns a pointer value representing the address of v.
         .          .    234:// It panics if CanAddr() returns false.
         .          .    235:// Addr is typically used to obtain a pointer to a struct field
         .          .    236:// or slice element in order to call a method that requires a
ROUTINE ======================== reflect.flag.mustBeExported in /home/isucon/.local/go/src/reflect/value.go
      60ms       60ms (flat, cum)  0.11% of Total
         .          .    203:	}
         .          .    204:}
         .          .    205:
         .          .    206:// mustBeExported panics if f records that the value was obtained using
         .          .    207:// an unexported field.
      60ms       60ms    208:func (f flag) mustBeExported() {
         .          .    209:	if f == 0 {
         .          .    210:		panic(&ValueError{methodName(), 0})
         .          .    211:	}
         .          .    212:	if f&flagRO != 0 {
         .          .    213:		panic("reflect: " + methodName() + " using value obtained using unexported field")
ROUTINE ======================== reflect.funcLayout in /home/isucon/.local/go/src/reflect/type.go
      10ms       30ms (flat, cum) 0.054% of Total
         .          .   2070:	if rcvr != nil && rcvr.Kind() == Interface {
         .          .   2071:		panic("reflect: funcLayout with interface receiver " + rcvr.String())
         .          .   2072:	}
         .          .   2073:	k := layoutKey{t, rcvr}
         .          .   2074:	layoutCache.RLock()
      10ms       30ms   2075:	if x := layoutCache.m[k]; x.t != nil {
         .          .   2076:		layoutCache.RUnlock()
         .          .   2077:		return x.t, x.argSize, x.retOffset, x.stack, x.framePool
         .          .   2078:	}
         .          .   2079:	layoutCache.RUnlock()
         .          .   2080:	layoutCache.Lock()
ROUTINE ======================== reflect.grow in /home/isucon/.local/go/src/reflect/value.go
     100ms      6.14s (flat, cum) 11.03% of Total
         .          .   1780:	return unsafe.Pointer(uintptr(p) + uintptr(i)*eltSize)
         .          .   1781:}
         .          .   1782:
         .          .   1783:// grow grows the slice s so that it can hold extra more values, allocating
         .          .   1784:// more capacity if needed. It also returns the old and new slice lengths.
      50ms       50ms   1785:func grow(s Value, extra int) (Value, int, int) {
         .       50ms   1786:	i0 := s.Len()
      20ms       20ms   1787:	i1 := i0 + extra
         .          .   1788:	if i1 < i0 {
         .          .   1789:		panic("reflect.Append: slice overflow")
         .          .   1790:	}
         .       20ms   1791:	m := s.Cap()
         .          .   1792:	if i1 <= m {
      30ms      880ms   1793:		return s.Slice(0, i1), i0, i1
         .          .   1794:	}
         .          .   1795:	if m == 0 {
         .          .   1796:		m = extra
         .          .   1797:	} else {
         .          .   1798:		for m < i1 {
         .          .   1799:			if i0 < 1024 {
         .          .   1800:				m += m
         .          .   1801:			} else {
         .          .   1802:				m += m / 4
         .          .   1803:			}
         .          .   1804:		}
         .          .   1805:	}
         .      3.52s   1806:	t := MakeSlice(s.Type(), i1, m)
         .      1.60s   1807:	Copy(t, s)
         .          .   1808:	return t, i0, i1
         .          .   1809:}
         .          .   1810:
         .          .   1811:// Append appends the values x to a slice s and returns the resulting slice.
         .          .   1812:// As in Go, each x's value must be assignable to the slice's element type.
ROUTINE ======================== reflect.implements in /home/isucon/.local/go/src/reflect/type.go
      60ms       60ms (flat, cum)  0.11% of Total
         .          .   1131:func (t *rtype) Comparable() bool {
         .          .   1132:	return t.alg != nil && t.alg.equal != nil
         .          .   1133:}
         .          .   1134:
         .          .   1135:// implements reports whether the type V implements the interface type T.
      40ms       40ms   1136:func implements(T, V *rtype) bool {
      20ms       20ms   1137:	if T.Kind() != Interface {
         .          .   1138:		return false
         .          .   1139:	}
         .          .   1140:	t := (*interfaceType)(unsafe.Pointer(T))
         .          .   1141:	if len(t.methods) == 0 {
         .          .   1142:		return true
ROUTINE ======================== reflect.mapiterinit in /home/isucon/.local/go/src/runtime/hashmap.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   1008:	mapdelete(t, h, key)
         .          .   1009:}
         .          .   1010:
         .          .   1011://go:linkname reflect_mapiterinit reflect.mapiterinit
         .          .   1012:func reflect_mapiterinit(t *maptype, h *hmap) *hiter {
         .       10ms   1013:	it := new(hiter)
         .          .   1014:	mapiterinit(t, h, it)
         .          .   1015:	return it
         .          .   1016:}
         .          .   1017:
         .          .   1018://go:linkname reflect_mapiternext reflect.mapiternext
ROUTINE ======================== reflect.packEface in /home/isucon/.local/go/src/reflect/value.go
     420ms      510ms (flat, cum)  0.92% of Total
         .          .     92:	}
         .          .     93:	return v.ptr
         .          .     94:}
         .          .     95:
         .          .     96:// packEface converts v to the empty interface.
     110ms      110ms     97:func packEface(v Value) interface{} {
      50ms       50ms     98:	t := v.typ
      10ms       10ms     99:	var i interface{}
         .          .    100:	e := (*emptyInterface)(unsafe.Pointer(&i))
         .          .    101:	// First, fill in the data portion of the interface.
         .          .    102:	switch {
     130ms      130ms    103:	case ifaceIndir(t):
         .          .    104:		if v.flag&flagIndir == 0 {
         .          .    105:			panic("bad indir")
         .          .    106:		}
         .          .    107:		// Value is indirect, and so is the interface we're making.
         .          .    108:		ptr := v.ptr
         .          .    109:		if v.flag&flagAddr != 0 {
         .          .    110:			// TODO: pass safe boolean from valueInterface so
         .          .    111:			// we don't need to copy if safe==true?
         .       20ms    112:			c := unsafe_New(t)
         .       20ms    113:			typedmemmove(t, c, ptr)
         .          .    114:			ptr = c
         .          .    115:		}
         .       10ms    116:		e.word = ptr
      10ms       10ms    117:	case v.flag&flagIndir != 0:
         .          .    118:		// Value is indirect, but interface is direct.  We need
         .          .    119:		// to load the data at v.ptr into the interface data word.
         .          .    120:		e.word = *(*unsafe.Pointer)(v.ptr)
         .          .    121:	default:
         .          .    122:		// Value is direct, and so is the interface.
      40ms       70ms    123:		e.word = v.ptr
         .          .    124:	}
         .          .    125:	// Now, fill in the type portion.  We're very careful here not
         .          .    126:	// to have any operation between the e.word and e.typ assignments
         .          .    127:	// that would let the garbage collector observe the partially-built
         .          .    128:	// interface value.
      30ms       40ms    129:	e.typ = t
      40ms       40ms    130:	return i
         .          .    131:}
         .          .    132:
         .          .    133:// unpackEface converts the empty interface i to a Value.
         .          .    134:func unpackEface(i interface{}) Value {
         .          .    135:	e := (*emptyInterface)(unsafe.Pointer(&i))
ROUTINE ======================== reflect.typedmemmove in /home/isucon/.local/go/src/runtime/mbarrier.go
     110ms      630ms (flat, cum)  1.13% of Total
         .          .    196:	}
         .          .    197:	heapBitsBulkBarrier(uintptr(dst), typ.size)
         .          .    198:}
         .          .    199:
         .          .    200://go:linkname reflect_typedmemmove reflect.typedmemmove
      40ms       40ms    201:func reflect_typedmemmove(typ *_type, dst, src unsafe.Pointer) {
      60ms      580ms    202:	typedmemmove(typ, dst, src)
      10ms       10ms    203:}
         .          .    204:
         .          .    205:// typedmemmovepartial is like typedmemmove but assumes that
         .          .    206:// dst and src point off bytes into the value and only copies size bytes.
         .          .    207://go:linkname reflect_typedmemmovepartial reflect.typedmemmovepartial
         .          .    208:func reflect_typedmemmovepartial(typ *_type, dst, src unsafe.Pointer, off, size uintptr) {
ROUTINE ======================== reflect.typedslicecopy in /home/isucon/.local/go/src/runtime/mbarrier.go
         0      1.59s (flat, cum)  2.86% of Total
         .          .    315:			n = src.len
         .          .    316:		}
         .          .    317:		memmove(dst.array, src.array, uintptr(n)*elemType.size)
         .          .    318:		return n
         .          .    319:	}
         .      1.59s    320:	return typedslicecopy(elemType, dst, src)
         .          .    321:}
ROUTINE ======================== reflect.unsafe_New in /home/isucon/.local/go/src/runtime/malloc.go
         0      1.58s (flat, cum)  2.84% of Total
         .          .    781:	return mallocgc(uintptr(typ.size), typ, flags)
         .          .    782:}
         .          .    783:
         .          .    784://go:linkname reflect_unsafe_New reflect.unsafe_New
         .          .    785:func reflect_unsafe_New(typ *_type) unsafe.Pointer {
         .      1.58s    786:	return newobject(typ)
         .          .    787:}
         .          .    788:
         .          .    789:// implementation of make builtin for slices
         .          .    790:func newarray(typ *_type, n uintptr) unsafe.Pointer {
         .          .    791:	flags := uint32(0)
ROUTINE ======================== reflect.unsafe_NewArray in /home/isucon/.local/go/src/runtime/malloc.go
         0      3.51s (flat, cum)  6.31% of Total
         .          .    798:	return mallocgc(uintptr(typ.size)*n, typ, flags)
         .          .    799:}
         .          .    800:
         .          .    801://go:linkname reflect_unsafe_NewArray reflect.unsafe_NewArray
         .          .    802:func reflect_unsafe_NewArray(typ *_type, n uintptr) unsafe.Pointer {
         .      3.51s    803:	return newarray(typ, n)
         .          .    804:}
         .          .    805:
         .          .    806:// rawmem returns a chunk of pointerless memory.  It is
         .          .    807:// not zeroed.
         .          .    808:func rawmem(size uintptr) unsafe.Pointer {
ROUTINE ======================== reflect.valueInterface in /home/isucon/.local/go/src/reflect/value.go
     250ms      760ms (flat, cum)  1.37% of Total
         .          .    906:// unexported struct fields.
         .          .    907:func (v Value) Interface() (i interface{}) {
         .          .    908:	return valueInterface(v, true)
         .          .    909:}
         .          .    910:
      70ms       70ms    911:func valueInterface(v Value, safe bool) interface{} {
      10ms       10ms    912:	if v.flag == 0 {
         .          .    913:		panic(&ValueError{"reflect.Value.Interface", 0})
         .          .    914:	}
      20ms       20ms    915:	if safe && v.flag&flagRO != 0 {
         .          .    916:		// Do not allow access to unexported values via Interface,
         .          .    917:		// because they might be pointers that should not be
         .          .    918:		// writable or methods or function that should not be callable.
         .          .    919:		panic("reflect.Value.Interface: cannot return value obtained from unexported field or method")
         .          .    920:	}
      10ms       10ms    921:	if v.flag&flagMethod != 0 {
         .          .    922:		v = makeMethodValue("Interface", v)
         .          .    923:	}
         .          .    924:
         .          .    925:	if v.kind() == Interface {
         .          .    926:		// Special case: return the element inside the interface.
         .          .    927:		// Empty interface has one layout, all interfaces with
         .          .    928:		// methods have a second layout.
         .          .    929:		if v.NumMethod() == 0 {
         .          .    930:			return *(*interface{})(v.ptr)
         .          .    931:		}
         .          .    932:		return *(*interface {
         .          .    933:			M()
         .          .    934:		})(v.ptr)
         .          .    935:	}
         .          .    936:
         .          .    937:	// TODO: pass safe to packEface so we don't need to copy if safe==true?
     140ms      650ms    938:	return packEface(v)
         .          .    939:}
         .          .    940:
         .          .    941:// InterfaceData returns the interface v's value as a uintptr pair.
         .          .    942:// It panics if v's Kind is not Interface.
         .          .    943:func (v Value) InterfaceData() [2]uintptr {
ROUTINE ======================== runtime.(*fixalloc).alloc in /home/isucon/.local/go/src/runtime/mfixalloc.go
      30ms       30ms (flat, cum) 0.054% of Total
         .          .     49:	f.nchunk = 0
         .          .     50:	f.inuse = 0
         .          .     51:	f.stat = stat
         .          .     52:}
         .          .     53:
      10ms       10ms     54:func (f *fixalloc) alloc() unsafe.Pointer {
         .          .     55:	if f.size == 0 {
         .          .     56:		print("runtime: use of FixAlloc_Alloc before FixAlloc_Init\n")
         .          .     57:		throw("runtime: internal error")
         .          .     58:	}
         .          .     59:
         .          .     60:	if f.list != nil {
         .          .     61:		v := unsafe.Pointer(f.list)
      20ms       20ms     62:		f.list = f.list.next
         .          .     63:		f.inuse += f.size
         .          .     64:		return v
         .          .     65:	}
         .          .     66:	if uintptr(f.nchunk) < f.size {
         .          .     67:		f.chunk = persistentalloc(_FixAllocChunk, 0, f.stat)
ROUTINE ======================== runtime.(*gcControllerState).findRunnableGCWorker in /home/isucon/.local/go/src/runtime/mgc.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    634:		// performing a mark transition. We can't run it
         .          .    635:		// because it may be on some other run or wait queue.
         .          .    636:		return nil
         .          .    637:	}
         .          .    638:
      10ms       10ms    639:	if !gcMarkWorkAvailable(_p_) {
         .          .    640:		// No work to be done right now. This can happen at
         .          .    641:		// the end of the mark phase when there are still
         .          .    642:		// assists tapering off. Don't bother running a worker
         .          .    643:		// now because it'll just return immediately.
         .          .    644:		return nil
ROUTINE ======================== runtime.(*gcWork).dispose in /home/isucon/.local/go/src/runtime/mgcwork.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    199:// GC can inspect them. This helps reduce the mutator's
         .          .    200:// ability to hide pointers during the concurrent mark phase.
         .          .    201://
         .          .    202://go:nowritebarrier
         .          .    203:func (w *gcWork) dispose() {
      10ms       10ms    204:	if wbuf := w.wbuf1.ptr(); wbuf != nil {
         .          .    205:		if wbuf.nobj == 0 {
         .          .    206:			putempty(wbuf, 212)
         .          .    207:		} else {
         .          .    208:			putfull(wbuf, 214)
         .          .    209:		}
ROUTINE ======================== runtime.(*gcWork).put in /home/isucon/.local/go/src/runtime/mgcwork.go
      60ms       60ms (flat, cum)  0.11% of Total
         .          .    103:}
         .          .    104:
         .          .    105:// put enqueues a pointer for the garbage collector to trace.
         .          .    106:// obj must point to the beginning of a heap object.
         .          .    107://go:nowritebarrier
      20ms       20ms    108:func (ww *gcWork) put(obj uintptr) {
      10ms       10ms    109:	w := (*gcWork)(noescape(unsafe.Pointer(ww))) // TODO: remove when escape analysis is fixed
         .          .    110:
         .          .    111:	wbuf := w.wbuf1.ptr()
         .          .    112:	if wbuf == nil {
         .          .    113:		w.init()
         .          .    114:		wbuf = w.wbuf1.ptr()
         .          .    115:		// wbuf is empty at this point.
      10ms       10ms    116:	} else if wbuf.nobj == len(wbuf.obj) {
         .          .    117:		w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1
         .          .    118:		wbuf = w.wbuf1.ptr()
         .          .    119:		if wbuf.nobj == len(wbuf.obj) {
         .          .    120:			putfull(wbuf, 132)
         .          .    121:			wbuf = getempty(133)
         .          .    122:			w.wbuf1 = wbufptrOf(wbuf)
         .          .    123:		}
         .          .    124:	}
         .          .    125:
         .          .    126:	wbuf.obj[wbuf.nobj] = obj
      10ms       10ms    127:	wbuf.nobj++
      10ms       10ms    128:}
         .          .    129:
         .          .    130:// tryGet dequeues a pointer for the garbage collector to trace.
         .          .    131://
         .          .    132:// If there are no pointers remaining in this gcWork or in the global
         .          .    133:// queue, tryGet returns 0.  Note that there may still be pointers in
ROUTINE ======================== runtime.(*gcWork).tryGet in /home/isucon/.local/go/src/runtime/mgcwork.go
      70ms       70ms (flat, cum)  0.13% of Total
         .          .    131://
         .          .    132:// If there are no pointers remaining in this gcWork or in the global
         .          .    133:// queue, tryGet returns 0.  Note that there may still be pointers in
         .          .    134:// other gcWork instances or other caches.
         .          .    135://go:nowritebarrier
      10ms       10ms    136:func (ww *gcWork) tryGet() uintptr {
         .          .    137:	w := (*gcWork)(noescape(unsafe.Pointer(ww))) // TODO: remove when escape analysis is fixed
         .          .    138:
         .          .    139:	wbuf := w.wbuf1.ptr()
         .          .    140:	if wbuf == nil {
         .          .    141:		w.init()
         .          .    142:		wbuf = w.wbuf1.ptr()
         .          .    143:		// wbuf is empty at this point.
         .          .    144:	}
      30ms       30ms    145:	if wbuf.nobj == 0 {
         .          .    146:		w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1
         .          .    147:		wbuf = w.wbuf1.ptr()
      10ms       10ms    148:		if wbuf.nobj == 0 {
         .          .    149:			owbuf := wbuf
         .          .    150:			wbuf = trygetfull(167)
         .          .    151:			if wbuf == nil {
         .          .    152:				return 0
         .          .    153:			}
         .          .    154:			putempty(owbuf, 166)
         .          .    155:			w.wbuf1 = wbufptrOf(wbuf)
         .          .    156:		}
         .          .    157:	}
         .          .    158:
      10ms       10ms    159:	wbuf.nobj--
      10ms       10ms    160:	return wbuf.obj[wbuf.nobj]
         .          .    161:}
         .          .    162:
         .          .    163:// get dequeues a pointer for the garbage collector to trace, blocking
         .          .    164:// if necessary to ensure all pointers from all queues and caches have
         .          .    165:// been retrieved.  get returns 0 if there are no pointers remaining.
ROUTINE ======================== runtime.(*guintptr).cas in /home/isucon/.local/go/src/runtime/runtime2.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .    128://go:nosplit
         .          .    129:func (gp *guintptr) set(g *g) { *gp = guintptr(unsafe.Pointer(g)) }
         .          .    130:
         .          .    131://go:nosplit
         .          .    132:func (gp *guintptr) cas(old, new guintptr) bool {
      10ms       20ms    133:	return atomic.Casuintptr((*uintptr)(unsafe.Pointer(gp)), uintptr(old), uintptr(new))
         .          .    134:}
         .          .    135:
         .          .    136:type puintptr uintptr
         .          .    137:
         .          .    138://go:nosplit
ROUTINE ======================== runtime.(*mSpanList).insert in /home/isucon/.local/go/src/runtime/mheap.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    936:	if list.first != nil {
         .          .    937:		list.first.prev = &span.next
         .          .    938:	} else {
         .          .    939:		list.last = &span.next
         .          .    940:	}
      10ms       10ms    941:	list.first = span
         .          .    942:	span.prev = &list.first
         .          .    943:	span.list = list
         .          .    944:}
         .          .    945:
         .          .    946:func (list *mSpanList) insertBack(span *mspan) {
ROUTINE ======================== runtime.(*mSpanList).insertBack in /home/isucon/.local/go/src/runtime/mheap.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    947:	if span.next != nil || span.prev != nil || span.list != nil {
         .          .    948:		println("failed MSpanList_InsertBack", span, span.next, span.prev, span.list)
         .          .    949:		throw("MSpanList_InsertBack")
         .          .    950:	}
         .          .    951:	span.next = nil
      10ms       10ms    952:	span.prev = list.last
         .          .    953:	*list.last = span
         .          .    954:	list.last = &span.next
         .          .    955:	span.list = list
         .          .    956:}
         .          .    957:
ROUTINE ======================== runtime.(*mSpanList).remove in /home/isucon/.local/go/src/runtime/mheap.go
      80ms       80ms (flat, cum)  0.14% of Total
         .          .    904:	list.first = nil
         .          .    905:	list.last = &list.first
         .          .    906:}
         .          .    907:
         .          .    908:func (list *mSpanList) remove(span *mspan) {
      20ms       20ms    909:	if span.prev == nil || span.list != list {
         .          .    910:		println("failed MSpanList_Remove", span, span.prev, span.list, list)
         .          .    911:		throw("MSpanList_Remove")
         .          .    912:	}
      10ms       10ms    913:	if span.next != nil {
      10ms       10ms    914:		span.next.prev = span.prev
         .          .    915:	} else {
         .          .    916:		// TODO: After we remove the span.list != list check above,
         .          .    917:		// we could at least still check list.last == &span.next here.
         .          .    918:		list.last = span.prev
         .          .    919:	}
      30ms       30ms    920:	*span.prev = span.next
      10ms       10ms    921:	span.next = nil
         .          .    922:	span.prev = nil
         .          .    923:	span.list = nil
         .          .    924:}
         .          .    925:
         .          .    926:func (list *mSpanList) isEmpty() bool {
ROUTINE ======================== runtime.(*mcache).refill in /home/isucon/.local/go/src/runtime/mcache.go
         0      820ms (flat, cum)  1.47% of Total
         .          .    114:	if s != &emptymspan {
         .          .    115:		s.incache = false
         .          .    116:	}
         .          .    117:
         .          .    118:	// Get a new cached span from the central lists.
         .      820ms    119:	s = mheap_.central[sizeclass].mcentral.cacheSpan()
         .          .    120:	if s == nil {
         .          .    121:		throw("out of memory")
         .          .    122:	}
         .          .    123:	if s.freelist.ptr() == nil {
         .          .    124:		println(s.ref, (s.npages<<_PageShift)/s.elemsize)
ROUTINE ======================== runtime.(*mcentral).cacheSpan in /home/isucon/.local/go/src/runtime/mcentral.go
      60ms      820ms (flat, cum)  1.47% of Total
         .          .     30:}
         .          .     31:
         .          .     32:// Allocate a span to use in an MCache.
         .          .     33:func (c *mcentral) cacheSpan() *mspan {
         .          .     34:	// Deduct credit for this span allocation and sweep if necessary.
      10ms       10ms     35:	spanBytes := uintptr(class_to_allocnpages[c.sizeclass]) * _PageSize
      10ms       30ms     36:	deductSweepCredit(spanBytes, 0)
         .          .     37:
         .       10ms     38:	lock(&c.lock)
         .          .     39:	sg := mheap_.sweepgen
         .          .     40:retry:
         .          .     41:	var s *mspan
         .          .     42:	for s = c.nonempty.first; s != nil; s = s.next {
      20ms       20ms     43:		if s.sweepgen == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
         .          .     44:			c.nonempty.remove(s)
         .          .     45:			c.empty.insertBack(s)
         .          .     46:			unlock(&c.lock)
         .       90ms     47:			s.sweep(true)
         .          .     48:			goto havespan
         .          .     49:		}
         .          .     50:		if s.sweepgen == sg-1 {
         .          .     51:			// the span is being swept by background sweeper, skip
         .          .     52:			continue
         .          .     53:		}
         .          .     54:		// we have a nonempty span that does not require sweeping, allocate from it
         .       20ms     55:		c.nonempty.remove(s)
      10ms       10ms     56:		c.empty.insertBack(s)
         .       10ms     57:		unlock(&c.lock)
         .          .     58:		goto havespan
         .          .     59:	}
         .          .     60:
         .          .     61:	for s = c.empty.first; s != nil; s = s.next {
         .          .     62:		if s.sweepgen == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {
         .          .     63:			// we have an empty span that requires sweeping,
         .          .     64:			// sweep it and see if we can free some space in it
         .          .     65:			c.empty.remove(s)
         .          .     66:			// swept spans are at the end of the list
         .          .     67:			c.empty.insertBack(s)
         .          .     68:			unlock(&c.lock)
         .      250ms     69:			s.sweep(true)
         .          .     70:			if s.freelist.ptr() != nil {
         .          .     71:				goto havespan
         .          .     72:			}
         .          .     73:			lock(&c.lock)
         .          .     74:			// the span is still empty after sweep
         .          .     75:			// it is already in the empty list, so just retry
         .          .     76:			goto retry
         .          .     77:		}
         .          .     78:		if s.sweepgen == sg-1 {
         .          .     79:			// the span is being swept by background sweeper, skip
         .          .     80:			continue
         .          .     81:		}
         .          .     82:		// already swept empty span,
         .          .     83:		// all subsequent ones must also be either swept or in process of sweeping
         .          .     84:		break
         .          .     85:	}
         .          .     86:	unlock(&c.lock)
         .          .     87:
         .          .     88:	// Replenish central list if empty.
         .      270ms     89:	s = c.grow()
         .          .     90:	if s == nil {
         .          .     91:		return nil
         .          .     92:	}
         .          .     93:	lock(&c.lock)
         .       10ms     94:	c.empty.insertBack(s)
         .          .     95:	unlock(&c.lock)
         .          .     96:
         .          .     97:	// At this point s is a non-empty span, queued at the end of the empty list,
         .          .     98:	// c is unlocked.
         .          .     99:havespan:
         .          .    100:	cap := int32((s.npages << _PageShift) / s.elemsize)
         .          .    101:	n := cap - int32(s.ref)
         .          .    102:	if n == 0 {
         .          .    103:		throw("empty span")
         .          .    104:	}
         .          .    105:	usedBytes := uintptr(s.ref) * s.elemsize
         .          .    106:	if usedBytes > 0 {
         .       30ms    107:		reimburseSweepCredit(usedBytes)
         .          .    108:	}
      10ms       60ms    109:	atomic.Xadd64(&memstats.heap_live, int64(spanBytes)-int64(usedBytes))
         .          .    110:	if trace.enabled {
         .          .    111:		// heap_live changed.
         .          .    112:		traceHeapAlloc()
         .          .    113:	}
         .          .    114:	if gcBlackenEnabled != 0 {
ROUTINE ======================== runtime.(*mcentral).freeSpan in /home/isucon/.local/go/src/runtime/mcentral.go
         0      100ms (flat, cum)  0.18% of Total
         .          .    169:		}
         .          .    170:		atomic.Store(&s.sweepgen, mheap_.sweepgen)
         .          .    171:		return false
         .          .    172:	}
         .          .    173:
         .       30ms    174:	lock(&c.lock)
         .          .    175:
         .          .    176:	// Move to nonempty if necessary.
         .          .    177:	if wasempty {
         .       20ms    178:		c.empty.remove(s)
         .       10ms    179:		c.nonempty.insert(s)
         .          .    180:	}
         .          .    181:
         .          .    182:	// delay updating sweepgen until here.  This is the signal that
         .          .    183:	// the span may be used in an MCache, so it must come after the
         .          .    184:	// linked list operations above (actually, just after the
         .          .    185:	// lock of c above.)
         .       20ms    186:	atomic.Store(&s.sweepgen, mheap_.sweepgen)
         .          .    187:
         .          .    188:	if s.ref != 0 {
         .          .    189:		unlock(&c.lock)
         .          .    190:		return false
         .          .    191:	}
         .          .    192:
         .          .    193:	// s is completely freed, return it to the heap.
         .          .    194:	c.nonempty.remove(s)
         .          .    195:	s.needzero = 1
         .          .    196:	s.freelist = 0
         .       10ms    197:	unlock(&c.lock)
         .       10ms    198:	heapBitsForSpan(s.base()).initSpan(s.layout())
         .          .    199:	mheap_.freeSpan(s, 0)
         .          .    200:	return true
         .          .    201:}
         .          .    202:
         .          .    203:// Fetch a new span from the heap and carve into objects for the free list.
ROUTINE ======================== runtime.(*mcentral).grow in /home/isucon/.local/go/src/runtime/mcentral.go
      20ms      270ms (flat, cum)  0.49% of Total
         .          .    204:func (c *mcentral) grow() *mspan {
         .          .    205:	npages := uintptr(class_to_allocnpages[c.sizeclass])
         .          .    206:	size := uintptr(class_to_size[c.sizeclass])
         .          .    207:	n := (npages << _PageShift) / size
         .          .    208:
         .      240ms    209:	s := mheap_.alloc(npages, c.sizeclass, false, true)
         .          .    210:	if s == nil {
         .          .    211:		return nil
         .          .    212:	}
         .          .    213:
         .          .    214:	p := uintptr(s.start << _PageShift)
         .          .    215:	s.limit = p + size*n
         .          .    216:	head := gclinkptr(p)
         .          .    217:	tail := gclinkptr(p)
         .          .    218:	// i==0 iteration already done
         .          .    219:	for i := uintptr(1); i < n; i++ {
         .          .    220:		p += size
      10ms       10ms    221:		tail.ptr().next = gclinkptr(p)
         .          .    222:		tail = gclinkptr(p)
         .          .    223:	}
         .          .    224:	if s.freelist.ptr() != nil {
         .          .    225:		throw("freelist not empty")
         .          .    226:	}
      10ms       10ms    227:	tail.ptr().next = 0
         .          .    228:	s.freelist = head
         .       10ms    229:	heapBitsForSpan(s.base()).initSpan(s.layout())
         .          .    230:	return s
         .          .    231:}
ROUTINE ======================== runtime.(*mheap).alloc in /home/isucon/.local/go/src/runtime/mheap.go
      10ms      2.92s (flat, cum)  5.25% of Total
         .          .    502:		s = h.alloc_m(npage, sizeclass, large)
         .          .    503:	})
         .          .    504:
         .          .    505:	if s != nil {
         .          .    506:		if needzero && s.needzero != 0 {
         .      2.91s    507:			memclr(unsafe.Pointer(s.start<<_PageShift), s.npages<<_PageShift)
         .          .    508:		}
         .          .    509:		s.needzero = 0
         .          .    510:	}
      10ms       10ms    511:	return s
         .          .    512:}
         .          .    513:
         .          .    514:func (h *mheap) allocStack(npage uintptr) *mspan {
         .          .    515:	_g_ := getg()
         .          .    516:	if _g_ != _g_.m.g0 {
ROUTINE ======================== runtime.(*mheap).alloc.func1 in /home/isucon/.local/go/src/runtime/mheap.go
         0      1.26s (flat, cum)  2.26% of Total
         .          .    497:	// Don't do any operations that lock the heap on the G stack.
         .          .    498:	// It might trigger stack growth, and the stack growth code needs
         .          .    499:	// to be able to allocate heap.
         .          .    500:	var s *mspan
         .          .    501:	systemstack(func() {
         .      1.26s    502:		s = h.alloc_m(npage, sizeclass, large)
         .          .    503:	})
         .          .    504:
         .          .    505:	if s != nil {
         .          .    506:		if needzero && s.needzero != 0 {
         .          .    507:			memclr(unsafe.Pointer(s.start<<_PageShift), s.npages<<_PageShift)
ROUTINE ======================== runtime.(*mheap).allocSpanLocked in /home/isucon/.local/go/src/runtime/mheap.go
      90ms      160ms (flat, cum)  0.29% of Total
         .          .    559:		}
         .          .    560:	}
         .          .    561:
         .          .    562:HaveSpan:
         .          .    563:	// Mark span in use.
      10ms       10ms    564:	if s.state != _MSpanFree {
         .          .    565:		throw("MHeap_AllocLocked - MSpan not free")
         .          .    566:	}
      10ms       10ms    567:	if s.npages < npage {
         .          .    568:		throw("MHeap_AllocLocked - bad npages")
         .          .    569:	}
         .       40ms    570:	list.remove(s)
         .          .    571:	if s.inList() {
         .          .    572:		throw("still in list")
         .          .    573:	}
         .          .    574:	if s.npreleased > 0 {
         .          .    575:		sysUsed(unsafe.Pointer(s.start<<_PageShift), s.npages<<_PageShift)
         .          .    576:		memstats.heap_released -= uint64(s.npreleased << _PageShift)
         .          .    577:		s.npreleased = 0
         .          .    578:	}
         .          .    579:
         .          .    580:	if s.npages > npage {
         .          .    581:		// Trim extra and put it back in the heap.
         .       20ms    582:		t := (*mspan)(h.spanalloc.alloc())
         .          .    583:		t.init(s.start+pageID(npage), s.npages-npage)
         .          .    584:		s.npages = npage
         .          .    585:		p := uintptr(t.start)
         .          .    586:		p -= (h.arena_start >> _PageShift)
         .          .    587:		if p > 0 {
         .          .    588:			h_spans[p-1] = s
         .          .    589:		}
         .          .    590:		h_spans[p] = t
         .          .    591:		h_spans[p+t.npages-1] = t
         .          .    592:		t.needzero = s.needzero
         .          .    593:		s.state = _MSpanStack // prevent coalescing with s
         .          .    594:		t.state = _MSpanStack
         .       10ms    595:		h.freeSpanLocked(t, false, false, s.unusedsince)
         .          .    596:		s.state = _MSpanFree
         .          .    597:	}
         .          .    598:	s.unusedsince = 0
         .          .    599:
         .          .    600:	p := uintptr(s.start)
         .          .    601:	p -= (h.arena_start >> _PageShift)
      20ms       20ms    602:	for n := uintptr(0); n < npage; n++ {
      50ms       50ms    603:		h_spans[p+n] = s
         .          .    604:	}
         .          .    605:
         .          .    606:	memstats.heap_inuse += uint64(npage << _PageShift)
         .          .    607:	memstats.heap_idle -= uint64(npage << _PageShift)
         .          .    608:
ROUTINE ======================== runtime.(*mheap).alloc_m in /home/isucon/.local/go/src/runtime/mheap.go
         0      1.26s (flat, cum)  2.26% of Total
         .          .    411:func (h *mheap) alloc_m(npage uintptr, sizeclass int32, large bool) *mspan {
         .          .    412:	_g_ := getg()
         .          .    413:	if _g_ != _g_.m.g0 {
         .          .    414:		throw("_mheap_alloc not on g0 stack")
         .          .    415:	}
         .       10ms    416:	lock(&h.lock)
         .          .    417:
         .          .    418:	// To prevent excessive heap growth, before allocating n pages
         .          .    419:	// we need to sweep and reclaim at least n pages.
         .          .    420:	if h.sweepdone == 0 {
         .          .    421:		// TODO(austin): This tends to sweep a large number of
         .          .    422:		// spans in order to find a few completely free spans
         .          .    423:		// (for example, in the garbage benchmark, this sweeps
         .          .    424:		// ~30x the number of pages its trying to allocate).
         .          .    425:		// If GC kept a bit for whether there were any marks
         .          .    426:		// in a span, we could release these free spans
         .          .    427:		// at the end of GC and eliminate this entirely.
         .      1.06s    428:		h.reclaim(npage)
         .          .    429:	}
         .          .    430:
         .          .    431:	// transfer stats from cache to global
         .          .    432:	memstats.heap_scan += uint64(_g_.m.mcache.local_scan)
         .          .    433:	_g_.m.mcache.local_scan = 0
         .          .    434:	memstats.tinyallocs += uint64(_g_.m.mcache.local_tinyallocs)
         .          .    435:	_g_.m.mcache.local_tinyallocs = 0
         .          .    436:
         .      160ms    437:	s := h.allocSpanLocked(npage)
         .          .    438:	if s != nil {
         .          .    439:		// Record span info, because gc needs to be
         .          .    440:		// able to map interior pointer to containing span.
         .       30ms    441:		atomic.Store(&s.sweepgen, h.sweepgen)
         .          .    442:		s.state = _MSpanInUse
         .          .    443:		s.freelist = 0
         .          .    444:		s.ref = 0
         .          .    445:		s.sizeclass = uint8(sizeclass)
         .          .    446:		if sizeclass == 0 {
ROUTINE ======================== runtime.(*mheap).freeSpan.func1 in /home/isucon/.local/go/src/runtime/mheap.go
         0       50ms (flat, cum)  0.09% of Total
         .          .    720:		}
         .          .    721:		if gcBlackenEnabled != 0 {
         .          .    722:			// heap_scan changed.
         .          .    723:			gcController.revise()
         .          .    724:		}
         .       50ms    725:		h.freeSpanLocked(s, true, true, 0)
         .          .    726:		unlock(&h.lock)
         .          .    727:	})
         .          .    728:}
         .          .    729:
         .          .    730:func (h *mheap) freeStack(s *mspan) {
ROUTINE ======================== runtime.(*mheap).freeSpanLocked in /home/isucon/.local/go/src/runtime/mheap.go
      60ms       60ms (flat, cum)  0.11% of Total
         .          .    778:	// Coalesce with earlier, later spans.
         .          .    779:	p := uintptr(s.start)
         .          .    780:	p -= h.arena_start >> _PageShift
         .          .    781:	if p > 0 {
         .          .    782:		t := h_spans[p-1]
      30ms       30ms    783:		if t != nil && t.state == _MSpanFree {
         .          .    784:			s.start = t.start
         .          .    785:			s.npages += t.npages
         .          .    786:			s.npreleased = t.npreleased // absorb released pages
         .          .    787:			s.needzero |= t.needzero
         .          .    788:			p -= t.npages
         .          .    789:			h_spans[p] = s
         .          .    790:			h.freeList(t.npages).remove(t)
         .          .    791:			t.state = _MSpanDead
         .          .    792:			h.spanalloc.free(unsafe.Pointer(t))
         .          .    793:		}
         .          .    794:	}
      10ms       10ms    795:	if (p+s.npages)*sys.PtrSize < h.spans_mapped {
         .          .    796:		t := h_spans[p+s.npages]
      20ms       20ms    797:		if t != nil && t.state == _MSpanFree {
         .          .    798:			s.npages += t.npages
         .          .    799:			s.npreleased += t.npreleased
         .          .    800:			s.needzero |= t.needzero
         .          .    801:			h_spans[p+s.npages-1] = s
         .          .    802:			h.freeList(t.npages).remove(t)
ROUTINE ======================== runtime.(*mheap).reclaim in /home/isucon/.local/go/src/runtime/mheap.go
         0      1.06s (flat, cum)  1.90% of Total
         .          .    369:// Called before allocating npage pages.
         .          .    370:func (h *mheap) reclaim(npage uintptr) {
         .          .    371:	// First try to sweep busy spans with large objects of size >= npage,
         .          .    372:	// this has good chances of reclaiming the necessary space.
         .          .    373:	for i := int(npage); i < len(h.busy); i++ {
         .       50ms    374:		if h.reclaimList(&h.busy[i], npage) != 0 {
         .          .    375:			return // Bingo!
         .          .    376:		}
         .          .    377:	}
         .          .    378:
         .          .    379:	// Then -- even larger objects.
         .       40ms    380:	if h.reclaimList(&h.busylarge, npage) != 0 {
         .          .    381:		return // Bingo!
         .          .    382:	}
         .          .    383:
         .          .    384:	// Now try smaller objects.
         .          .    385:	// One such object is not enough, so we need to reclaim several of them.
         .          .    386:	reclaimed := uintptr(0)
         .          .    387:	for i := 0; i < int(npage) && i < len(h.busy); i++ {
         .          .    388:		reclaimed += h.reclaimList(&h.busy[i], npage-reclaimed)
         .          .    389:		if reclaimed >= npage {
         .          .    390:			return
         .          .    391:		}
         .          .    392:	}
         .          .    393:
         .          .    394:	// Now sweep everything that is not yet swept.
         .          .    395:	unlock(&h.lock)
         .          .    396:	for {
         .      970ms    397:		n := sweepone()
         .          .    398:		if n == ^uintptr(0) { // all spans are swept
         .          .    399:			break
         .          .    400:		}
         .          .    401:		reclaimed += n
         .          .    402:		if reclaimed >= npage {
ROUTINE ======================== runtime.(*mheap).reclaimList in /home/isucon/.local/go/src/runtime/mheap.go
         0       90ms (flat, cum)  0.16% of Total
         .          .    342:			list.remove(s)
         .          .    343:			// swept spans are at the end of the list
         .          .    344:			list.insertBack(s)
         .          .    345:			unlock(&h.lock)
         .          .    346:			snpages := s.npages
         .       90ms    347:			if s.sweep(false) {
         .          .    348:				n += snpages
         .          .    349:			}
         .          .    350:			lock(&h.lock)
         .          .    351:			if n >= npages {
         .          .    352:				return n
ROUTINE ======================== runtime.(*mspan).ensureSwept in /home/isucon/.local/go/src/runtime/mgcsweep.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    146:	if atomic.Load(&s.sweepgen) == sg {
         .          .    147:		return
         .          .    148:	}
         .          .    149:	// The caller must be sure that the span is a MSpanInUse span.
         .          .    150:	if atomic.Cas(&s.sweepgen, sg-2, sg-1) {
         .       10ms    151:		s.sweep(false)
         .          .    152:		return
         .          .    153:	}
         .          .    154:	// unfortunate condition, and we don't have efficient means to wait
         .          .    155:	for atomic.Load(&s.sweepgen) != sg {
         .          .    156:		osyield()
ROUTINE ======================== runtime.(*mspan).sweep in /home/isucon/.local/go/src/runtime/mgcsweep.go
     380ms      3.70s (flat, cum)  6.65% of Total
         .          .    178:
         .          .    179:	if trace.enabled {
         .          .    180:		traceGCSweepStart()
         .          .    181:	}
         .          .    182:
         .       10ms    183:	atomic.Xadd64(&mheap_.pagesSwept, int64(s.npages))
         .          .    184:
         .          .    185:	cl := s.sizeclass
         .          .    186:	size := s.elemsize
         .          .    187:	res := false
         .          .    188:	nfree := 0
         .          .    189:
         .          .    190:	var head, end gclinkptr
         .          .    191:
         .          .    192:	c := _g_.m.mcache
         .          .    193:	freeToHeap := false
         .          .    194:
         .          .    195:	// Mark any free objects in this span so we don't collect them.
         .          .    196:	sstart := uintptr(s.start << _PageShift)
     130ms      130ms    197:	for link := s.freelist; link.ptr() != nil; link = link.ptr().next {
      30ms       30ms    198:		if uintptr(link) < sstart || s.limit <= uintptr(link) {
         .          .    199:			// Free list is corrupted.
         .          .    200:			dumpFreeList(s)
         .          .    201:			throw("free list corrupted")
         .          .    202:		}
     160ms      160ms    203:		heapBitsForAddr(uintptr(link)).setMarkedNonAtomic()
         .          .    204:	}
         .          .    205:
         .          .    206:	// Unlink & free special records for any objects we're about to free.
         .          .    207:	// Two complications here:
         .          .    208:	// 1. An object can have both finalizer and profile special records.
         .          .    209:	//    In such case we need to queue finalizer for execution,
         .          .    210:	//    mark the object as live and preserve the profile special.
         .          .    211:	// 2. A tiny object can have several finalizers setup for different offsets.
         .          .    212:	//    If such object is not marked, we need to queue all finalizers at once.
         .          .    213:	// Both 1 and 2 are possible at the same time.
         .          .    214:	specialp := &s.specials
         .          .    215:	special := *specialp
         .          .    216:	for special != nil {
         .          .    217:		// A finalizer can be set for an inner byte of an object, find object beginning.
      10ms       10ms    218:		p := uintptr(s.start<<_PageShift) + uintptr(special.offset)/size*size
         .          .    219:		hbits := heapBitsForAddr(p)
      20ms       20ms    220:		if !hbits.isMarked() {
         .          .    221:			// This object is not marked and has at least one special record.
         .          .    222:			// Pass 1: see if it has at least one finalizer.
      10ms       10ms    223:			hasFin := false
         .          .    224:			endOffset := p - uintptr(s.start<<_PageShift) + size
         .          .    225:			for tmp := special; tmp != nil && uintptr(tmp.offset) < endOffset; tmp = tmp.next {
         .          .    226:				if tmp.kind == _KindSpecialFinalizer {
         .          .    227:					// Stop freeing of object if it has a finalizer.
         .          .    228:					hbits.setMarkedNonAtomic()
         .          .    229:					hasFin = true
         .          .    230:					break
         .          .    231:				}
         .          .    232:			}
         .          .    233:			// Pass 2: queue all finalizers _or_ handle profile record.
         .          .    234:			for special != nil && uintptr(special.offset) < endOffset {
         .          .    235:				// Find the exact byte for which the special was setup
         .          .    236:				// (as opposed to object beginning).
         .          .    237:				p := uintptr(s.start<<_PageShift) + uintptr(special.offset)
         .          .    238:				if special.kind == _KindSpecialFinalizer || !hasFin {
         .          .    239:					// Splice out special record.
         .          .    240:					y := special
         .          .    241:					special = special.next
         .          .    242:					*specialp = special
         .          .    243:					freespecial(y, unsafe.Pointer(p), size)
         .          .    244:				} else {
         .          .    245:					// This is profile record, but the object has finalizers (so kept alive).
         .          .    246:					// Keep special record.
         .          .    247:					specialp = &special.next
         .          .    248:					special = *specialp
         .          .    249:				}
         .          .    250:			}
         .          .    251:		} else {
         .          .    252:			// object is still live: keep special record
         .          .    253:			specialp = &special.next
         .          .    254:			special = *specialp
         .          .    255:		}
         .          .    256:	}
         .          .    257:
         .          .    258:	// Sweep through n objects of given size starting at p.
         .          .    259:	// This thread owns the span now, so it can manipulate
         .          .    260:	// the block bitmap without atomic operations.
         .          .    261:
      10ms       10ms    262:	size, n, _ := s.layout()
         .          .    263:	heapBitsSweepSpan(s.base(), size, n, func(p uintptr) {
         .          .    264:		// At this point we know that we are looking at garbage object
         .          .    265:		// that needs to be collected.
         .          .    266:		if debug.allocfreetrace != 0 {
         .          .    267:			tracefree(unsafe.Pointer(p), size)
         .          .    268:		}
         .          .    269:		if msanenabled {
         .          .    270:			msanfree(unsafe.Pointer(p), size)
         .          .    271:		}
         .          .    272:
         .          .    273:		// Reset to allocated+noscan.
         .          .    274:		if cl == 0 {
         .          .    275:			// Free large span.
         .          .    276:			if preserve {
         .          .    277:				throw("can't preserve large span")
         .          .    278:			}
         .          .    279:			heapBitsForSpan(p).initSpan(s.layout())
         .          .    280:			s.needzero = 1
         .          .    281:
         .          .    282:			// Free the span after heapBitsSweepSpan
         .          .    283:			// returns, since it's not done with the span.
         .          .    284:			freeToHeap = true
         .          .    285:		} else {
         .          .    286:			// Free small object.
         .          .    287:			if size > 2*sys.PtrSize {
         .          .    288:				*(*uintptr)(unsafe.Pointer(p + sys.PtrSize)) = uintptrMask & 0xdeaddeaddeaddead // mark as "needs to be zeroed"
         .          .    289:			} else if size > sys.PtrSize {
         .          .    290:				*(*uintptr)(unsafe.Pointer(p + sys.PtrSize)) = 0
         .          .    291:			}
         .          .    292:			if head.ptr() == nil {
         .          .    293:				head = gclinkptr(p)
         .          .    294:			} else {
         .          .    295:				end.ptr().next = gclinkptr(p)
         .          .    296:			}
         .          .    297:			end = gclinkptr(p)
         .          .    298:			end.ptr().next = gclinkptr(0x0bade5)
         .          .    299:			nfree++
         .          .    300:		}
         .      3.19s    301:	})
         .          .    302:
         .          .    303:	// We need to set s.sweepgen = h.sweepgen only when all blocks are swept,
         .          .    304:	// because of the potential for a concurrent free/SetFinalizer.
         .          .    305:	// But we need to set it before we make the span available for allocation
         .          .    306:	// (return it to heap or mcentral), because allocation code assumes that a
         .          .    307:	// span is already swept if available for allocation.
         .          .    308:	if freeToHeap || nfree == 0 {
         .          .    309:		// The span must be in our exclusive ownership until we update sweepgen,
         .          .    310:		// check for potential races.
         .          .    311:		if s.state != mSpanInUse || s.sweepgen != sweepgen-1 {
         .          .    312:			print("MSpan_Sweep: state=", s.state, " sweepgen=", s.sweepgen, " mheap.sweepgen=", sweepgen, "\n")
         .          .    313:			throw("MSpan_Sweep: bad span state after sweep")
         .          .    314:		}
         .       20ms    315:		atomic.Store(&s.sweepgen, sweepgen)
         .          .    316:	}
         .          .    317:	if nfree > 0 {
      10ms       10ms    318:		c.local_nsmallfree[cl] += uintptr(nfree)
         .      100ms    319:		res = mheap_.central[cl].mcentral.freeSpan(s, int32(nfree), head, end, preserve)
         .          .    320:		// MCentral_FreeSpan updates sweepgen
         .          .    321:	} else if freeToHeap {
         .          .    322:		// Free large span to heap
         .          .    323:
         .          .    324:		// NOTE(rsc,dvyukov): The original implementation of efence
ROUTINE ======================== runtime.(*mspan).sweep.func1 in /home/isucon/.local/go/src/runtime/mgcsweep.go
     2.27s      2.35s (flat, cum)  4.22% of Total
         .          .    258:	// Sweep through n objects of given size starting at p.
         .          .    259:	// This thread owns the span now, so it can manipulate
         .          .    260:	// the block bitmap without atomic operations.
         .          .    261:
         .          .    262:	size, n, _ := s.layout()
     330ms      330ms    263:	heapBitsSweepSpan(s.base(), size, n, func(p uintptr) {
         .          .    264:		// At this point we know that we are looking at garbage object
         .          .    265:		// that needs to be collected.
      30ms       30ms    266:		if debug.allocfreetrace != 0 {
         .          .    267:			tracefree(unsafe.Pointer(p), size)
         .          .    268:		}
         .          .    269:		if msanenabled {
         .          .    270:			msanfree(unsafe.Pointer(p), size)
         .          .    271:		}
         .          .    272:
         .          .    273:		// Reset to allocated+noscan.
      20ms       20ms    274:		if cl == 0 {
         .          .    275:			// Free large span.
         .          .    276:			if preserve {
         .          .    277:				throw("can't preserve large span")
         .          .    278:			}
         .       80ms    279:			heapBitsForSpan(p).initSpan(s.layout())
         .          .    280:			s.needzero = 1
         .          .    281:
         .          .    282:			// Free the span after heapBitsSweepSpan
         .          .    283:			// returns, since it's not done with the span.
         .          .    284:			freeToHeap = true
         .          .    285:		} else {
         .          .    286:			// Free small object.
      60ms       60ms    287:			if size > 2*sys.PtrSize {
     430ms      430ms    288:				*(*uintptr)(unsafe.Pointer(p + sys.PtrSize)) = uintptrMask & 0xdeaddeaddeaddead // mark as "needs to be zeroed"
         .          .    289:			} else if size > sys.PtrSize {
      30ms       30ms    290:				*(*uintptr)(unsafe.Pointer(p + sys.PtrSize)) = 0
         .          .    291:			}
      30ms       30ms    292:			if head.ptr() == nil {
         .          .    293:				head = gclinkptr(p)
         .          .    294:			} else {
      60ms       60ms    295:				end.ptr().next = gclinkptr(p)
         .          .    296:			}
      90ms       90ms    297:			end = gclinkptr(p)
      70ms       70ms    298:			end.ptr().next = gclinkptr(0x0bade5)
     910ms      910ms    299:			nfree++
         .          .    300:		}
     210ms      210ms    301:	})
         .          .    302:
         .          .    303:	// We need to set s.sweepgen = h.sweepgen only when all blocks are swept,
         .          .    304:	// because of the potential for a concurrent free/SetFinalizer.
         .          .    305:	// But we need to set it before we make the span available for allocation
         .          .    306:	// (return it to heap or mcentral), because allocation code assumes that a
ROUTINE ======================== runtime.(*pollCache).alloc in /home/isucon/.local/go/src/runtime/netpoll.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    424:func netpollWriteDeadline(arg interface{}, seq uintptr) {
         .          .    425:	netpolldeadlineimpl(arg.(*pollDesc), seq, false, true)
         .          .    426:}
         .          .    427:
         .          .    428:func (c *pollCache) alloc() *pollDesc {
         .       10ms    429:	lock(&c.lock)
         .          .    430:	if c.first == nil {
         .          .    431:		const pdSize = unsafe.Sizeof(pollDesc{})
         .          .    432:		n := pollBlockSize / pdSize
         .          .    433:		if n == 0 {
         .          .    434:			n = 1
ROUTINE ======================== runtime.(*waitq).dequeue in /home/isucon/.local/go/src/runtime/chan.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    655:
         .          .    656:func (q *waitq) dequeue() *sudog {
         .          .    657:	for {
         .          .    658:		sgp := q.first
         .          .    659:		if sgp == nil {
      10ms       10ms    660:			return nil
         .          .    661:		}
         .          .    662:		y := sgp.next
         .          .    663:		if y == nil {
         .          .    664:			q.first = nil
         .          .    665:			q.last = nil
ROUTINE ======================== runtime.SetFinalizer in /home/isucon/.local/go/src/runtime/mfinal.go
      10ms       70ms (flat, cum)  0.13% of Total
         .          .    280:	if ot.elem == nil {
         .          .    281:		throw("nil elem type!")
         .          .    282:	}
         .          .    283:
         .          .    284:	// find the containing object
         .       10ms    285:	_, base, _ := findObject(e.data)
         .          .    286:
         .          .    287:	if base == nil {
         .          .    288:		// 0-length objects are okay.
         .          .    289:		if e.data == unsafe.Pointer(&zerobase) {
         .          .    290:			return
         .          .    291:		}
         .          .    292:
         .          .    293:		// Global initializers might be linker-allocated.
         .          .    294:		//	var Foo = &Object{}
         .          .    295:		//	func main() {
         .          .    296:		//		runtime.SetFinalizer(Foo, nil)
         .          .    297:		//	}
         .          .    298:		// The relevant segments are: noptrdata, data, bss, noptrbss.
         .          .    299:		// We cannot assume they are in any order or even contiguous,
         .          .    300:		// due to external linking.
         .          .    301:		for datap := &firstmoduledata; datap != nil; datap = datap.next {
         .          .    302:			if datap.noptrdata <= uintptr(e.data) && uintptr(e.data) < datap.enoptrdata ||
         .          .    303:				datap.data <= uintptr(e.data) && uintptr(e.data) < datap.edata ||
         .          .    304:				datap.bss <= uintptr(e.data) && uintptr(e.data) < datap.ebss ||
         .          .    305:				datap.noptrbss <= uintptr(e.data) && uintptr(e.data) < datap.enoptrbss {
         .          .    306:				return
         .          .    307:			}
         .          .    308:		}
         .          .    309:		throw("runtime.SetFinalizer: pointer not in allocated block")
         .          .    310:	}
         .          .    311:
         .          .    312:	if e.data != base {
         .          .    313:		// As an implementation detail we allow to set finalizers for an inner byte
         .          .    314:		// of an object if it could come from tiny alloc (see mallocgc for details).
         .          .    315:		if ot.elem == nil || ot.elem.kind&kindNoPointers == 0 || ot.elem.size >= maxTinySize {
         .          .    316:			throw("runtime.SetFinalizer: pointer not at beginning of allocated block")
         .          .    317:		}
         .          .    318:	}
         .          .    319:
         .          .    320:	f := efaceOf(&finalizer)
         .          .    321:	ftyp := f._type
         .          .    322:	if ftyp == nil {
         .          .    323:		// switch to system stack and remove finalizer
      10ms       10ms    324:		systemstack(func() {
         .          .    325:			removefinalizer(e.data)
         .       20ms    326:		})
         .          .    327:		return
         .          .    328:	}
         .          .    329:
         .          .    330:	if ftyp.kind&kindMask != kindFunc {
         .          .    331:		throw("runtime.SetFinalizer: second argument is " + *ftyp._string + ", not a function")
         .          .    332:	}
         .          .    333:	ft := (*functype)(unsafe.Pointer(ftyp))
         .          .    334:	if ft.dotdotdot || len(ft.in) != 1 {
         .          .    335:		throw("runtime.SetFinalizer: cannot pass " + *etyp._string + " to finalizer " + *ftyp._string)
         .          .    336:	}
         .          .    337:	fint := ft.in[0]
         .          .    338:	switch {
         .          .    339:	case fint == etyp:
         .          .    340:		// ok - same type
         .          .    341:		goto okarg
         .          .    342:	case fint.kind&kindMask == kindPtr:
         .          .    343:		if (fint.x == nil || fint.x.name == nil || etyp.x == nil || etyp.x.name == nil) && (*ptrtype)(unsafe.Pointer(fint)).elem == ot.elem {
         .          .    344:			// ok - not same type, but both pointers,
         .          .    345:			// one or the other is unnamed, and same element type, so assignable.
         .          .    346:			goto okarg
         .          .    347:		}
         .          .    348:	case fint.kind&kindMask == kindInterface:
         .          .    349:		ityp := (*interfacetype)(unsafe.Pointer(fint))
         .          .    350:		if len(ityp.mhdr) == 0 {
         .          .    351:			// ok - satisfies empty interface
         .          .    352:			goto okarg
         .          .    353:		}
         .          .    354:		if assertE2I2(ityp, *efaceOf(&obj), nil) {
         .          .    355:			goto okarg
         .          .    356:		}
         .          .    357:	}
         .          .    358:	throw("runtime.SetFinalizer: cannot pass " + *etyp._string + " to finalizer " + *ftyp._string)
         .          .    359:okarg:
         .          .    360:	// compute size needed for return parameters
         .          .    361:	nret := uintptr(0)
         .          .    362:	for _, t := range ft.out {
         .          .    363:		nret = round(nret, uintptr(t.align)) + uintptr(t.size)
         .          .    364:	}
         .          .    365:	nret = round(nret, sys.PtrSize)
         .          .    366:
         .          .    367:	// make sure we have a finalizer goroutine
         .          .    368:	createfing()
         .          .    369:
         .          .    370:	systemstack(func() {
         .          .    371:		if !addfinalizer(e.data, (*funcval)(f.data), nret, fint, ot) {
         .          .    372:			throw("runtime.SetFinalizer: finalizer already set")
         .          .    373:		}
         .       30ms    374:	})
         .          .    375:}
         .          .    376:
         .          .    377:// Look up pointer v in heap.  Return the span containing the object,
         .          .    378:// the start of the object, and the size of the object.  If the object
         .          .    379:// does not exist, return nil, nil, 0.
ROUTINE ======================== runtime.SetFinalizer.func1 in /home/isucon/.local/go/src/runtime/mfinal.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    320:	f := efaceOf(&finalizer)
         .          .    321:	ftyp := f._type
         .          .    322:	if ftyp == nil {
         .          .    323:		// switch to system stack and remove finalizer
         .          .    324:		systemstack(func() {
         .       20ms    325:			removefinalizer(e.data)
         .          .    326:		})
         .          .    327:		return
         .          .    328:	}
         .          .    329:
         .          .    330:	if ftyp.kind&kindMask != kindFunc {
ROUTINE ======================== runtime.SetFinalizer.func2 in /home/isucon/.local/go/src/runtime/mfinal.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    366:
         .          .    367:	// make sure we have a finalizer goroutine
         .          .    368:	createfing()
         .          .    369:
         .          .    370:	systemstack(func() {
         .       30ms    371:		if !addfinalizer(e.data, (*funcval)(f.data), nret, fint, ot) {
         .          .    372:			throw("runtime.SetFinalizer: finalizer already set")
         .          .    373:		}
         .          .    374:	})
         .          .    375:}
         .          .    376:
ROUTINE ======================== runtime._ExternalCode in /home/isucon/.local/go/src/runtime/proc.go
     100ms      100ms (flat, cum)  0.18% of Total
         .          .   2940:	lock uint32
         .          .   2941:	hz   int32
         .          .   2942:}
         .          .   2943:
         .          .   2944:func _System()       { _System() }
     100ms      100ms   2945:func _ExternalCode() { _ExternalCode() }
         .          .   2946:func _GC()           { _GC() }
         .          .   2947:
         .          .   2948:// Called if we receive a SIGPROF signal.
         .          .   2949:func sigprof(pc, sp, lr uintptr, gp *g, mp *m) {
         .          .   2950:	if prof.hz == 0 {
ROUTINE ======================== runtime._System in /home/isucon/.local/go/src/runtime/proc.go
         0      380ms (flat, cum)  0.68% of Total
         .          .   2939:var prof struct {
         .          .   2940:	lock uint32
         .          .   2941:	hz   int32
         .          .   2942:}
         .          .   2943:
         .      380ms   2944:func _System()       { _System() }
         .          .   2945:func _ExternalCode() { _ExternalCode() }
         .          .   2946:func _GC()           { _GC() }
         .          .   2947:
         .          .   2948:// Called if we receive a SIGPROF signal.
         .          .   2949:func sigprof(pc, sp, lr uintptr, gp *g, mp *m) {
ROUTINE ======================== runtime.addfinalizer in /home/isucon/.local/go/src/runtime/mheap.go
      10ms       30ms (flat, cum) 0.054% of Total
         .          .   1070:}
         .          .   1071:
         .          .   1072:// Adds a finalizer to the object p.  Returns true if it succeeded.
         .          .   1073:func addfinalizer(p unsafe.Pointer, f *funcval, nret uintptr, fint *_type, ot *ptrtype) bool {
         .          .   1074:	lock(&mheap_.speciallock)
         .       10ms   1075:	s := (*specialfinalizer)(mheap_.specialfinalizeralloc.alloc())
         .          .   1076:	unlock(&mheap_.speciallock)
         .          .   1077:	s.special.kind = _KindSpecialFinalizer
         .          .   1078:	s.fn = f
         .          .   1079:	s.nret = nret
         .          .   1080:	s.fint = fint
         .          .   1081:	s.ot = ot
         .       10ms   1082:	if addspecial(p, &s.special) {
         .          .   1083:		// This is responsible for maintaining the same
         .          .   1084:		// GC-related invariants as markrootSpans in any
         .          .   1085:		// situation where it's possible that markrootSpans
         .          .   1086:		// has already run but mark termination hasn't yet.
         .          .   1087:		if gcphase != _GCoff {
         .          .   1088:			_, base, _ := findObject(p)
         .          .   1089:			mp := acquirem()
         .          .   1090:			gcw := &mp.p.ptr().gcw
         .          .   1091:			// Mark everything reachable from the object
         .          .   1092:			// so it's retained for the finalizer.
         .          .   1093:			scanobject(uintptr(base), gcw)
         .          .   1094:			// Mark the finalizer itself, since the
         .          .   1095:			// special isn't part of the GC'd heap.
         .          .   1096:			scanblock(uintptr(unsafe.Pointer(&s.fn)), sys.PtrSize, &oneptrmask[0], gcw)
         .          .   1097:			if gcBlackenPromptly {
         .          .   1098:				gcw.dispose()
         .          .   1099:			}
         .          .   1100:			releasem(mp)
         .          .   1101:		}
      10ms       10ms   1102:		return true
         .          .   1103:	}
         .          .   1104:
         .          .   1105:	// There was an old finalizer
         .          .   1106:	lock(&mheap_.speciallock)
         .          .   1107:	mheap_.specialfinalizeralloc.free(unsafe.Pointer(s))
ROUTINE ======================== runtime.addspecial in /home/isucon/.local/go/src/runtime/mheap.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   1013:
         .          .   1014:	// Splice in record, fill in offset.
         .          .   1015:	s.offset = uint16(offset)
         .          .   1016:	s.next = *t
         .          .   1017:	*t = s
         .       10ms   1018:	unlock(&span.speciallock)
         .          .   1019:	releasem(mp)
         .          .   1020:
         .          .   1021:	return true
         .          .   1022:}
         .          .   1023:
ROUTINE ======================== runtime.adjustdefers in /home/isucon/.local/go/src/runtime/stack.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    687:	adjustpointer(adjinfo, unsafe.Pointer(&gp.sched.ctxt))
         .          .    688:}
         .          .    689:
         .          .    690:func adjustdefers(gp *g, adjinfo *adjustinfo) {
         .          .    691:	// Adjust defer argument blocks the same way we adjust active stack frames.
         .       30ms    692:	tracebackdefers(gp, adjustframe, noescape(unsafe.Pointer(adjinfo)))
         .          .    693:
         .          .    694:	// Adjust pointers in the Defer structs.
         .          .    695:	// Defer structs themselves are never on the stack.
         .          .    696:	for d := gp._defer; d != nil; d = d.link {
         .          .    697:		adjustpointer(adjinfo, unsafe.Pointer(&d.fn))
ROUTINE ======================== runtime.adjustframe in /home/isucon/.local/go/src/runtime/stack.go
      40ms      260ms (flat, cum)  0.47% of Total
         .          .    598:	}
         .          .    599:	f := frame.fn
         .          .    600:	if stackDebug >= 2 {
         .          .    601:		print("    adjusting ", funcname(f), " frame=[", hex(frame.sp), ",", hex(frame.fp), "] pc=", hex(frame.pc), " continpc=", hex(frame.continpc), "\n")
         .          .    602:	}
      10ms       10ms    603:	if f.entry == systemstack_switchPC {
         .          .    604:		// A special routine at the bottom of stack of a goroutine that does an systemstack call.
         .          .    605:		// We will allow it to be copied even though we don't
         .          .    606:		// have full GC info for it (because it is written in asm).
         .          .    607:		return true
         .          .    608:	}
         .          .    609:	if targetpc != f.entry {
         .          .    610:		targetpc--
         .          .    611:	}
         .      150ms    612:	pcdata := pcdatavalue(f, _PCDATA_StackMapIndex, targetpc, &adjinfo.cache)
         .          .    613:	if pcdata == -1 {
         .          .    614:		pcdata = 0 // in prologue
         .          .    615:	}
         .          .    616:
         .          .    617:	// Adjust local variables if stack frame has been allocated.
         .          .    618:	size := frame.varp - frame.sp
         .          .    619:	var minsize uintptr
         .          .    620:	switch sys.TheChar {
         .          .    621:	case '7':
         .          .    622:		minsize = sys.SpAlign
         .          .    623:	default:
         .          .    624:		minsize = sys.MinFrameSize
         .          .    625:	}
         .          .    626:	if size > minsize {
         .          .    627:		var bv bitvector
         .          .    628:		stackmap := (*stackmap)(funcdata(f, _FUNCDATA_LocalsPointerMaps))
      10ms       10ms    629:		if stackmap == nil || stackmap.n <= 0 {
         .          .    630:			print("runtime: frame ", funcname(f), " untyped locals ", hex(frame.varp-size), "+", hex(size), "\n")
         .          .    631:			throw("missing stackmap")
         .          .    632:		}
         .          .    633:		// Locals bitmap information, scan just the pointers in locals.
         .          .    634:		if pcdata < 0 || pcdata >= stackmap.n {
         .          .    635:			// don't know where we are
         .          .    636:			print("runtime: pcdata is ", pcdata, " and ", stackmap.n, " locals stack map entries for ", funcname(f), " (targetpc=", targetpc, ")\n")
         .          .    637:			throw("bad symbol table")
         .          .    638:		}
         .          .    639:		bv = stackmapdata(stackmap, pcdata)
         .          .    640:		size = uintptr(bv.n) * sys.PtrSize
         .          .    641:		if stackDebug >= 3 {
         .          .    642:			print("      locals ", pcdata, "/", stackmap.n, " ", size/sys.PtrSize, " words ", bv.bytedata, "\n")
         .          .    643:		}
         .       50ms    644:		adjustpointers(unsafe.Pointer(frame.varp-size), &bv, adjinfo, f)
         .          .    645:	}
         .          .    646:
         .          .    647:	// Adjust saved base pointer if there is one.
         .          .    648:	if sys.TheChar == '6' && frame.argp-frame.varp == 2*sys.RegSize {
         .          .    649:		if !framepointer_enabled {
         .          .    650:			print("runtime: found space for saved base pointer, but no framepointer experiment\n")
         .          .    651:			print("argp=", hex(frame.argp), " varp=", hex(frame.varp), "\n")
         .          .    652:			throw("bad frame layout")
         .          .    653:		}
         .          .    654:		if stackDebug >= 3 {
         .          .    655:			print("      saved bp\n")
         .          .    656:		}
         .          .    657:		adjustpointer(adjinfo, unsafe.Pointer(frame.varp))
         .          .    658:	}
         .          .    659:
         .          .    660:	// Adjust arguments.
         .          .    661:	if frame.arglen > 0 {
         .          .    662:		var bv bitvector
         .          .    663:		if frame.argmap != nil {
         .          .    664:			bv = *frame.argmap
         .          .    665:		} else {
         .          .    666:			stackmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))
      20ms       20ms    667:			if stackmap == nil || stackmap.n <= 0 {
         .          .    668:				print("runtime: frame ", funcname(f), " untyped args ", frame.argp, "+", uintptr(frame.arglen), "\n")
         .          .    669:				throw("missing stackmap")
         .          .    670:			}
         .          .    671:			if pcdata < 0 || pcdata >= stackmap.n {
         .          .    672:				// don't know where we are
         .          .    673:				print("runtime: pcdata is ", pcdata, " and ", stackmap.n, " args stack map entries for ", funcname(f), " (targetpc=", targetpc, ")\n")
         .          .    674:				throw("bad symbol table")
         .          .    675:			}
         .          .    676:			bv = stackmapdata(stackmap, pcdata)
         .          .    677:		}
         .          .    678:		if stackDebug >= 3 {
         .          .    679:			print("      args\n")
         .          .    680:		}
         .       20ms    681:		adjustpointers(unsafe.Pointer(frame.argp), &bv, adjinfo, nil)
         .          .    682:	}
         .          .    683:	return true
         .          .    684:}
         .          .    685:
         .          .    686:func adjustctxt(gp *g, adjinfo *adjustinfo) {
ROUTINE ======================== runtime.adjustpointers in /home/isucon/.local/go/src/runtime/stack.go
      70ms       70ms (flat, cum)  0.13% of Total
         .          .    562:	bv := gobv(*cbv)
         .          .    563:	minp := adjinfo.old.lo
         .          .    564:	maxp := adjinfo.old.hi
         .          .    565:	delta := adjinfo.delta
         .          .    566:	num := uintptr(bv.n)
      10ms       10ms    567:	for i := uintptr(0); i < num; i++ {
         .          .    568:		if stackDebug >= 4 {
         .          .    569:			print("        ", add(scanp, i*sys.PtrSize), ":", ptrnames[ptrbit(&bv, i)], ":", hex(*(*uintptr)(add(scanp, i*sys.PtrSize))), " # ", i, " ", bv.bytedata[i/8], "\n")
         .          .    570:		}
      20ms       20ms    571:		if ptrbit(&bv, i) == 1 {
      20ms       20ms    572:			pp := (*uintptr)(add(scanp, i*sys.PtrSize))
         .          .    573:			p := *pp
      10ms       10ms    574:			if f != nil && 0 < p && p < _PageSize && debug.invalidptr != 0 || p == poisonStack {
         .          .    575:				// Looks like a junk value in a pointer slot.
         .          .    576:				// Live analysis wrong?
         .          .    577:				getg().m.traceback = 2
         .          .    578:				print("runtime: bad pointer in frame ", funcname(f), " at ", pp, ": ", hex(p), "\n")
         .          .    579:				throw("invalid stack pointer")
         .          .    580:			}
      10ms       10ms    581:			if minp <= p && p < maxp {
         .          .    582:				if stackDebug >= 3 {
         .          .    583:					print("adjust ptr ", p, " ", funcname(f), "\n")
         .          .    584:				}
         .          .    585:				*pp = p + delta
         .          .    586:			}
ROUTINE ======================== runtime.aeshash64 in /home/isucon/.local/go/src/runtime/asm_amd64.s
      10ms       10ms (flat, cum) 0.018% of Total
         .          .   1178:	MOVQ	X0, ret+16(FP)
         .          .   1179:	RET
         .          .   1180:
         .          .   1181:TEXT runtime·aeshash64(SB),NOSPLIT,$0-24
         .          .   1182:	MOVQ	p+0(FP), AX	// ptr to data
      10ms       10ms   1183:	MOVQ	h+8(FP), X0	// seed
         .          .   1184:	PINSRQ	$1, (AX), X0	// data
         .          .   1185:	AESENC	runtime·aeskeysched+0(SB), X0
         .          .   1186:	AESENC	runtime·aeskeysched+16(SB), X0
         .          .   1187:	AESENC	runtime·aeskeysched+32(SB), X0
         .          .   1188:	MOVQ	X0, ret+16(FP)
ROUTINE ======================== runtime.aeshashbody in /home/isucon/.local/go/src/runtime/asm_amd64.s
      40ms       40ms (flat, cum) 0.072% of Total
         .          .    896:	JE	endofpage
         .          .    897:
         .          .    898:	// 16 bytes loaded at this address won't cross
         .          .    899:	// a page boundary, so we can load it directly.
         .          .    900:	MOVOU	-16(AX), X1
      20ms       20ms    901:	ADDQ	CX, CX
         .          .    902:	MOVQ	$masks<>(SB), AX
         .          .    903:	PAND	(AX)(CX*8), X1
         .          .    904:final1:
      10ms       10ms    905:	AESENC	X0, X1	// scramble input, xor in seed
      10ms       10ms    906:	AESENC	X1, X1  // scramble combo 2 times
         .          .    907:	AESENC	X1, X1
         .          .    908:	MOVQ	X1, (DX)
         .          .    909:	RET
         .          .    910:
         .          .    911:endofpage:
ROUTINE ======================== runtime.assertE2I2 in /home/isucon/.local/go/src/runtime/iface.go
      90ms      470ms (flat, cum)  0.84% of Total
         .          .    348:	r.data = e.data
         .          .    349:}
         .          .    350:
         .          .    351:var testingAssertE2I2GC bool
         .          .    352:
      30ms       30ms    353:func assertE2I2(inter *interfacetype, e eface, r *iface) bool {
         .          .    354:	if testingAssertE2I2GC {
         .          .    355:		GC()
         .          .    356:	}
         .          .    357:	t := e._type
         .          .    358:	if t == nil {
         .          .    359:		if r != nil {
         .          .    360:			*r = iface{}
         .          .    361:		}
         .          .    362:		return false
         .          .    363:	}
      30ms      410ms    364:	tab := getitab(inter, t, true)
         .          .    365:	if tab == nil {
      10ms       10ms    366:		if r != nil {
      20ms       20ms    367:			*r = iface{}
         .          .    368:		}
         .          .    369:		return false
         .          .    370:	}
         .          .    371:	if r != nil {
         .          .    372:		r.tab = tab
ROUTINE ======================== runtime.assertE2T in /home/isucon/.local/go/src/runtime/iface.go
      60ms      110ms (flat, cum)   0.2% of Total
         .          .    215:		}
         .          .    216:	}
         .          .    217:	return true
         .          .    218:}
         .          .    219:
      20ms       20ms    220:func assertE2T(t *_type, e eface, r unsafe.Pointer) {
         .          .    221:	if e._type == nil {
         .          .    222:		panic(&TypeAssertionError{"", "", *t._string, ""})
         .          .    223:	}
         .          .    224:	if e._type != t {
         .          .    225:		panic(&TypeAssertionError{"", *e._type._string, *t._string, ""})
         .          .    226:	}
      10ms       10ms    227:	if r != nil {
      10ms       10ms    228:		if isDirectIface(t) {
         .          .    229:			writebarrierptr((*uintptr)(r), uintptr(e.data))
         .          .    230:		} else {
      20ms       70ms    231:			typedmemmove(t, r, e.data)
         .          .    232:		}
         .          .    233:	}
         .          .    234:}
         .          .    235:
         .          .    236:var testingAssertE2T2GC bool
ROUTINE ======================== runtime.assertE2T2 in /home/isucon/.local/go/src/runtime/iface.go
     180ms      890ms (flat, cum)  1.60% of Total
         .          .    234:}
         .          .    235:
         .          .    236:var testingAssertE2T2GC bool
         .          .    237:
         .          .    238:// The compiler ensures that r is non-nil.
      20ms       20ms    239:func assertE2T2(t *_type, e eface, r unsafe.Pointer) bool {
      20ms       20ms    240:	if testingAssertE2T2GC {
         .          .    241:		GC()
         .          .    242:	}
         .          .    243:	if e._type != t {
         .          .    244:		memclr(r, uintptr(t.size))
         .          .    245:		return false
         .          .    246:	}
      40ms       40ms    247:	if isDirectIface(t) {
         .          .    248:		writebarrierptr((*uintptr)(r), uintptr(e.data))
         .          .    249:	} else {
      40ms      750ms    250:		typedmemmove(t, r, e.data)
         .          .    251:	}
      60ms       60ms    252:	return true
         .          .    253:}
         .          .    254:
         .          .    255:func convI2E(i iface) (r eface) {
         .          .    256:	tab := i.tab
         .          .    257:	if tab == nil {
ROUTINE ======================== runtime.assertI2I2 in /home/isucon/.local/go/src/runtime/iface.go
      10ms       30ms (flat, cum) 0.054% of Total
         .          .    320:		if r != nil {
         .          .    321:			*r = iface{}
         .          .    322:		}
         .          .    323:		return false
         .          .    324:	}
      10ms       10ms    325:	if tab.inter != inter {
         .       20ms    326:		tab = getitab(inter, tab._type, true)
         .          .    327:		if tab == nil {
         .          .    328:			if r != nil {
         .          .    329:				*r = iface{}
         .          .    330:			}
         .          .    331:			return false
ROUTINE ======================== runtime.assertI2T2 in /home/isucon/.local/go/src/runtime/iface.go
      20ms       20ms (flat, cum) 0.036% of Total
         .          .    197:			typedmemmove(t, r, i.data)
         .          .    198:		}
         .          .    199:	}
         .          .    200:}
         .          .    201:
      10ms       10ms    202:func assertI2T2(t *_type, i iface, r unsafe.Pointer) bool {
         .          .    203:	tab := i.tab
      10ms       10ms    204:	if tab == nil || tab._type != t {
         .          .    205:		if r != nil {
         .          .    206:			memclr(r, uintptr(t.size))
         .          .    207:		}
         .          .    208:		return false
         .          .    209:	}
ROUTINE ======================== runtime.atomicstorep in /home/isucon/.local/go/src/runtime/atomic_pointer.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .     18://
         .          .     19:// Additionally, these functions must update the shadow heap for
         .          .     20:// write barrier checking.
         .          .     21:
         .          .     22://go:nosplit
      10ms       10ms     23:func atomicstorep(ptr unsafe.Pointer, new unsafe.Pointer) {
         .       10ms     24:	atomic.Storep1(noescape(ptr), new)
         .          .     25:	writebarrierptr_nostore((*uintptr)(ptr), uintptr(new))
         .          .     26:}
         .          .     27:
         .          .     28://go:nosplit
         .          .     29:func casp(ptr *unsafe.Pointer, old, new unsafe.Pointer) bool {
ROUTINE ======================== runtime.bgsweep in /home/isucon/.local/go/src/runtime/mgcsweep.go
         0      2.15s (flat, cum)  3.86% of Total
         .          .     61:	sweep.parked = true
         .          .     62:	c <- 1
         .          .     63:	goparkunlock(&sweep.lock, "GC sweep wait", traceEvGoBlock, 1)
         .          .     64:
         .          .     65:	for {
         .      2.15s     66:		for gosweepone() != ^uintptr(0) {
         .          .     67:			sweep.nbgsweep++
         .          .     68:			Gosched()
         .          .     69:		}
         .          .     70:		lock(&sweep.lock)
         .          .     71:		if !gosweepdone() {
ROUTINE ======================== runtime.call256 in /home/isucon/.local/go/src/runtime/asm_amd64.s
         0       10ms (flat, cum) 0.018% of Total
         .          .    470:	RET
         .          .    471:
         .          .    472:CALLFN(·call32, 32)
         .          .    473:CALLFN(·call64, 64)
         .          .    474:CALLFN(·call128, 128)
         .       10ms    475:CALLFN(·call256, 256)
         .          .    476:CALLFN(·call512, 512)
         .          .    477:CALLFN(·call1024, 1024)
         .          .    478:CALLFN(·call2048, 2048)
         .          .    479:CALLFN(·call4096, 4096)
         .          .    480:CALLFN(·call8192, 8192)
ROUTINE ======================== runtime.call64 in /home/isucon/.local/go/src/runtime/asm_amd64.s
      10ms      300ms (flat, cum)  0.54% of Total
         .          .    468:	MOVQ	BX, 24(SP);			\
         .          .    469:	CALL	runtime·callwritebarrier(SB);	\
         .          .    470:	RET
         .          .    471:
         .          .    472:CALLFN(·call32, 32)
      10ms      300ms    473:CALLFN(·call64, 64)
         .          .    474:CALLFN(·call128, 128)
         .          .    475:CALLFN(·call256, 256)
         .          .    476:CALLFN(·call512, 512)
         .          .    477:CALLFN(·call1024, 1024)
         .          .    478:CALLFN(·call2048, 2048)
ROUTINE ======================== runtime.callers in /home/isucon/.local/go/src/runtime/traceback.go
         0      230ms (flat, cum)  0.41% of Total
         .          .    603:	pc := uintptr(getcallerpc(unsafe.Pointer(&skip)))
         .          .    604:	gp := getg()
         .          .    605:	var n int
         .          .    606:	systemstack(func() {
         .          .    607:		n = gentraceback(pc, sp, 0, gp, skip, &pcbuf[0], len(pcbuf), nil, nil, 0)
         .      230ms    608:	})
         .          .    609:	return n
         .          .    610:}
         .          .    611:
         .          .    612:func gcallers(gp *g, skip int, pcbuf []uintptr) int {
         .          .    613:	return gentraceback(^uintptr(0), ^uintptr(0), 0, gp, skip, &pcbuf[0], len(pcbuf), nil, nil, 0)
ROUTINE ======================== runtime.callers.func1 in /home/isucon/.local/go/src/runtime/traceback.go
         0      230ms (flat, cum)  0.41% of Total
         .          .    602:	sp := getcallersp(unsafe.Pointer(&skip))
         .          .    603:	pc := uintptr(getcallerpc(unsafe.Pointer(&skip)))
         .          .    604:	gp := getg()
         .          .    605:	var n int
         .          .    606:	systemstack(func() {
         .      230ms    607:		n = gentraceback(pc, sp, 0, gp, skip, &pcbuf[0], len(pcbuf), nil, nil, 0)
         .          .    608:	})
         .          .    609:	return n
         .          .    610:}
         .          .    611:
         .          .    612:func gcallers(gp *g, skip int, pcbuf []uintptr) int {
ROUTINE ======================== runtime.callwritebarrier in /home/isucon/.local/go/src/runtime/mbarrier.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    231://go:nosplit
         .          .    232:func callwritebarrier(typ *_type, frame unsafe.Pointer, framesize, retoffset uintptr) {
         .          .    233:	if !writeBarrier.needed || typ == nil || typ.kind&kindNoPointers != 0 || framesize-retoffset < sys.PtrSize || !inheap(uintptr(frame)) {
         .          .    234:		return
         .          .    235:	}
         .       10ms    236:	heapBitsBulkBarrier(uintptr(add(frame, retoffset)), framesize-retoffset)
         .          .    237:}
         .          .    238:
         .          .    239://go:nosplit
         .          .    240:func typedslicecopy(typ *_type, dst, src slice) int {
         .          .    241:	// TODO(rsc): If typedslicecopy becomes faster than calling
ROUTINE ======================== runtime.casgstatus in /home/isucon/.local/go/src/runtime/proc.go
      20ms       70ms (flat, cum)  0.13% of Total
         .          .    702:// and casfrom_Gscanstatus instead.
         .          .    703:// casgstatus will loop if the g->atomicstatus is in a Gscan status until the routine that
         .          .    704:// put it in the Gscan state is finished.
         .          .    705://go:nosplit
         .          .    706:func casgstatus(gp *g, oldval, newval uint32) {
      10ms       10ms    707:	if (oldval&_Gscan != 0) || (newval&_Gscan != 0) || oldval == newval {
         .          .    708:		systemstack(func() {
         .          .    709:			print("runtime: casgstatus: oldval=", hex(oldval), " newval=", hex(newval), "\n")
         .          .    710:			throw("casgstatus: bad incoming values")
         .          .    711:		})
         .          .    712:	}
         .          .    713:
         .          .    714:	if oldval == _Grunning && gp.gcscanvalid {
         .          .    715:		// If oldvall == _Grunning, then the actual status must be
         .          .    716:		// _Grunning or _Grunning|_Gscan; either way,
         .          .    717:		// we own gp.gcscanvalid, so it's safe to read.
         .          .    718:		// gp.gcscanvalid must not be true when we are running.
         .          .    719:		print("runtime: casgstatus ", hex(oldval), "->", hex(newval), " gp.status=", hex(gp.atomicstatus), " gp.gcscanvalid=true\n")
         .          .    720:		throw("casgstatus")
         .          .    721:	}
         .          .    722:
         .          .    723:	// loop if gp->atomicstatus is in a scan state giving
         .          .    724:	// GC time to finish and change the state to oldval.
      10ms       60ms    725:	for !atomic.Cas(&gp.atomicstatus, oldval, newval) {
         .          .    726:		if oldval == _Gwaiting && gp.atomicstatus == _Grunnable {
         .          .    727:			systemstack(func() {
         .          .    728:				throw("casgstatus: waiting for Gwaiting but is Grunnable")
         .          .    729:			})
         .          .    730:		}
ROUTINE ======================== runtime.chanrecv in /home/isucon/.local/go/src/runtime/chan.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    404:	var t0 int64
         .          .    405:	if blockprofilerate > 0 {
         .          .    406:		t0 = cputicks()
         .          .    407:	}
         .          .    408:
         .       10ms    409:	lock(&c.lock)
         .          .    410:
         .          .    411:	if c.closed != 0 && c.qcount == 0 {
         .          .    412:		if raceenabled {
         .          .    413:			raceacquire(unsafe.Pointer(c))
         .          .    414:		}
         .          .    415:		unlock(&c.lock)
         .          .    416:		if ep != nil {
         .          .    417:			memclr(ep, uintptr(c.elemsize))
         .          .    418:		}
         .          .    419:		return true, false
         .          .    420:	}
         .          .    421:
         .          .    422:	if sg := c.sendq.dequeue(); sg != nil {
         .          .    423:		// Found a waiting sender.  If buffer is size 0, receive value
         .          .    424:		// directly from sender.  Otherwise, recieve from head of queue
         .          .    425:		// and add sender's value to the tail of the queue (both map to
         .          .    426:		// the same buffer slot because the queue is full).
         .          .    427:		recv(c, sg, ep, func() { unlock(&c.lock) })
         .          .    428:		return true, true
         .          .    429:	}
         .          .    430:
         .          .    431:	if c.qcount > 0 {
         .          .    432:		// Receive directly from queue
         .          .    433:		qp := chanbuf(c, c.recvx)
         .          .    434:		if raceenabled {
         .          .    435:			raceacquire(qp)
         .          .    436:			racerelease(qp)
         .          .    437:		}
         .          .    438:		if ep != nil {
         .          .    439:			typedmemmove(c.elemtype, ep, qp)
         .          .    440:		}
         .          .    441:		memclr(qp, uintptr(c.elemsize))
         .          .    442:		c.recvx++
         .          .    443:		if c.recvx == c.dataqsiz {
         .          .    444:			c.recvx = 0
         .          .    445:		}
         .          .    446:		c.qcount--
         .          .    447:		unlock(&c.lock)
         .          .    448:		return true, true
         .          .    449:	}
         .          .    450:
         .          .    451:	if !block {
         .          .    452:		unlock(&c.lock)
         .          .    453:		return false, false
         .          .    454:	}
         .          .    455:
         .          .    456:	// no sender available: block on this channel.
         .          .    457:	gp := getg()
         .          .    458:	mysg := acquireSudog()
         .          .    459:	mysg.releasetime = 0
         .          .    460:	if t0 != 0 {
         .          .    461:		mysg.releasetime = -1
         .          .    462:	}
         .          .    463:	mysg.elem = ep
         .          .    464:	mysg.waitlink = nil
         .          .    465:	gp.waiting = mysg
         .          .    466:	mysg.g = gp
         .          .    467:	mysg.selectdone = nil
         .          .    468:	gp.param = nil
         .          .    469:	c.recvq.enqueue(mysg)
         .       20ms    470:	goparkunlock(&c.lock, "chan receive", traceEvGoBlockRecv, 3)
         .          .    471:
         .          .    472:	// someone woke us up
         .          .    473:	if mysg != gp.waiting {
         .          .    474:		throw("G waiting list is corrupted")
         .          .    475:	}
ROUTINE ======================== runtime.chanrecv1 in /home/isucon/.local/go/src/runtime/chan.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    350:}
         .          .    351:
         .          .    352:// entry points for <- c from compiled code
         .          .    353://go:nosplit
         .          .    354:func chanrecv1(t *chantype, c *hchan, elem unsafe.Pointer) {
         .       30ms    355:	chanrecv(t, c, elem, true)
         .          .    356:}
         .          .    357:
         .          .    358://go:nosplit
         .          .    359:func chanrecv2(t *chantype, c *hchan, elem unsafe.Pointer) (received bool) {
         .          .    360:	_, received = chanrecv(t, c, elem, true)
ROUTINE ======================== runtime.chansend in /home/isucon/.local/go/src/runtime/chan.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    165:	if c.closed != 0 {
         .          .    166:		unlock(&c.lock)
         .          .    167:		panic("send on closed channel")
         .          .    168:	}
         .          .    169:
         .       10ms    170:	if sg := c.recvq.dequeue(); sg != nil {
         .          .    171:		// Found a waiting receiver. We pass the value we want to send
         .          .    172:		// directly to the receiver, bypassing the channel buffer (if any).
         .       10ms    173:		send(c, sg, ep, func() { unlock(&c.lock) })
         .          .    174:		return true
         .          .    175:	}
         .          .    176:
         .          .    177:	if c.qcount < c.dataqsiz {
         .          .    178:		// Space is available in the channel buffer.  Enqueue the element to send.
         .          .    179:		qp := chanbuf(c, c.sendx)
         .          .    180:		if raceenabled {
         .          .    181:			raceacquire(qp)
         .          .    182:			racerelease(qp)
         .          .    183:		}
         .          .    184:		typedmemmove(c.elemtype, qp, ep)
         .          .    185:		c.sendx++
         .          .    186:		if c.sendx == c.dataqsiz {
         .          .    187:			c.sendx = 0
         .          .    188:		}
         .          .    189:		c.qcount++
         .          .    190:		unlock(&c.lock)
         .          .    191:		return true
         .          .    192:	}
         .          .    193:
         .          .    194:	if !block {
         .          .    195:		unlock(&c.lock)
         .          .    196:		return false
         .          .    197:	}
         .          .    198:
         .          .    199:	// Block on the channel.  Some receiver will complete our operation for us.
         .          .    200:	gp := getg()
         .          .    201:	mysg := acquireSudog()
         .          .    202:	mysg.releasetime = 0
         .          .    203:	if t0 != 0 {
         .          .    204:		mysg.releasetime = -1
         .          .    205:	}
         .          .    206:	mysg.elem = ep
         .          .    207:	mysg.waitlink = nil
         .          .    208:	mysg.g = gp
         .          .    209:	mysg.selectdone = nil
         .          .    210:	gp.waiting = mysg
         .          .    211:	gp.param = nil
         .          .    212:	c.sendq.enqueue(mysg)
         .       10ms    213:	goparkunlock(&c.lock, "chan send", traceEvGoBlockSend, 3)
         .          .    214:
         .          .    215:	// someone woke us up.
         .          .    216:	if mysg != gp.waiting {
         .          .    217:		throw("G waiting list is corrupted")
         .          .    218:	}
ROUTINE ======================== runtime.chansend1 in /home/isucon/.local/go/src/runtime/chan.go
         0       30ms (flat, cum) 0.054% of Total
         .          .     95:}
         .          .     96:
         .          .     97:// entry point for c <- x from compiled code
         .          .     98://go:nosplit
         .          .     99:func chansend1(t *chantype, c *hchan, elem unsafe.Pointer) {
         .       30ms    100:	chansend(t, c, elem, true, getcallerpc(unsafe.Pointer(&t)))
         .          .    101:}
         .          .    102:
         .          .    103:/*
         .          .    104: * generic single channel send/recv
         .          .    105: * If block is not nil,
ROUTINE ======================== runtime.concatstring2 in /home/isucon/.local/go/src/runtime/string.go
      10ms       40ms (flat, cum) 0.072% of Total
         .          .     54:	}
         .          .     55:	return s
         .          .     56:}
         .          .     57:
         .          .     58:func concatstring2(buf *tmpBuf, a [2]string) string {
      10ms       40ms     59:	return concatstrings(buf, a[:])
         .          .     60:}
         .          .     61:
         .          .     62:func concatstring3(buf *tmpBuf, a [3]string) string {
         .          .     63:	return concatstrings(buf, a[:])
         .          .     64:}
ROUTINE ======================== runtime.concatstring3 in /home/isucon/.local/go/src/runtime/string.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .     57:
         .          .     58:func concatstring2(buf *tmpBuf, a [2]string) string {
         .          .     59:	return concatstrings(buf, a[:])
         .          .     60:}
         .          .     61:
      10ms       10ms     62:func concatstring3(buf *tmpBuf, a [3]string) string {
         .       10ms     63:	return concatstrings(buf, a[:])
         .          .     64:}
         .          .     65:
         .          .     66:func concatstring4(buf *tmpBuf, a [4]string) string {
         .          .     67:	return concatstrings(buf, a[:])
         .          .     68:}
ROUTINE ======================== runtime.concatstrings in /home/isucon/.local/go/src/runtime/string.go
      40ms       60ms (flat, cum)  0.11% of Total
         .          .     22:// if small enough.
         .          .     23:func concatstrings(buf *tmpBuf, a []string) string {
         .          .     24:	idx := 0
         .          .     25:	l := 0
         .          .     26:	count := 0
      20ms       20ms     27:	for i, x := range a {
         .          .     28:		n := len(x)
         .          .     29:		if n == 0 {
         .          .     30:			continue
         .          .     31:		}
      10ms       10ms     32:		if l+n < l {
         .          .     33:			throw("string concatenation too long")
         .          .     34:		}
         .          .     35:		l += n
         .          .     36:		count++
         .          .     37:		idx = i
         .          .     38:	}
         .          .     39:	if count == 0 {
         .          .     40:		return ""
         .          .     41:	}
         .          .     42:
         .          .     43:	// If there is just one string and either it is not on the stack
         .          .     44:	// or our result does not escape the calling frame (buf != nil),
         .          .     45:	// then we can return that string directly.
         .          .     46:	if count == 1 && (buf != nil || !stringDataOnStack(a[idx])) {
         .          .     47:		return a[idx]
         .          .     48:	}
         .       10ms     49:	s, b := rawstringtmp(buf, l)
         .          .     50:	l = 0
         .          .     51:	for _, x := range a {
         .       10ms     52:		copy(b[l:], x)
      10ms       10ms     53:		l += len(x)
         .          .     54:	}
         .          .     55:	return s
         .          .     56:}
         .          .     57:
         .          .     58:func concatstring2(buf *tmpBuf, a [2]string) string {
ROUTINE ======================== runtime.convI2I in /home/isucon/.local/go/src/runtime/iface.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    292:	if tab.inter == inter {
         .          .    293:		r.tab = tab
         .          .    294:		r.data = i.data
         .          .    295:		return
         .          .    296:	}
         .       20ms    297:	r.tab = getitab(inter, tab._type, false)
         .          .    298:	r.data = i.data
         .          .    299:	return
         .          .    300:}
         .          .    301:
         .          .    302:func assertI2I(inter *interfacetype, i iface, r *iface) {
ROUTINE ======================== runtime.convT2E in /home/isucon/.local/go/src/runtime/iface.go
     390ms      5.44s (flat, cum)  9.78% of Total
         .          .    123:	tab := getitab(inter, t, false)
         .          .    124:	atomicstorep(unsafe.Pointer(cache), unsafe.Pointer(tab))
         .          .    125:	return tab
         .          .    126:}
         .          .    127:
     120ms      120ms    128:func convT2E(t *_type, elem unsafe.Pointer, x unsafe.Pointer) (e eface) {
         .          .    129:	if raceenabled {
         .          .    130:		raceReadObjectPC(t, elem, getcallerpc(unsafe.Pointer(&t)), funcPC(convT2E))
         .          .    131:	}
         .          .    132:	if msanenabled {
         .          .    133:		msanread(elem, t.size)
         .          .    134:	}
      90ms       90ms    135:	if isDirectIface(t) {
         .          .    136:		e._type = t
         .          .    137:		typedmemmove(t, unsafe.Pointer(&e.data), elem)
         .          .    138:	} else {
         .          .    139:		if x == nil {
      30ms      4.43s    140:			x = newobject(t)
         .          .    141:		}
         .          .    142:		// TODO: We allocate a zeroed object only to overwrite it with
         .          .    143:		// actual data.  Figure out how to avoid zeroing.  Also below in convT2I.
     100ms      750ms    144:		typedmemmove(t, x, elem)
      30ms       30ms    145:		e._type = t
      10ms       10ms    146:		e.data = x
         .          .    147:	}
      10ms       10ms    148:	return
         .          .    149:}
         .          .    150:
         .          .    151:func convT2I(t *_type, inter *interfacetype, cache **itab, elem unsafe.Pointer, x unsafe.Pointer) (i iface) {
         .          .    152:	if raceenabled {
         .          .    153:		raceReadObjectPC(t, elem, getcallerpc(unsafe.Pointer(&t)), funcPC(convT2I))
ROUTINE ======================== runtime.convT2I in /home/isucon/.local/go/src/runtime/iface.go
      10ms      100ms (flat, cum)  0.18% of Total
         .          .    158:	tab := (*itab)(atomic.Loadp(unsafe.Pointer(cache)))
         .          .    159:	if tab == nil {
         .          .    160:		tab = getitab(inter, t, false)
         .          .    161:		atomicstorep(unsafe.Pointer(cache), unsafe.Pointer(tab))
         .          .    162:	}
      10ms       10ms    163:	if isDirectIface(t) {
         .          .    164:		i.tab = tab
         .          .    165:		typedmemmove(t, unsafe.Pointer(&i.data), elem)
         .          .    166:	} else {
         .          .    167:		if x == nil {
         .       70ms    168:			x = newobject(t)
         .          .    169:		}
         .       20ms    170:		typedmemmove(t, x, elem)
         .          .    171:		i.tab = tab
         .          .    172:		i.data = x
         .          .    173:	}
         .          .    174:	return
         .          .    175:}
ROUTINE ======================== runtime.copystack in /home/isucon/.local/go/src/runtime/stack.go
         0      500ms (flat, cum)   0.9% of Total
         .          .    738:		throw("nil stackbase")
         .          .    739:	}
         .          .    740:	used := old.hi - gp.sched.sp
         .          .    741:
         .          .    742:	// allocate new stack
         .       20ms    743:	new, newstkbar := stackalloc(uint32(newsize))
         .          .    744:	if stackPoisonCopy != 0 {
         .          .    745:		fillstack(new, 0xfd)
         .          .    746:	}
         .          .    747:	if stackDebug >= 1 {
         .          .    748:		print("copystack gp=", gp, " [", hex(old.lo), " ", hex(old.hi-used), " ", hex(old.hi), "]/", gp.stackAlloc, " -> [", hex(new.lo), " ", hex(new.hi-used), " ", hex(new.hi), "]/", newsize, "\n")
         .          .    749:	}
         .          .    750:
         .          .    751:	// Disallow sigprof scans of this stack and block if there's
         .          .    752:	// one in progress.
         .          .    753:	gcLockStackBarriers(gp)
         .          .    754:
         .          .    755:	// adjust pointers in the to-be-copied frames
         .          .    756:	var adjinfo adjustinfo
         .          .    757:	adjinfo.old = old
         .          .    758:	adjinfo.delta = new.hi - old.hi
         .      420ms    759:	gentraceback(^uintptr(0), ^uintptr(0), 0, gp, 0, nil, 0x7fffffff, adjustframe, noescape(unsafe.Pointer(&adjinfo)), 0)
         .          .    760:
         .          .    761:	// adjust other miscellaneous things that have pointers into stacks.
         .          .    762:	adjustctxt(gp, &adjinfo)
         .       30ms    763:	adjustdefers(gp, &adjinfo)
         .          .    764:	adjustpanics(gp, &adjinfo)
         .          .    765:	adjustsudogs(gp, &adjinfo)
         .          .    766:	adjuststkbar(gp, &adjinfo)
         .          .    767:
         .          .    768:	// copy the stack to the new location
         .          .    769:	if stackPoisonCopy != 0 {
         .          .    770:		fillstack(new, 0xfb)
         .          .    771:	}
         .       30ms    772:	memmove(unsafe.Pointer(new.hi-used), unsafe.Pointer(old.hi-used), used)
         .          .    773:
         .          .    774:	// copy old stack barriers to new stack barrier array
         .          .    775:	newstkbar = newstkbar[:len(gp.stkbar)]
         .          .    776:	copy(newstkbar, gp.stkbar)
         .          .    777:
ROUTINE ======================== runtime.deductSweepCredit in /home/isucon/.local/go/src/runtime/mgcsweep.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    378:	// Account for this span allocation.
         .          .    379:	spanBytesAlloc := atomic.Xadd64(&mheap_.spanBytesAlloc, int64(spanBytes))
         .          .    380:
         .          .    381:	// Fix debt if necessary.
         .          .    382:	pagesOwed := int64(mheap_.sweepPagesPerByte * float64(spanBytesAlloc))
         .       10ms    383:	for pagesOwed-int64(atomic.Load64(&mheap_.pagesSwept)) > int64(callerSweepPages) {
         .       10ms    384:		if gosweepone() == ^uintptr(0) {
         .          .    385:			mheap_.sweepPagesPerByte = 0
         .          .    386:			break
         .          .    387:		}
         .          .    388:	}
         .          .    389:}
ROUTINE ======================== runtime.deferproc in /home/isucon/.local/go/src/runtime/panic.go
      40ms      230ms (flat, cum)  0.41% of Total
         .          .     71:}
         .          .     72:
         .          .     73:// Create a new deferred function fn with siz bytes of arguments.
         .          .     74:// The compiler turns a defer statement into a call to this.
         .          .     75://go:nosplit
      10ms       10ms     76:func deferproc(siz int32, fn *funcval) { // arguments of fn follow fn
      10ms       10ms     77:	if getg().m.curg != getg() {
         .          .     78:		// go code on the system stack can't defer
         .          .     79:		throw("defer on system stack")
         .          .     80:	}
         .          .     81:
         .          .     82:	// the arguments of fn are in a perilous state.  The stack map
         .          .     83:	// for deferproc does not describe them.  So we can't let garbage
         .          .     84:	// collection or stack copying trigger until we've copied them out
         .          .     85:	// to somewhere safe.  The memmove below does that.
         .          .     86:	// Until the copy completes, we can only call nosplit routines.
      10ms       20ms     87:	sp := getcallersp(unsafe.Pointer(&siz))
         .          .     88:	argp := uintptr(unsafe.Pointer(&fn)) + unsafe.Sizeof(fn)
         .          .     89:	callerpc := getcallerpc(unsafe.Pointer(&siz))
         .          .     90:
         .          .     91:	systemstack(func() {
         .          .     92:		d := newdefer(siz)
         .          .     93:		if d._panic != nil {
         .          .     94:			throw("deferproc: d.panic != nil after newdefer")
         .          .     95:		}
         .          .     96:		d.fn = fn
         .          .     97:		d.pc = callerpc
         .          .     98:		d.sp = sp
         .          .     99:		memmove(add(unsafe.Pointer(d), unsafe.Sizeof(*d)), unsafe.Pointer(argp), uintptr(siz))
         .      180ms    100:	})
         .          .    101:
         .          .    102:	// deferproc returns 0 normally.
         .          .    103:	// a deferred func that stops a panic
         .          .    104:	// makes the deferproc return 1.
         .          .    105:	// the code the compiler generates always
         .          .    106:	// checks the return value and jumps to the
         .          .    107:	// end of the function if deferproc returns != 0.
      10ms       10ms    108:	return0()
         .          .    109:	// No code can go here - the C return register has
         .          .    110:	// been set and must not be clobbered.
         .          .    111:}
         .          .    112:
         .          .    113:// Small malloc size classes >= 16 are the multiples of 16: 16, 32, 48, 64, 80, 96, 112, 128, 144, ...
ROUTINE ======================== runtime.deferproc.func1 in /home/isucon/.local/go/src/runtime/panic.go
      50ms      180ms (flat, cum)  0.32% of Total
         .          .     86:	// Until the copy completes, we can only call nosplit routines.
         .          .     87:	sp := getcallersp(unsafe.Pointer(&siz))
         .          .     88:	argp := uintptr(unsafe.Pointer(&fn)) + unsafe.Sizeof(fn)
         .          .     89:	callerpc := getcallerpc(unsafe.Pointer(&siz))
         .          .     90:
      20ms       20ms     91:	systemstack(func() {
         .      130ms     92:		d := newdefer(siz)
         .          .     93:		if d._panic != nil {
         .          .     94:			throw("deferproc: d.panic != nil after newdefer")
         .          .     95:		}
      10ms       10ms     96:		d.fn = fn
      10ms       10ms     97:		d.pc = callerpc
         .          .     98:		d.sp = sp
      10ms       10ms     99:		memmove(add(unsafe.Pointer(d), unsafe.Sizeof(*d)), unsafe.Pointer(argp), uintptr(siz))
         .          .    100:	})
         .          .    101:
         .          .    102:	// deferproc returns 0 normally.
         .          .    103:	// a deferred func that stops a panic
         .          .    104:	// makes the deferproc return 1.
ROUTINE ======================== runtime.deferreturn in /home/isucon/.local/go/src/runtime/panic.go
     200ms      370ms (flat, cum)  0.66% of Total
         .          .    278:// call the deferred function.
         .          .    279:
         .          .    280:// The single argument isn't actually used - it just has its address
         .          .    281:// taken so it can be matched against pending defers.
         .          .    282://go:nosplit
      20ms       20ms    283:func deferreturn(arg0 uintptr) {
      30ms       30ms    284:	gp := getg()
         .          .    285:	d := gp._defer
      10ms       10ms    286:	if d == nil {
         .          .    287:		return
         .          .    288:	}
      10ms       40ms    289:	sp := getcallersp(unsafe.Pointer(&arg0))
      80ms       80ms    290:	if d.sp != sp {
      10ms       10ms    291:		return
         .          .    292:	}
         .          .    293:
         .          .    294:	// Moving arguments around.
         .          .    295:	// Do not allow preemption here, because the garbage collector
         .          .    296:	// won't know the form of the arguments until the jmpdefer can
         .          .    297:	// flip the PC over to fn.
      10ms       10ms    298:	mp := acquirem()
      10ms       40ms    299:	memmove(unsafe.Pointer(&arg0), deferArgs(d), uintptr(d.siz))
         .          .    300:	fn := d.fn
      10ms       10ms    301:	d.fn = nil
         .       10ms    302:	gp._defer = d.link
         .          .    303:	// Switch to systemstack merely to save nosplit stack space.
         .          .    304:	systemstack(func() {
         .          .    305:		freedefer(d)
         .      100ms    306:	})
      10ms       10ms    307:	releasem(mp)
         .          .    308:	jmpdefer(fn, uintptr(unsafe.Pointer(&arg0)))
         .          .    309:}
         .          .    310:
         .          .    311:// Goexit terminates the goroutine that calls it.  No other goroutine is affected.
         .          .    312:// Goexit runs all deferred calls before terminating the goroutine.  Because Goexit
ROUTINE ======================== runtime.deferreturn.func1 in /home/isucon/.local/go/src/runtime/panic.go
      20ms      100ms (flat, cum)  0.18% of Total
         .          .    299:	memmove(unsafe.Pointer(&arg0), deferArgs(d), uintptr(d.siz))
         .          .    300:	fn := d.fn
         .          .    301:	d.fn = nil
         .          .    302:	gp._defer = d.link
         .          .    303:	// Switch to systemstack merely to save nosplit stack space.
      20ms       20ms    304:	systemstack(func() {
         .       80ms    305:		freedefer(d)
         .          .    306:	})
         .          .    307:	releasem(mp)
         .          .    308:	jmpdefer(fn, uintptr(unsafe.Pointer(&arg0)))
         .          .    309:}
         .          .    310:
ROUTINE ======================== runtime.duffcopy in /home/isucon/.local/go/src/runtime/duff_amd64.s
      40ms       40ms (flat, cum) 0.072% of Total
         .          .    348:	ADDQ	$16, SI
         .          .    349:	MOVUPS	X0, (DI)
         .          .    350:	ADDQ	$16, DI
         .          .    351:
         .          .    352:	MOVUPS	(SI), X0
      10ms       10ms    353:	ADDQ	$16, SI
         .          .    354:	MOVUPS	X0, (DI)
         .          .    355:	ADDQ	$16, DI
         .          .    356:
         .          .    357:	MOVUPS	(SI), X0
         .          .    358:	ADDQ	$16, SI
         .          .    359:	MOVUPS	X0, (DI)
         .          .    360:	ADDQ	$16, DI
         .          .    361:
         .          .    362:	MOVUPS	(SI), X0
         .          .    363:	ADDQ	$16, SI
         .          .    364:	MOVUPS	X0, (DI)
         .          .    365:	ADDQ	$16, DI
         .          .    366:
         .          .    367:	MOVUPS	(SI), X0
         .          .    368:	ADDQ	$16, SI
         .          .    369:	MOVUPS	X0, (DI)
      10ms       10ms    370:	ADDQ	$16, DI
         .          .    371:
         .          .    372:	MOVUPS	(SI), X0
         .          .    373:	ADDQ	$16, SI
         .          .    374:	MOVUPS	X0, (DI)
         .          .    375:	ADDQ	$16, DI
         .          .    376:
         .          .    377:	MOVUPS	(SI), X0
         .          .    378:	ADDQ	$16, SI
         .          .    379:	MOVUPS	X0, (DI)
         .          .    380:	ADDQ	$16, DI
         .          .    381:
         .          .    382:	MOVUPS	(SI), X0
         .          .    383:	ADDQ	$16, SI
         .          .    384:	MOVUPS	X0, (DI)
         .          .    385:	ADDQ	$16, DI
         .          .    386:
         .          .    387:	MOVUPS	(SI), X0
         .          .    388:	ADDQ	$16, SI
         .          .    389:	MOVUPS	X0, (DI)
         .          .    390:	ADDQ	$16, DI
         .          .    391:
         .          .    392:	MOVUPS	(SI), X0
         .          .    393:	ADDQ	$16, SI
         .          .    394:	MOVUPS	X0, (DI)
         .          .    395:	ADDQ	$16, DI
         .          .    396:
         .          .    397:	MOVUPS	(SI), X0
      10ms       10ms    398:	ADDQ	$16, SI
         .          .    399:	MOVUPS	X0, (DI)
         .          .    400:	ADDQ	$16, DI
         .          .    401:
         .          .    402:	MOVUPS	(SI), X0
         .          .    403:	ADDQ	$16, SI
         .          .    404:	MOVUPS	X0, (DI)
         .          .    405:	ADDQ	$16, DI
         .          .    406:
         .          .    407:	MOVUPS	(SI), X0
         .          .    408:	ADDQ	$16, SI
         .          .    409:	MOVUPS	X0, (DI)
         .          .    410:	ADDQ	$16, DI
         .          .    411:
         .          .    412:	MOVUPS	(SI), X0
         .          .    413:	ADDQ	$16, SI
         .          .    414:	MOVUPS	X0, (DI)
         .          .    415:	ADDQ	$16, DI
         .          .    416:
         .          .    417:	MOVUPS	(SI), X0
      10ms       10ms    418:	ADDQ	$16, SI
         .          .    419:	MOVUPS	X0, (DI)
         .          .    420:	ADDQ	$16, DI
         .          .    421:
         .          .    422:	MOVUPS	(SI), X0
         .          .    423:	ADDQ	$16, SI
ROUTINE ======================== runtime.duffzero in /home/isucon/.local/go/src/runtime/duff_amd64.s
      30ms       30ms (flat, cum) 0.054% of Total
         .          .     89:	MOVUPS	X0,48(DI)
         .          .     90:	ADDQ	$64,DI
         .          .     91:
         .          .     92:	MOVUPS	X0,(DI)
         .          .     93:	MOVUPS	X0,16(DI)
      10ms       10ms     94:	MOVUPS	X0,32(DI)
      20ms       20ms     95:	MOVUPS	X0,48(DI)
         .          .     96:	ADDQ	$64,DI
         .          .     97:
         .          .     98:	MOVUPS	X0,(DI)
         .          .     99:	MOVUPS	X0,16(DI)
         .          .    100:	MOVUPS	X0,32(DI)
ROUTINE ======================== runtime.efaceeq in /home/isucon/.local/go/src/runtime/alg.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    232:	return ifaceeq(*(*iface)(p), *(*iface)(q))
         .          .    233:}
         .          .    234:func nilinterequal(p, q unsafe.Pointer) bool {
         .          .    235:	return efaceeq(*(*eface)(p), *(*eface)(q))
         .          .    236:}
      10ms       10ms    237:func efaceeq(x, y eface) bool {
         .          .    238:	t := x._type
         .          .    239:	if t != y._type {
         .          .    240:		return false
         .          .    241:	}
         .          .    242:	if t == nil {
ROUTINE ======================== runtime.efacethash in /home/isucon/.local/go/src/runtime/iface.go
     210ms      210ms (flat, cum)  0.38% of Total
         .          .    405:	}
         .          .    406:	return tab._type.hash
         .          .    407:}
         .          .    408:
         .          .    409:func efacethash(e eface) uint32 {
      40ms       40ms    410:	t := e._type
      40ms       40ms    411:	if t == nil {
         .          .    412:		return 0
         .          .    413:	}
     130ms      130ms    414:	return t.hash
         .          .    415:}
         .          .    416:
         .          .    417:func iterate_itabs(fn func(*itab)) {
         .          .    418:	for _, h := range &hash {
         .          .    419:		for ; h != nil; h = h.link {
ROUTINE ======================== runtime.entersyscall in /home/isucon/.local/go/src/runtime/proc.go
      30ms      120ms (flat, cum)  0.22% of Total
         .          .   2322:	_g_.m.locks--
         .          .   2323:}
         .          .   2324:
         .          .   2325:// Standard syscall entry used by the go syscall library and normal cgo calls.
         .          .   2326://go:nosplit
      10ms       10ms   2327:func entersyscall(dummy int32) {
      20ms      110ms   2328:	reentersyscall(getcallerpc(unsafe.Pointer(&dummy)), getcallersp(unsafe.Pointer(&dummy)))
         .          .   2329:}
         .          .   2330:
         .          .   2331:func entersyscall_sysmon() {
         .          .   2332:	lock(&sched.lock)
         .          .   2333:	if atomic.Load(&sched.sysmonwait) != 0 {
ROUTINE ======================== runtime.epollctl in /home/isucon/.local/go/src/runtime/sys_linux_amd64.s
      70ms       70ms (flat, cum)  0.13% of Total
         .          .    428:	MOVL	op+4(FP), SI
         .          .    429:	MOVL	fd+8(FP), DX
         .          .    430:	MOVQ	ev+16(FP), R10
         .          .    431:	MOVL	$233, AX			// syscall entry
         .          .    432:	SYSCALL
      70ms       70ms    433:	MOVL	AX, ret+24(FP)
         .          .    434:	RET
         .          .    435:
         .          .    436:// int32 runtime·epollwait(int32 epfd, EpollEvent *ev, int32 nev, int32 timeout);
         .          .    437:TEXT runtime·epollwait(SB),NOSPLIT,$0
         .          .    438:	MOVL	epfd+0(FP), DI
ROUTINE ======================== runtime.epollwait in /home/isucon/.local/go/src/runtime/sys_linux_amd64.s
      20ms       20ms (flat, cum) 0.036% of Total
         .          .    439:	MOVQ	ev+8(FP), SI
         .          .    440:	MOVL	nev+16(FP), DX
         .          .    441:	MOVL	timeout+20(FP), R10
         .          .    442:	MOVL	$232, AX			// syscall entry
         .          .    443:	SYSCALL
      20ms       20ms    444:	MOVL	AX, ret+24(FP)
         .          .    445:	RET
         .          .    446:
         .          .    447:// void runtime·closeonexec(int32 fd);
         .          .    448:TEXT runtime·closeonexec(SB),NOSPLIT,$0
         .          .    449:	MOVL    fd+0(FP), DI  // fd
ROUTINE ======================== runtime.eqstring in /home/isucon/.local/go/src/runtime/asm_amd64.s
      80ms       80ms (flat, cum)  0.14% of Total
         .          .   1293:// The compiler guarantees that strings passed
         .          .   1294:// to eqstring have equal length.
         .          .   1295:// See runtime_test.go:eqstring_generic for
         .          .   1296:// equivalent Go code.
         .          .   1297:TEXT runtime·eqstring(SB),NOSPLIT,$0-33
      10ms       10ms   1298:	MOVQ	s1str+0(FP), SI
      30ms       30ms   1299:	MOVQ	s2str+16(FP), DI
         .          .   1300:	CMPQ	SI, DI
         .          .   1301:	JEQ	eq
      20ms       20ms   1302:	MOVQ	s1len+8(FP), BX
         .          .   1303:	LEAQ	v+32(FP), AX
      20ms       20ms   1304:	JMP	runtime·memeqbody(SB)
         .          .   1305:eq:
         .          .   1306:	MOVB	$1, v+32(FP)
         .          .   1307:	RET
         .          .   1308:
         .          .   1309:// a in SI
ROUTINE ======================== runtime.evacuate in /home/isucon/.local/go/src/runtime/hashmap.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    915:					}
         .          .    916:					x.tophash[xi] = top
         .          .    917:					if t.indirectkey {
         .          .    918:						*(*unsafe.Pointer)(xk) = k2 // copy pointer
         .          .    919:					} else {
         .       10ms    920:						typedmemmove(t.key, xk, k) // copy value
         .          .    921:					}
         .          .    922:					if t.indirectvalue {
         .          .    923:						*(*unsafe.Pointer)(xv) = *(*unsafe.Pointer)(v)
         .          .    924:					} else {
         .       10ms    925:						typedmemmove(t.elem, xv, v)
         .          .    926:					}
         .          .    927:					xi++
         .          .    928:					xk = add(xk, uintptr(t.keysize))
         .          .    929:					xv = add(xv, uintptr(t.valuesize))
         .          .    930:				} else {
         .          .    931:					b.tophash[i] = evacuatedY
         .          .    932:					if yi == bucketCnt {
         .          .    933:						newy := (*bmap)(newobject(t.bucket))
         .          .    934:						h.setoverflow(t, y, newy)
         .          .    935:						y = newy
         .          .    936:						yi = 0
         .          .    937:						yk = add(unsafe.Pointer(y), dataOffset)
         .          .    938:						yv = add(yk, bucketCnt*uintptr(t.keysize))
         .          .    939:					}
         .          .    940:					y.tophash[yi] = top
         .          .    941:					if t.indirectkey {
         .          .    942:						*(*unsafe.Pointer)(yk) = k2
         .          .    943:					} else {
         .          .    944:						typedmemmove(t.key, yk, k)
         .          .    945:					}
         .          .    946:					if t.indirectvalue {
         .          .    947:						*(*unsafe.Pointer)(yv) = *(*unsafe.Pointer)(v)
         .          .    948:					} else {
         .       10ms    949:						typedmemmove(t.elem, yv, v)
         .          .    950:					}
         .          .    951:					yi++
         .          .    952:					yk = add(yk, uintptr(t.keysize))
         .          .    953:					yv = add(yv, uintptr(t.valuesize))
         .          .    954:				}
ROUTINE ======================== runtime.execute in /home/isucon/.local/go/src/runtime/proc.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .   1747:// current time slice. Otherwise, it starts a new time slice.
         .          .   1748:// Never returns.
         .          .   1749:func execute(gp *g, inheritTime bool) {
         .          .   1750:	_g_ := getg()
         .          .   1751:
         .       10ms   1752:	casgstatus(gp, _Grunnable, _Grunning)
         .          .   1753:	gp.waitsince = 0
         .          .   1754:	gp.preempt = false
         .          .   1755:	gp.stackguard0 = gp.stack.lo + _StackGuard
         .          .   1756:	if !inheritTime {
      10ms       10ms   1757:		_g_.m.p.ptr().schedtick++
         .          .   1758:	}
         .          .   1759:	_g_.m.curg = gp
         .          .   1760:	gp.m = _g_.m
         .          .   1761:
         .          .   1762:	// Check whether the profiler needs to be turned on or off.
ROUTINE ======================== runtime.exitsyscall in /home/isucon/.local/go/src/runtime/proc.go
      70ms       90ms (flat, cum)  0.16% of Total
         .          .   2409:// The goroutine g exited its system call.
         .          .   2410:// Arrange for it to run on a cpu again.
         .          .   2411:// This is called only from the go syscall library, not
         .          .   2412:// from the low-level system calls used by the
         .          .   2413://go:nosplit
      10ms       10ms   2414:func exitsyscall(dummy int32) {
      10ms       10ms   2415:	_g_ := getg()
         .          .   2416:
      10ms       10ms   2417:	_g_.m.locks++ // see comment in entersyscall
      10ms       10ms   2418:	if getcallersp(unsafe.Pointer(&dummy)) > _g_.syscallsp {
         .          .   2419:		throw("exitsyscall: syscall frame is no longer valid")
         .          .   2420:	}
         .          .   2421:
      10ms       10ms   2422:	_g_.waitsince = 0
         .          .   2423:	oldp := _g_.m.p.ptr()
         .       10ms   2424:	if exitsyscallfast() {
         .          .   2425:		if _g_.m.mcache == nil {
         .          .   2426:			throw("lost mcache")
         .          .   2427:		}
      10ms       10ms   2428:		if trace.enabled {
         .          .   2429:			if oldp != _g_.m.p.ptr() || _g_.m.syscalltick != _g_.m.p.ptr().syscalltick {
         .          .   2430:				systemstack(traceGoStart)
         .          .   2431:			}
         .          .   2432:		}
         .          .   2433:		// There's a cpu for us, so we can run.
         .          .   2434:		_g_.m.p.ptr().syscalltick++
         .          .   2435:		// We need to cas the status and scan before resuming...
         .       10ms   2436:		casgstatus(_g_, _Gsyscall, _Grunning)
         .          .   2437:
         .          .   2438:		// Garbage collector isn't running (since we are),
         .          .   2439:		// so okay to clear syscallsp.
         .          .   2440:		_g_.syscallsp = 0
         .          .   2441:		_g_.m.locks--
         .          .   2442:		if _g_.preempt {
         .          .   2443:			// restore the preemption request in case we've cleared it in newstack
         .          .   2444:			_g_.stackguard0 = stackPreempt
         .          .   2445:		} else {
         .          .   2446:			// otherwise restore the real _StackGuard, we've spoiled it in entersyscall/entersyscallblock
      10ms       10ms   2447:			_g_.stackguard0 = _g_.stack.lo + _StackGuard
         .          .   2448:		}
         .          .   2449:		_g_.throwsplit = false
         .          .   2450:		return
         .          .   2451:	}
         .          .   2452:
ROUTINE ======================== runtime.exitsyscall0 in /home/isucon/.local/go/src/runtime/proc.go
         0       60ms (flat, cum)  0.11% of Total
         .          .   2582:	if _g_.m.lockedg != nil {
         .          .   2583:		// Wait until another thread schedules gp and so m again.
         .          .   2584:		stoplockedm()
         .          .   2585:		execute(gp, false) // Never returns.
         .          .   2586:	}
         .       60ms   2587:	stopm()
         .          .   2588:	schedule() // Never returns.
         .          .   2589:}
         .          .   2590:
         .          .   2591:func beforefork() {
         .          .   2592:	gp := getg().m.curg
ROUTINE ======================== runtime.exitsyscallfast in /home/isucon/.local/go/src/runtime/proc.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .   2488://go:nosplit
         .          .   2489:func exitsyscallfast() bool {
         .          .   2490:	_g_ := getg()
         .          .   2491:
         .          .   2492:	// Freezetheworld sets stopwait but does not retake P's.
      10ms       10ms   2493:	if sched.stopwait == freezeStopWait {
         .          .   2494:		_g_.m.mcache = nil
         .          .   2495:		_g_.m.p = 0
         .          .   2496:		return false
         .          .   2497:	}
         .          .   2498:
ROUTINE ======================== runtime.fastlog2 in /home/isucon/.local/go/src/runtime/fastlog2.go
      20ms       20ms (flat, cum) 0.036% of Total
         .          .     11:// sampling, without introducing dependences into package math. This
         .          .     12:// uses a very rough approximation using the float64 exponent and the
         .          .     13:// first 25 bits of the mantissa. The top 5 bits of the mantissa are
         .          .     14:// used to load limits from a table of constants and the rest are used
         .          .     15:// to scale linearly between them.
      20ms       20ms     16:func fastlog2(x float64) float64 {
         .          .     17:	const fastlogScaleBits = 20
         .          .     18:	const fastlogScaleRatio = 1.0 / (1 << fastlogScaleBits)
         .          .     19:
         .          .     20:	xBits := float64bits(x)
         .          .     21:	// Extract the exponent from the IEEE float64, and index a constant
ROUTINE ======================== runtime.fastrand1 in /home/isucon/.local/go/src/runtime/asm_amd64.s
      10ms       10ms (flat, cum) 0.018% of Total
         .          .   1967:TEXT runtime·fastrand1(SB), NOSPLIT, $0-4
         .          .   1968:	get_tls(CX)
         .          .   1969:	MOVQ	g(CX), AX
         .          .   1970:	MOVQ	g_m(AX), AX
         .          .   1971:	MOVL	m_fastrand(AX), DX
      10ms       10ms   1972:	ADDL	DX, DX
         .          .   1973:	MOVL	DX, BX
         .          .   1974:	XORL	$0x88888eef, DX
         .          .   1975:	CMOVLMI	BX, DX
         .          .   1976:	MOVL	DX, m_fastrand(AX)
         .          .   1977:	MOVL	DX, ret+0(FP)
ROUTINE ======================== runtime.findObject in /home/isucon/.local/go/src/runtime/mfinal.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    377:// Look up pointer v in heap.  Return the span containing the object,
         .          .    378:// the start of the object, and the size of the object.  If the object
         .          .    379:// does not exist, return nil, nil, 0.
         .          .    380:func findObject(v unsafe.Pointer) (s *mspan, x unsafe.Pointer, n uintptr) {
         .          .    381:	c := gomcache()
      10ms       10ms    382:	c.local_nlookup++
         .          .    383:	if sys.PtrSize == 4 && c.local_nlookup >= 1<<30 {
         .          .    384:		// purge cache stats to prevent overflow
         .          .    385:		lock(&mheap_.lock)
         .          .    386:		purgecachedstats(c)
         .          .    387:		unlock(&mheap_.lock)
ROUTINE ======================== runtime.findfunc in /home/isucon/.local/go/src/runtime/symtab.go
      50ms       60ms (flat, cum)  0.11% of Total
         .          .    205:	}
         .          .    206:	return nil
         .          .    207:}
         .          .    208:
         .          .    209:func findfunc(pc uintptr) *_func {
         .       10ms    210:	datap := findmoduledatap(pc)
         .          .    211:	if datap == nil {
         .          .    212:		return nil
         .          .    213:	}
         .          .    214:	const nsub = uintptr(len(findfuncbucket{}.subbuckets))
         .          .    215:
         .          .    216:	x := pc - datap.minpc
         .          .    217:	b := x / pcbucketsize
         .          .    218:	i := x % pcbucketsize / (pcbucketsize / nsub)
         .          .    219:
         .          .    220:	ffb := (*findfuncbucket)(add(unsafe.Pointer(datap.findfunctab), b*unsafe.Sizeof(findfuncbucket{})))
      30ms       30ms    221:	idx := ffb.idx + uint32(ffb.subbuckets[i])
      10ms       10ms    222:	if pc < datap.ftab[idx].entry {
         .          .    223:		throw("findfunc: bad findfunctab entry")
         .          .    224:	}
         .          .    225:
         .          .    226:	// linear search to find func with pc >= entry.
      10ms       10ms    227:	for datap.ftab[idx+1].entry <= pc {
         .          .    228:		idx++
         .          .    229:	}
         .          .    230:	return (*_func)(unsafe.Pointer(&datap.pclntable[datap.ftab[idx].funcoff]))
         .          .    231:}
         .          .    232:
ROUTINE ======================== runtime.findmoduledatap in /home/isucon/.local/go/src/runtime/symtab.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    196:	file, line32 := funcline1(f.raw(), pc, false)
         .          .    197:	return file, int(line32)
         .          .    198:}
         .          .    199:
         .          .    200:func findmoduledatap(pc uintptr) *moduledata {
      10ms       10ms    201:	for datap := &firstmoduledata; datap != nil; datap = datap.next {
         .          .    202:		if datap.minpc <= pc && pc < datap.maxpc {
         .          .    203:			return datap
         .          .    204:		}
         .          .    205:	}
         .          .    206:	return nil
ROUTINE ======================== runtime.findrunnable in /home/isucon/.local/go/src/runtime/proc.go
      10ms       60ms (flat, cum)  0.11% of Total
         .          .   1808:		goto top
         .          .   1809:	}
         .          .   1810:	if _g_.m.p.ptr().runSafePointFn != 0 {
         .          .   1811:		runSafePointFn()
         .          .   1812:	}
      10ms       10ms   1813:	if fingwait && fingwake {
         .          .   1814:		if gp := wakefing(); gp != nil {
         .       10ms   1815:			ready(gp, 0)
         .          .   1816:		}
         .          .   1817:	}
         .          .   1818:
         .          .   1819:	// local runq
         .          .   1820:	if gp, inheritTime := runqget(_g_.m.p.ptr()); gp != nil {
         .          .   1821:		return gp, inheritTime
         .          .   1822:	}
         .          .   1823:
         .          .   1824:	// global runq
         .          .   1825:	if sched.runqsize != 0 {
         .          .   1826:		lock(&sched.lock)
         .          .   1827:		gp := globrunqget(_g_.m.p.ptr(), 0)
         .          .   1828:		unlock(&sched.lock)
         .          .   1829:		if gp != nil {
         .          .   1830:			return gp, false
         .          .   1831:		}
         .          .   1832:	}
         .          .   1833:
         .          .   1834:	// Poll network.
         .          .   1835:	// This netpoll is only an optimization before we resort to stealing.
         .          .   1836:	// We can safely skip it if there a thread blocked in netpoll already.
         .          .   1837:	// If there is any kind of logical race with that blocked thread
         .          .   1838:	// (e.g. it has already returned from netpoll, but does not set lastpoll yet),
         .          .   1839:	// this thread will do blocking netpoll below anyway.
         .          .   1840:	if netpollinited() && sched.lastpoll != 0 {
         .          .   1841:		if gp := netpoll(false); gp != nil { // non-blocking
         .          .   1842:			// netpoll returns list of goroutines linked by schedlink.
         .          .   1843:			injectglist(gp.schedlink.ptr())
         .          .   1844:			casgstatus(gp, _Gwaiting, _Grunnable)
         .          .   1845:			if trace.enabled {
         .          .   1846:				traceGoUnpark(gp, 0)
         .          .   1847:			}
         .          .   1848:			return gp, false
         .          .   1849:		}
         .          .   1850:	}
         .          .   1851:
         .          .   1852:	// If number of spinning M's >= number of busy P's, block.
         .          .   1853:	// This is necessary to prevent excessive CPU consumption
         .          .   1854:	// when GOMAXPROCS>>1 but the program parallelism is low.
         .          .   1855:	if !_g_.m.spinning && 2*atomic.Load(&sched.nmspinning) >= uint32(gomaxprocs)-atomic.Load(&sched.npidle) { // TODO: fast atomic
         .          .   1856:		goto stop
         .          .   1857:	}
         .          .   1858:	if !_g_.m.spinning {
         .          .   1859:		_g_.m.spinning = true
         .          .   1860:		atomic.Xadd(&sched.nmspinning, 1)
         .          .   1861:	}
         .          .   1862:	// random steal from other P's
         .          .   1863:	for i := 0; i < int(4*gomaxprocs); i++ {
         .          .   1864:		if sched.gcwaiting != 0 {
         .          .   1865:			goto top
         .          .   1866:		}
         .          .   1867:		_p_ := allp[fastrand1()%uint32(gomaxprocs)]
         .          .   1868:		var gp *g
         .          .   1869:		if _p_ == _g_.m.p.ptr() {
         .          .   1870:			gp, _ = runqget(_p_)
         .          .   1871:		} else {
         .          .   1872:			stealRunNextG := i > 2*int(gomaxprocs) // first look for ready queues with more than 1 g
         .          .   1873:			gp = runqsteal(_g_.m.p.ptr(), _p_, stealRunNextG)
         .          .   1874:		}
         .          .   1875:		if gp != nil {
         .          .   1876:			return gp, false
         .          .   1877:		}
         .          .   1878:	}
         .          .   1879:
         .          .   1880:stop:
         .          .   1881:
         .          .   1882:	// We have nothing to do. If we're in the GC mark phase, can
         .          .   1883:	// safely scan and blacken objects, and have work to do, run
         .          .   1884:	// idle-time marking rather than give up the P.
         .          .   1885:	if _p_ := _g_.m.p.ptr(); gcBlackenEnabled != 0 && _p_.gcBgMarkWorker != 0 && gcMarkWorkAvailable(_p_) {
         .          .   1886:		_p_.gcMarkWorkerMode = gcMarkWorkerIdleMode
         .          .   1887:		gp := _p_.gcBgMarkWorker.ptr()
         .          .   1888:		casgstatus(gp, _Gwaiting, _Grunnable)
         .          .   1889:		if trace.enabled {
         .          .   1890:			traceGoUnpark(gp, 0)
         .          .   1891:		}
         .          .   1892:		return gp, false
         .          .   1893:	}
         .          .   1894:
         .          .   1895:	// return P and block
         .          .   1896:	lock(&sched.lock)
         .          .   1897:	if sched.gcwaiting != 0 || _g_.m.p.ptr().runSafePointFn != 0 {
         .          .   1898:		unlock(&sched.lock)
         .          .   1899:		goto top
         .          .   1900:	}
         .          .   1901:	if sched.runqsize != 0 {
         .          .   1902:		gp := globrunqget(_g_.m.p.ptr(), 0)
         .          .   1903:		unlock(&sched.lock)
         .          .   1904:		return gp, false
         .          .   1905:	}
         .          .   1906:	_p_ := releasep()
         .          .   1907:	pidleput(_p_)
         .          .   1908:	unlock(&sched.lock)
         .          .   1909:
         .          .   1910:	// Delicate dance: thread transitions from spinning to non-spinning state,
         .          .   1911:	// potentially concurrently with submission of new goroutines. We must
         .          .   1912:	// drop nmspinning first and then check all per-P queues again (with
         .          .   1913:	// #StoreLoad memory barrier in between). If we do it the other way around,
         .          .   1914:	// another thread can submit a goroutine after we've checked all run queues
         .          .   1915:	// but before we drop nmspinning; as the result nobody will unpark a thread
         .          .   1916:	// to run the goroutine.
         .          .   1917:	// If we discover new work below, we need to restore m.spinning as a signal
         .          .   1918:	// for resetspinning to unpark a new worker thread (because there can be more
         .          .   1919:	// than one starving goroutine). However, if after discovering new work
         .          .   1920:	// we also observe no idle Ps, it is OK to just park the current thread:
         .          .   1921:	// the system is fully loaded so no spinning threads are required.
         .          .   1922:	// Also see "Worker thread parking/unparking" comment at the top of the file.
         .          .   1923:	wasSpinning := _g_.m.spinning
         .          .   1924:	if _g_.m.spinning {
         .          .   1925:		_g_.m.spinning = false
         .          .   1926:		if int32(atomic.Xadd(&sched.nmspinning, -1)) < 0 {
         .          .   1927:			throw("findrunnable: negative nmspinning")
         .          .   1928:		}
         .          .   1929:	}
         .          .   1930:
         .          .   1931:	// check all runqueues once again
         .          .   1932:	for i := 0; i < int(gomaxprocs); i++ {
         .          .   1933:		_p_ := allp[i]
         .          .   1934:		if _p_ != nil && !runqempty(_p_) {
         .          .   1935:			lock(&sched.lock)
         .          .   1936:			_p_ = pidleget()
         .          .   1937:			unlock(&sched.lock)
         .          .   1938:			if _p_ != nil {
         .          .   1939:				acquirep(_p_)
         .          .   1940:				if wasSpinning {
         .          .   1941:					_g_.m.spinning = true
         .          .   1942:					atomic.Xadd(&sched.nmspinning, 1)
         .          .   1943:				}
         .          .   1944:				goto top
         .          .   1945:			}
         .          .   1946:			break
         .          .   1947:		}
         .          .   1948:	}
         .          .   1949:
         .          .   1950:	// poll network
         .          .   1951:	if netpollinited() && atomic.Xchg64(&sched.lastpoll, 0) != 0 {
         .          .   1952:		if _g_.m.p != 0 {
         .          .   1953:			throw("findrunnable: netpoll with p")
         .          .   1954:		}
         .          .   1955:		if _g_.m.spinning {
         .          .   1956:			throw("findrunnable: netpoll with spinning")
         .          .   1957:		}
         .       20ms   1958:		gp := netpoll(true) // block until new work is available
         .          .   1959:		atomic.Store64(&sched.lastpoll, uint64(nanotime()))
         .          .   1960:		if gp != nil {
         .          .   1961:			lock(&sched.lock)
         .          .   1962:			_p_ = pidleget()
         .       10ms   1963:			unlock(&sched.lock)
         .          .   1964:			if _p_ != nil {
         .          .   1965:				acquirep(_p_)
         .          .   1966:				injectglist(gp.schedlink.ptr())
         .          .   1967:				casgstatus(gp, _Gwaiting, _Grunnable)
         .          .   1968:				if trace.enabled {
         .          .   1969:					traceGoUnpark(gp, 0)
         .          .   1970:				}
         .          .   1971:				return gp, false
         .          .   1972:			}
         .          .   1973:			injectglist(gp)
         .          .   1974:		}
         .          .   1975:	}
         .       10ms   1976:	stopm()
         .          .   1977:	goto top
         .          .   1978:}
         .          .   1979:
         .          .   1980:func resetspinning() {
         .          .   1981:	_g_ := getg()
ROUTINE ======================== runtime.flushallmcaches in /home/isucon/.local/go/src/runtime/mstats.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    345:		c := p.mcache
         .          .    346:		if c == nil {
         .          .    347:			continue
         .          .    348:		}
         .          .    349:		c.releaseAll()
         .       10ms    350:		stackcache_clear(c)
         .          .    351:	}
         .          .    352:}
         .          .    353:
         .          .    354://go:nosplit
         .          .    355:func purgecachedstats(c *mcache) {
ROUTINE ======================== runtime.forEachP in /home/isucon/.local/go/src/runtime/proc.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   1177:		for {
         .          .   1178:			// Wait for 100us, then try to re-preempt in
         .          .   1179:			// case of any races.
         .          .   1180:			//
         .          .   1181:			// Requires system stack.
         .       10ms   1182:			if notetsleep(&sched.safePointNote, 100*1000) {
         .          .   1183:				noteclear(&sched.safePointNote)
         .          .   1184:				break
         .          .   1185:			}
         .          .   1186:			preemptall()
         .          .   1187:		}
ROUTINE ======================== runtime.freedefer in /home/isucon/.local/go/src/runtime/panic.go
      80ms       80ms (flat, cum)  0.14% of Total
         .          .    222:		freedeferpanic()
         .          .    223:	}
         .          .    224:	if d.fn != nil {
         .          .    225:		freedeferfn()
         .          .    226:	}
      10ms       10ms    227:	sc := deferclass(uintptr(d.siz))
         .          .    228:	if sc < uintptr(len(p{}.deferpool)) {
      20ms       20ms    229:		mp := acquirem()
         .          .    230:		pp := mp.p.ptr()
      10ms       10ms    231:		if len(pp.deferpool[sc]) == cap(pp.deferpool[sc]) {
         .          .    232:			// Transfer half of local cache to the central cache.
         .          .    233:			var first, last *_defer
         .          .    234:			for len(pp.deferpool[sc]) > cap(pp.deferpool[sc])/2 {
         .          .    235:				n := len(pp.deferpool[sc])
         .          .    236:				d := pp.deferpool[sc][n-1]
         .          .    237:				pp.deferpool[sc][n-1] = nil
         .          .    238:				pp.deferpool[sc] = pp.deferpool[sc][:n-1]
         .          .    239:				if first == nil {
         .          .    240:					first = d
         .          .    241:				} else {
         .          .    242:					last.link = d
         .          .    243:				}
         .          .    244:				last = d
         .          .    245:			}
         .          .    246:			lock(&sched.deferlock)
         .          .    247:			last.link = sched.deferpool[sc]
         .          .    248:			sched.deferpool[sc] = first
         .          .    249:			unlock(&sched.deferlock)
         .          .    250:		}
      20ms       20ms    251:		*d = _defer{}
      20ms       20ms    252:		pp.deferpool[sc] = append(pp.deferpool[sc], d)
         .          .    253:		releasem(mp)
         .          .    254:	}
         .          .    255:}
         .          .    256:
         .          .    257:// Separate function so that it can split stack.
ROUTINE ======================== runtime.funcspdelta in /home/isucon/.local/go/src/runtime/symtab.go
      30ms      300ms (flat, cum)  0.54% of Total
         .          .    358:func funcline(f *_func, targetpc uintptr) (file string, line int32) {
         .          .    359:	return funcline1(f, targetpc, true)
         .          .    360:}
         .          .    361:
         .          .    362:func funcspdelta(f *_func, targetpc uintptr, cache *pcvalueCache) int32 {
      30ms      300ms    363:	x := pcvalue(f, f.pcsp, targetpc, cache, true)
         .          .    364:	if x&(sys.PtrSize-1) != 0 {
         .          .    365:		print("invalid spdelta ", funcname(f), " ", hex(f.entry), " ", hex(targetpc), " ", hex(f.pcsp), " ", x, "\n")
         .          .    366:	}
         .          .    367:	return x
         .          .    368:}
ROUTINE ======================== runtime.futex in /home/isucon/.local/go/src/runtime/sys_linux_amd64.s
     110ms      110ms (flat, cum)   0.2% of Total
         .          .    301:	MOVL	val+12(FP), DX
         .          .    302:	MOVQ	ts+16(FP), R10
         .          .    303:	MOVQ	addr2+24(FP), R8
         .          .    304:	MOVL	val3+32(FP), R9
         .          .    305:	MOVL	$202, AX
      60ms       60ms    306:	SYSCALL
      40ms       40ms    307:	MOVL	AX, ret+40(FP)
      10ms       10ms    308:	RET
         .          .    309:
         .          .    310:// int32 clone(int32 flags, void *stack, M *mp, G *gp, void (*fn)(void));
         .          .    311:TEXT runtime·clone(SB),NOSPLIT,$0
         .          .    312:	MOVL	flags+0(FP), DI
         .          .    313:	MOVQ	stack+8(FP), SI
ROUTINE ======================== runtime.futexsleep in /home/isucon/.local/go/src/runtime/os1_linux.go
         0      110ms (flat, cum)   0.2% of Total
         .          .     35:	// FUTEX_WAIT returns an internal error code
         .          .     36:	// as an errno.  Libpthread ignores the return value
         .          .     37:	// here, and so can we: as it says a few lines up,
         .          .     38:	// spurious wakeups are allowed.
         .          .     39:	if ns < 0 {
         .       90ms     40:		futex(unsafe.Pointer(addr), _FUTEX_WAIT, val, nil, nil, 0)
         .          .     41:		return
         .          .     42:	}
         .          .     43:
         .          .     44:	// It's difficult to live within the no-split stack limits here.
         .          .     45:	// On ARM and 386, a 64-bit divide invokes a general software routine
         .          .     46:	// that needs more stack than we can afford. So we use timediv instead.
         .          .     47:	// But on real 64-bit systems, where words are larger but the stack limit
         .          .     48:	// is not, even timediv is too heavy, and we really need to use just an
         .          .     49:	// ordinary machine instruction.
         .          .     50:	if sys.PtrSize == 8 {
         .          .     51:		ts.set_sec(ns / 1000000000)
         .          .     52:		ts.set_nsec(int32(ns % 1000000000))
         .          .     53:	} else {
         .          .     54:		ts.tv_nsec = 0
         .          .     55:		ts.set_sec(int64(timediv(ns, 1000000000, (*int32)(unsafe.Pointer(&ts.tv_nsec)))))
         .          .     56:	}
         .       20ms     57:	futex(unsafe.Pointer(addr), _FUTEX_WAIT, val, unsafe.Pointer(&ts), nil, 0)
         .          .     58:}
         .          .     59:
         .          .     60:// If any procs are sleeping on addr, wake up at most cnt.
         .          .     61://go:nosplit
         .          .     62:func futexwakeup(addr *uint32, cnt uint32) {
ROUTINE ======================== runtime.gcAssistAlloc in /home/isucon/.local/go/src/runtime/mgcmark.go
         0      3.53s (flat, cum)  6.34% of Total
         .          .    420:		_p_.gcAssistTime += duration
         .          .    421:		if _p_.gcAssistTime > gcAssistTimeSlack {
         .          .    422:			atomic.Xaddint64(&gcController.assistTime, _p_.gcAssistTime)
         .          .    423:			_p_.gcAssistTime = 0
         .          .    424:		}
         .      3.53s    425:	})
         .          .    426:
         .          .    427:	if completed {
         .          .    428:		gcMarkDone()
         .          .    429:	}
         .          .    430:
ROUTINE ======================== runtime.gcAssistAlloc.func1 in /home/isucon/.local/go/src/runtime/mgcmark.go
         0      3.53s (flat, cum)  6.34% of Total
         .          .    383:		}
         .          .    384:
         .          .    385:		// drain own cached work first in the hopes that it
         .          .    386:		// will be more cache friendly.
         .          .    387:		gcw := &getg().m.p.ptr().gcw
         .      3.53s    388:		workDone := gcDrainN(gcw, scanWork)
         .          .    389:		// If we are near the end of the mark phase
         .          .    390:		// dispose of the gcw.
         .          .    391:		if gcBlackenPromptly {
         .          .    392:			gcw.dispose()
         .          .    393:		}
ROUTINE ======================== runtime.gcBgMarkWorker in /home/isucon/.local/go/src/runtime/mgc.go
         0      4.04s (flat, cum)  7.26% of Total
         .          .   1371:
         .          .   1372:	for {
         .          .   1373:		// Go to sleep until woken by gcContoller.findRunnable.
         .          .   1374:		// We can't releasem yet since even the call to gopark
         .          .   1375:		// may be preempted.
         .       10ms   1376:		gopark(func(g *g, parkp unsafe.Pointer) bool {
         .          .   1377:			park := (*parkInfo)(parkp)
         .          .   1378:
         .          .   1379:			// The worker G is no longer running, so it's
         .          .   1380:			// now safe to allow preemption.
         .          .   1381:			releasem(park.m)
         .          .   1382:
         .          .   1383:			// If the worker isn't attached to its P,
         .          .   1384:			// attach now. During initialization and after
         .          .   1385:			// a phase change, the worker may have been
         .          .   1386:			// running on a different P. As soon as we
         .          .   1387:			// attach, the owner P may schedule the
         .          .   1388:			// worker, so this must be done after the G is
         .          .   1389:			// stopped.
         .          .   1390:			if park.attach != nil {
         .          .   1391:				p := park.attach
         .          .   1392:				park.attach = nil
         .          .   1393:				// cas the worker because we may be
         .          .   1394:				// racing with a new worker starting
         .          .   1395:				// on this P.
         .          .   1396:				if !p.gcBgMarkWorker.cas(0, guintptr(unsafe.Pointer(g))) {
         .          .   1397:					// The P got a new worker.
         .          .   1398:					// Exit this worker.
         .          .   1399:					return false
         .          .   1400:				}
         .          .   1401:			}
         .          .   1402:			return true
         .          .   1403:		}, noescape(unsafe.Pointer(&park)), "GC worker (idle)", traceEvGoBlock, 0)
         .          .   1404:
         .          .   1405:		// Loop until the P dies and disassociates this
         .          .   1406:		// worker (the P may later be reused, in which case
         .          .   1407:		// it will get a new worker) or we failed to associate.
         .          .   1408:		if _p_.gcBgMarkWorker.ptr() != gp {
         .          .   1409:			break
         .          .   1410:		}
         .          .   1411:
         .          .   1412:		// Disable preemption so we can use the gcw. If the
         .          .   1413:		// scheduler wants to preempt us, we'll stop draining,
         .          .   1414:		// dispose the gcw, and then preempt.
         .          .   1415:		park.m = acquirem()
         .          .   1416:
         .          .   1417:		if gcBlackenEnabled == 0 {
         .          .   1418:			throw("gcBgMarkWorker: blackening not enabled")
         .          .   1419:		}
         .          .   1420:
         .          .   1421:		startTime := nanotime()
         .          .   1422:
         .          .   1423:		decnwait := atomic.Xadd(&work.nwait, -1)
         .          .   1424:		if decnwait == work.nproc {
         .          .   1425:			println("runtime: work.nwait=", decnwait, "work.nproc=", work.nproc)
         .          .   1426:			throw("work.nwait was > work.nproc")
         .          .   1427:		}
         .          .   1428:
         .          .   1429:		switch _p_.gcMarkWorkerMode {
         .          .   1430:		default:
         .          .   1431:			throw("gcBgMarkWorker: unexpected gcMarkWorkerMode")
         .          .   1432:		case gcMarkWorkerDedicatedMode:
         .          .   1433:			gcDrain(&_p_.gcw, gcDrainNoBlock|gcDrainFlushBgCredit)
         .          .   1434:		case gcMarkWorkerFractionalMode, gcMarkWorkerIdleMode:
         .      3.94s   1435:			gcDrain(&_p_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)
         .          .   1436:		}
         .          .   1437:
         .          .   1438:		// If we are nearing the end of mark, dispose
         .          .   1439:		// of the cache promptly. We must do this
         .          .   1440:		// before signaling that we're no longer
         .          .   1441:		// working so that other workers can't observe
         .          .   1442:		// no workers and no work while we have this
         .          .   1443:		// cached, and before we compute done.
         .          .   1444:		if gcBlackenPromptly {
         .          .   1445:			_p_.gcw.dispose()
         .          .   1446:		}
         .          .   1447:
         .          .   1448:		// Account for time.
         .          .   1449:		duration := nanotime() - startTime
         .          .   1450:		switch _p_.gcMarkWorkerMode {
         .          .   1451:		case gcMarkWorkerDedicatedMode:
         .          .   1452:			atomic.Xaddint64(&gcController.dedicatedMarkTime, duration)
         .          .   1453:			atomic.Xaddint64(&gcController.dedicatedMarkWorkersNeeded, 1)
         .          .   1454:		case gcMarkWorkerFractionalMode:
         .          .   1455:			atomic.Xaddint64(&gcController.fractionalMarkTime, duration)
         .          .   1456:			atomic.Xaddint64(&gcController.fractionalMarkWorkersNeeded, 1)
         .          .   1457:		case gcMarkWorkerIdleMode:
         .          .   1458:			atomic.Xaddint64(&gcController.idleMarkTime, duration)
         .          .   1459:		}
         .          .   1460:
         .          .   1461:		// Was this the last worker and did we run out
         .          .   1462:		// of work?
         .          .   1463:		incnwait := atomic.Xadd(&work.nwait, +1)
         .          .   1464:		if incnwait > work.nproc {
         .          .   1465:			println("runtime: p.gcMarkWorkerMode=", _p_.gcMarkWorkerMode,
         .          .   1466:				"work.nwait=", incnwait, "work.nproc=", work.nproc)
         .          .   1467:			throw("work.nwait > work.nproc")
         .          .   1468:		}
         .          .   1469:
         .          .   1470:		// If this worker reached a background mark completion
         .          .   1471:		// point, signal the main GC goroutine.
         .          .   1472:		if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
         .          .   1473:			// Make this G preemptible and disassociate it
         .          .   1474:			// as the worker for this P so
         .          .   1475:			// findRunnableGCWorker doesn't try to
         .          .   1476:			// schedule it.
         .          .   1477:			_p_.gcBgMarkWorker.set(nil)
         .          .   1478:			releasem(park.m)
         .          .   1479:
         .       90ms   1480:			gcMarkDone()
         .          .   1481:
         .          .   1482:			// Disable preemption and prepare to reattach
         .          .   1483:			// to the P.
         .          .   1484:			//
         .          .   1485:			// We may be running on a different P at this
ROUTINE ======================== runtime.gcDrain in /home/isucon/.local/go/src/runtime/mgcmark.go
      20ms      3.99s (flat, cum)  7.17% of Total
         .          .    807:			job := atomic.Xadd(&work.markrootNext, +1) - 1
         .          .    808:			if job >= work.markrootJobs {
         .          .    809:				break
         .          .    810:			}
         .          .    811:			// TODO: Pass in gcw.
         .      1.11s    812:			markroot(job)
         .          .    813:		}
         .          .    814:	}
         .          .    815:
         .          .    816:	initScanWork := gcw.scanWork
         .          .    817:
         .          .    818:	// Drain heap marking jobs.
         .          .    819:	for !(preemptible && gp.preempt) {
         .          .    820:		// Try to keep work available on the global queue. We used to
         .          .    821:		// check if there were waiting workers, but it's better to
         .          .    822:		// just keep work available than to make workers wait. In the
         .          .    823:		// worst case, we'll do O(log(_WorkbufSize)) unnecessary
         .          .    824:		// balances.
         .          .    825:		if work.full == 0 {
         .          .    826:			gcw.balance()
         .          .    827:		}
         .          .    828:
         .          .    829:		var b uintptr
         .          .    830:		if blocking {
         .          .    831:			b = gcw.get()
         .          .    832:		} else {
      10ms       40ms    833:			b = gcw.tryGet()
         .          .    834:		}
         .          .    835:		if b == 0 {
         .          .    836:			// work barrier reached or tryGet failed.
         .          .    837:			break
         .          .    838:		}
         .      2.83s    839:		scanobject(b, gcw)
         .          .    840:
         .          .    841:		// Flush background scan work credit to the global
         .          .    842:		// account if we've accumulated enough locally so
         .          .    843:		// mutator assists can draw on it.
      10ms       10ms    844:		if gcw.scanWork >= gcCreditSlack {
         .          .    845:			atomic.Xaddint64(&gcController.scanWork, gcw.scanWork)
         .          .    846:			if flushBgCredit {
         .          .    847:				gcFlushBgCredit(gcw.scanWork - initScanWork)
         .          .    848:				initScanWork = 0
         .          .    849:			}
ROUTINE ======================== runtime.gcDrainN in /home/isucon/.local/go/src/runtime/mgcmark.go
      30ms      3.53s (flat, cum)  6.34% of Total
         .          .    880:	// There may already be scan work on the gcw, which we don't
         .          .    881:	// want to claim was done by this call.
         .          .    882:	workFlushed := -gcw.scanWork
         .          .    883:
         .          .    884:	gp := getg().m.curg
      10ms       10ms    885:	for !gp.preempt && workFlushed+gcw.scanWork < scanWork {
         .          .    886:		// See gcDrain comment.
         .          .    887:		if work.full == 0 {
         .          .    888:			gcw.balance()
         .          .    889:		}
         .          .    890:
         .          .    891:		// This might be a good place to add prefetch code...
         .          .    892:		// if(wbuf.nobj > 4) {
         .          .    893:		//         PREFETCH(wbuf->obj[wbuf.nobj - 3];
         .          .    894:		//  }
         .          .    895:		//
         .       40ms    896:		b := gcw.tryGet()
         .          .    897:		if b == 0 {
         .          .    898:			break
         .          .    899:		}
         .      3.46s    900:		scanobject(b, gcw)
         .          .    901:
         .          .    902:		// Flush background scan work credit.
      20ms       20ms    903:		if gcw.scanWork >= gcCreditSlack {
         .          .    904:			atomic.Xaddint64(&gcController.scanWork, gcw.scanWork)
         .          .    905:			workFlushed += gcw.scanWork
         .          .    906:			gcw.scanWork = 0
         .          .    907:		}
         .          .    908:	}
ROUTINE ======================== runtime.gcLockStackBarriers in /home/isucon/.local/go/src/runtime/mstkbar.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .    342://go:nosplit
         .          .    343:func gcLockStackBarriers(gp *g) {
         .          .    344:	// Disable preemption so scanstack cannot run while the caller
         .          .    345:	// is manipulating the stack barriers.
         .          .    346:	acquirem()
      10ms       20ms    347:	for !atomic.Cas(&gp.stackLock, 0, 1) {
         .          .    348:		osyield()
         .          .    349:	}
         .          .    350:}
         .          .    351:
         .          .    352://go:nosplit
ROUTINE ======================== runtime.gcMark in /home/isucon/.local/go/src/runtime/mgc.go
         0       30ms (flat, cum) 0.054% of Total
         .          .   1555:	}
         .          .   1556:
         .          .   1557:	gchelperstart()
         .          .   1558:
         .          .   1559:	var gcw gcWork
         .       20ms   1560:	gcDrain(&gcw, gcDrainBlock)
         .          .   1561:	gcw.dispose()
         .          .   1562:
         .          .   1563:	// TODO: Re-enable once this is cheap.
         .          .   1564:	//gcMarkRootCheck()
         .          .   1565:	if work.full != 0 {
         .          .   1566:		throw("work.full != 0")
         .          .   1567:	}
         .          .   1568:
         .          .   1569:	if work.nproc > 1 {
         .       10ms   1570:		notesleep(&work.alldone)
         .          .   1571:	}
         .          .   1572:
         .          .   1573:	// markroot is done now, so record that objects with
         .          .   1574:	// finalizers have been scanned.
         .          .   1575:	work.finalizersDone = true
ROUTINE ======================== runtime.gcMarkDone in /home/isucon/.local/go/src/runtime/mgc.go
         0       90ms (flat, cum)  0.16% of Total
         .          .   1092:			// start new mark 2 workers that will observe
         .          .   1093:			// the new root marking jobs.
         .          .   1094:			forEachP(func(_p_ *p) {
         .          .   1095:				_p_.gcw.dispose()
         .          .   1096:			})
         .       10ms   1097:		})
         .          .   1098:
         .          .   1099:		// Now we can start up mark 2 workers.
         .          .   1100:		atomic.Xaddint64(&gcController.dedicatedMarkWorkersNeeded, 0xffffffff)
         .          .   1101:		atomic.Xaddint64(&gcController.fractionalMarkWorkersNeeded, 0xffffffff)
         .          .   1102:
         .          .   1103:		incnwait := atomic.Xadd(&work.nwait, +1)
         .          .   1104:		if incnwait == work.nproc && !gcMarkWorkAvailable(nil) {
         .          .   1105:			// This loop will make progress because
         .          .   1106:			// gcBlackenPromptly is now true, so it won't
         .          .   1107:			// take this same "if" branch.
         .          .   1108:			goto top
         .          .   1109:		}
         .          .   1110:	} else {
         .          .   1111:		// Transition to mark termination.
         .          .   1112:		now := nanotime()
         .          .   1113:		work.tMarkTerm = now
         .          .   1114:		work.pauseStart = now
         .          .   1115:		getg().m.preemptoff = "gcing"
         .          .   1116:		systemstack(stopTheWorldWithSema)
         .          .   1117:		// The gcphase is _GCmark, it will transition to _GCmarktermination
         .          .   1118:		// below. The important thing is that the wb remains active until
         .          .   1119:		// all marking is complete. This includes writes made by the GC.
         .          .   1120:
         .          .   1121:		// markroot is done now, so record that objects with
         .          .   1122:		// finalizers have been scanned.
         .          .   1123:		work.finalizersDone = true
         .          .   1124:
         .          .   1125:		// Disable assists and background workers. We must do
         .          .   1126:		// this before waking blocked assists.
         .          .   1127:		atomic.Store(&gcBlackenEnabled, 0)
         .          .   1128:
         .          .   1129:		// Flush the gcWork caches. This must be done before
         .          .   1130:		// endCycle since endCycle depends on statistics kept
         .          .   1131:		// in these caches.
         .          .   1132:		gcFlushGCWork()
         .          .   1133:
         .          .   1134:		// Wake all blocked assists. These will run when we
         .          .   1135:		// start the world again.
         .          .   1136:		gcWakeAllAssists()
         .          .   1137:
         .          .   1138:		// Likewise, release the transition lock. Blocked
         .          .   1139:		// workers and assists will run when we start the
         .          .   1140:		// world again.
         .          .   1141:		semrelease(&work.markDoneSema)
         .          .   1142:
         .          .   1143:		gcController.endCycle()
         .          .   1144:
         .          .   1145:		// Perform mark termination. This will restart the world.
         .       80ms   1146:		gcMarkTermination()
         .          .   1147:	}
         .          .   1148:}
         .          .   1149:
         .          .   1150:func gcMarkTermination() {
         .          .   1151:	// World is stopped.
ROUTINE ======================== runtime.gcMarkDone.func1 in /home/isucon/.local/go/src/runtime/mgc.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   1091:			// workers have exited their loop so we can
         .          .   1092:			// start new mark 2 workers that will observe
         .          .   1093:			// the new root marking jobs.
         .          .   1094:			forEachP(func(_p_ *p) {
         .          .   1095:				_p_.gcw.dispose()
         .       10ms   1096:			})
         .          .   1097:		})
         .          .   1098:
         .          .   1099:		// Now we can start up mark 2 workers.
         .          .   1100:		atomic.Xaddint64(&gcController.dedicatedMarkWorkersNeeded, 0xffffffff)
         .          .   1101:		atomic.Xaddint64(&gcController.fractionalMarkWorkersNeeded, 0xffffffff)
ROUTINE ======================== runtime.gcMarkTermination in /home/isucon/.local/go/src/runtime/mgc.go
         0       80ms (flat, cum)  0.14% of Total
         .          .   1177:		// during gcMark (it shrinks stacks, including the
         .          .   1178:		// outer function's stack), so we must not refer
         .          .   1179:		// to any of its variables. Return back to the
         .          .   1180:		// non-system stack to pick up the new addresses
         .          .   1181:		// before continuing.
         .       60ms   1182:	})
         .          .   1183:
         .          .   1184:	systemstack(func() {
         .          .   1185:		work.heap2 = work.bytesMarked
         .          .   1186:		if debug.gccheckmark > 0 {
         .          .   1187:			// Run a full stop-the-world mark using checkmark bits,
         .          .   1188:			// to check that we didn't forget to mark anything during
         .          .   1189:			// the concurrent mark process.
         .          .   1190:			gcResetMarkState()
         .          .   1191:			initCheckmarks()
         .          .   1192:			gcMark(startTime)
         .          .   1193:			clearCheckmarks()
         .          .   1194:		}
         .          .   1195:
         .          .   1196:		// marking is complete so we can turn the write barrier off
         .          .   1197:		setGCPhase(_GCoff)
         .          .   1198:		gcSweep(work.mode)
         .          .   1199:
         .          .   1200:		if debug.gctrace > 1 {
         .          .   1201:			startTime = nanotime()
         .          .   1202:			// The g stacks have been scanned so
         .          .   1203:			// they have gcscanvalid==true and gcworkdone==true.
         .          .   1204:			// Reset these so that all stacks will be rescanned.
         .          .   1205:			gcResetMarkState()
         .          .   1206:			finishsweep_m(true)
         .          .   1207:
         .          .   1208:			// Still in STW but gcphase is _GCoff, reset to _GCmarktermination
         .          .   1209:			// At this point all objects will be found during the gcMark which
         .          .   1210:			// does a complete STW mark and object scan.
         .          .   1211:			setGCPhase(_GCmarktermination)
         .          .   1212:			gcMark(startTime)
         .          .   1213:			setGCPhase(_GCoff) // marking is done, turn off wb.
         .          .   1214:			gcSweep(work.mode)
         .          .   1215:		}
         .       20ms   1216:	})
         .          .   1217:
         .          .   1218:	_g_.m.traceback = 0
         .          .   1219:	casgstatus(gp, _Gwaiting, _Grunning)
         .          .   1220:
         .          .   1221:	if trace.enabled {
ROUTINE ======================== runtime.gcMarkTermination.func1 in /home/isucon/.local/go/src/runtime/mgc.go
         0       30ms (flat, cum) 0.054% of Total
         .          .   1169:	// we're currently running on will no longer change.  Cuts
         .          .   1170:	// the root set down a bit (g0 stacks are not scanned, and
         .          .   1171:	// we don't need to scan gc's internal state).  We also
         .          .   1172:	// need to switch to g0 so we can shrink the stack.
         .          .   1173:	systemstack(func() {
         .       30ms   1174:		gcMark(startTime)
         .          .   1175:		// Must return immediately.
         .          .   1176:		// The outer function's stack may have moved
         .          .   1177:		// during gcMark (it shrinks stacks, including the
         .          .   1178:		// outer function's stack), so we must not refer
         .          .   1179:		// to any of its variables. Return back to the
ROUTINE ======================== runtime.gcMarkTermination.func2 in /home/isucon/.local/go/src/runtime/mgc.go
         0       20ms (flat, cum) 0.036% of Total
         .          .   1193:			clearCheckmarks()
         .          .   1194:		}
         .          .   1195:
         .          .   1196:		// marking is complete so we can turn the write barrier off
         .          .   1197:		setGCPhase(_GCoff)
         .       20ms   1198:		gcSweep(work.mode)
         .          .   1199:
         .          .   1200:		if debug.gctrace > 1 {
         .          .   1201:			startTime = nanotime()
         .          .   1202:			// The g stacks have been scanned so
         .          .   1203:			// they have gcscanvalid==true and gcworkdone==true.
ROUTINE ======================== runtime.gcSweep in /home/isucon/.local/go/src/runtime/mgc.go
         0       20ms (flat, cum) 0.036% of Total
         .          .   1700:	if sweep.parked {
         .          .   1701:		sweep.parked = false
         .          .   1702:		ready(sweep.g, 0)
         .          .   1703:	}
         .          .   1704:	unlock(&sweep.lock)
         .       20ms   1705:	mProf_GC()
         .          .   1706:}
         .          .   1707:
         .          .   1708:func gcCopySpans() {
         .          .   1709:	// Cache runtime.mheap_.allspans in work.spans to avoid conflicts with
         .          .   1710:	// resizing/freeing allspans.
ROUTINE ======================== runtime.gcUnlockStackBarriers in /home/isucon/.local/go/src/runtime/mstkbar.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    360:}
         .          .    361:
         .          .    362:func gcUnlockStackBarriers(gp *g) {
         .          .    363:	atomic.Store(&gp.stackLock, 0)
         .          .    364:	releasem(getg().m)
      10ms       10ms    365:}
ROUTINE ======================== runtime.gcUnwindBarriers in /home/isucon/.local/go/src/runtime/mstkbar.go
      20ms       50ms (flat, cum)  0.09% of Total
         .          .    291://
         .          .    292:// This is nosplit to ensure gp's stack does not move.
         .          .    293://
         .          .    294://go:nosplit
         .          .    295:func gcUnwindBarriers(gp *g, sp uintptr) {
         .       20ms    296:	gcLockStackBarriers(gp)
         .          .    297:	// On LR machines, if there is a stack barrier on the return
         .          .    298:	// from the frame containing sp, this will mark it as hit even
         .          .    299:	// though it isn't, but it's okay to be conservative.
         .          .    300:	before := gp.stkbarPos
         .          .    301:	for int(gp.stkbarPos) < len(gp.stkbar) && gp.stkbar[gp.stkbarPos].savedLRPtr < sp {
         .          .    302:		gcRemoveStackBarrier(gp, gp.stkbar[gp.stkbarPos])
         .          .    303:		gp.stkbarPos++
         .          .    304:	}
         .       10ms    305:	gcUnlockStackBarriers(gp)
         .          .    306:	if debugStackBarrier && gp.stkbarPos != before {
         .          .    307:		print("skip barriers below ", hex(sp), " in goid=", gp.goid, ": ")
         .          .    308:		// We skipped barriers between the "==>" marker
         .          .    309:		// (before) and the "@@@" marker (gp.stkbarPos).
         .          .    310:		gcPrintStkbars(gp, int(before))
         .          .    311:		print("\n")
         .          .    312:	}
      20ms       20ms    313:}
         .          .    314:
         .          .    315:// nextBarrierPC returns the original return PC of the next stack barrier.
         .          .    316:// Used by getcallerpc, so it must be nosplit.
         .          .    317://go:nosplit
         .          .    318:func nextBarrierPC() uintptr {
ROUTINE ======================== runtime.gchelper in /home/isucon/.local/go/src/runtime/mgc.go
         0       30ms (flat, cum) 0.054% of Total
         .          .   1801:	}
         .          .   1802:
         .          .   1803:	// Parallel mark over GC roots and heap
         .          .   1804:	if gcphase == _GCmarktermination {
         .          .   1805:		var gcw gcWork
         .       30ms   1806:		gcDrain(&gcw, gcDrainBlock) // blocks in getfull
         .          .   1807:		gcw.dispose()
         .          .   1808:	}
         .          .   1809:
         .          .   1810:	if trace.enabled {
         .          .   1811:		traceGCScanDone()
ROUTINE ======================== runtime.gcmarknewobject_m in /home/isucon/.local/go/src/runtime/mgcmark.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   1135://go:nowritebarrier
         .          .   1136:func gcmarknewobject_m(obj, size uintptr) {
         .          .   1137:	if useCheckmark && !gcBlackenPromptly { // The world should be stopped so this should not happen.
         .          .   1138:		throw("gcmarknewobject called while doing checkmark")
         .          .   1139:	}
         .       10ms   1140:	heapBitsForAddr(obj).setMarked()
         .          .   1141:	atomic.Xadd64(&work.bytesMarked, int64(size))
         .          .   1142:}
         .          .   1143:
         .          .   1144:// Checkmarking
         .          .   1145:
ROUTINE ======================== runtime.gcmarkwb_m in /home/isucon/.local/go/src/runtime/mbarrier.go
     190ms      590ms (flat, cum)  1.06% of Total
         .          .     86:// into to the stack. Don't do it! Mark termination only re-scans
         .          .     87:// frames that have potentially been active since the concurrent scan,
         .          .     88:// so it depends on write barriers to track changes to pointers in
         .          .     89:// stack frames that have not been active.
         .          .     90://go:nowritebarrierrec
      50ms       50ms     91:func gcmarkwb_m(slot *uintptr, ptr uintptr) {
      10ms       10ms     92:	if writeBarrier.needed {
     120ms      120ms     93:		if ptr != 0 && inheap(ptr) {
         .      400ms     94:			shade(ptr)
         .          .     95:		}
         .          .     96:	}
      10ms       10ms     97:}
         .          .     98:
         .          .     99:// Write barrier calls must not happen during critical GC and scheduler
         .          .    100:// related operations. In particular there are times when the GC assumes
         .          .    101:// that the world is stopped but scheduler related code is still being
         .          .    102:// executed, dealing with syscalls, dealing with putting gs on runnable
ROUTINE ======================== runtime.gcstopm in /home/isucon/.local/go/src/runtime/proc.go
         0       30ms (flat, cum) 0.054% of Total
         .          .   1737:	sched.stopwait--
         .          .   1738:	if sched.stopwait == 0 {
         .          .   1739:		notewakeup(&sched.stopnote)
         .          .   1740:	}
         .          .   1741:	unlock(&sched.lock)
         .       30ms   1742:	stopm()
         .          .   1743:}
         .          .   1744:
         .          .   1745:// Schedules gp to run on the current M.
         .          .   1746:// If inheritTime is true, gp inherits the remaining time in the
         .          .   1747:// current time slice. Otherwise, it starts a new time slice.
ROUTINE ======================== runtime.gentraceback in /home/isucon/.local/go/src/runtime/traceback.go
     100ms      820ms (flat, cum)  1.47% of Total
         .          .    172:	}
         .          .    173:	waspanic := false
         .          .    174:	printing := pcbuf == nil && callback == nil
         .          .    175:	_defer := gp._defer
         .          .    176:
      10ms       10ms    177:	for _defer != nil && uintptr(_defer.sp) == _NoArgs {
         .          .    178:		_defer = _defer.link
         .          .    179:	}
         .          .    180:
         .          .    181:	// If the PC is zero, it's likely a nil function call.
         .          .    182:	// Start in the caller's frame.
         .          .    183:	if frame.pc == 0 {
         .          .    184:		if usesLR {
         .          .    185:			frame.pc = *(*uintptr)(unsafe.Pointer(frame.sp))
         .          .    186:			frame.lr = 0
         .          .    187:		} else {
         .          .    188:			frame.pc = uintptr(*(*sys.Uintreg)(unsafe.Pointer(frame.sp)))
         .          .    189:			frame.sp += sys.RegSize
         .          .    190:		}
         .          .    191:	}
         .          .    192:
         .       10ms    193:	f := findfunc(frame.pc)
      10ms       10ms    194:	if f != nil && f.entry == stackBarrierPC {
         .          .    195:		// We got caught in the middle of a stack barrier
         .          .    196:		// (presumably by a signal), so stkbar may be
         .          .    197:		// inconsistent with the barriers on the stack.
         .          .    198:		// Simulate the completion of the barrier.
         .          .    199:		//
         .          .    200:		// On x86, SP will be exactly one word above
         .          .    201:		// savedLRPtr. On LR machines, SP will be above
         .          .    202:		// savedLRPtr by some frame size.
         .          .    203:		var stkbarPos uintptr
         .          .    204:		if len(stkbar) > 0 && stkbar[0].savedLRPtr < sp0 {
         .          .    205:			// stackBarrier has not incremented stkbarPos.
         .          .    206:			stkbarPos = gp.stkbarPos
         .          .    207:		} else if gp.stkbarPos > 0 && gp.stkbar[gp.stkbarPos-1].savedLRPtr < sp0 {
         .          .    208:			// stackBarrier has incremented stkbarPos.
         .          .    209:			stkbarPos = gp.stkbarPos - 1
         .          .    210:		} else {
         .          .    211:			printlock()
         .          .    212:			print("runtime: failed to unwind through stackBarrier at SP ", hex(sp0), "; ")
         .          .    213:			gcPrintStkbars(gp, int(gp.stkbarPos))
         .          .    214:			print("\n")
         .          .    215:			throw("inconsistent state in stackBarrier")
         .          .    216:		}
         .          .    217:
         .          .    218:		frame.pc = gp.stkbar[stkbarPos].savedLRVal
         .          .    219:		stkbar = gp.stkbar[stkbarPos+1:]
         .          .    220:		f = findfunc(frame.pc)
         .          .    221:	}
         .          .    222:	if f == nil {
         .          .    223:		if callback != nil {
         .          .    224:			print("runtime: unknown pc ", hex(frame.pc), "\n")
         .          .    225:			throw("unknown pc")
         .          .    226:		}
         .          .    227:		return 0
         .          .    228:	}
         .          .    229:	frame.fn = f
         .          .    230:
         .          .    231:	var cache pcvalueCache
         .          .    232:
         .          .    233:	n := 0
         .          .    234:	for n < max {
         .          .    235:		// Typically:
         .          .    236:		//	pc is the PC of the running function.
         .          .    237:		//	sp is the stack pointer at that program counter.
         .          .    238:		//	fp is the frame pointer (caller's stack pointer) at that program counter, or nil if unknown.
         .          .    239:		//	stk is the stack containing sp.
         .          .    240:		//	The caller's program counter is lr, unless lr is zero, in which case it is *(uintptr*)sp.
         .          .    241:		f = frame.fn
         .          .    242:
         .          .    243:		// Found an actual function.
         .          .    244:		// Derive frame pointer and link register.
         .          .    245:		if frame.fp == 0 {
         .          .    246:			// We want to jump over the systemstack switch. If we're running on the
         .          .    247:			// g0, this systemstack is at the top of the stack.
         .          .    248:			// if we're not on g0 or there's a no curg, then this is a regular call.
         .          .    249:			sp := frame.sp
         .          .    250:			if flags&_TraceJumpStack != 0 && f.entry == systemstackPC && gp == g.m.g0 && gp.m.curg != nil {
         .          .    251:				sp = gp.m.curg.sched.sp
         .          .    252:				stkbarG = gp.m.curg
         .          .    253:				stkbar = stkbarG.stkbar[stkbarG.stkbarPos:]
         .          .    254:			}
      10ms      310ms    255:			frame.fp = sp + uintptr(funcspdelta(f, frame.pc, &cache))
         .          .    256:			if !usesLR {
         .          .    257:				// On x86, call instruction pushes return PC before entering new function.
      10ms       10ms    258:				frame.fp += sys.RegSize
         .          .    259:			}
         .          .    260:		}
         .          .    261:		var flr *_func
         .          .    262:		if topofstack(f) {
         .          .    263:			frame.lr = 0
         .          .    264:			flr = nil
         .          .    265:		} else if usesLR && f.entry == jmpdeferPC {
         .          .    266:			// jmpdefer modifies SP/LR/PC non-atomically.
         .          .    267:			// If a profiling interrupt arrives during jmpdefer,
         .          .    268:			// the stack unwind may see a mismatched register set
         .          .    269:			// and get confused. Stop if we see PC within jmpdefer
         .          .    270:			// to avoid that confusion.
         .          .    271:			// See golang.org/issue/8153.
         .          .    272:			if callback != nil {
         .          .    273:				throw("traceback_arm: found jmpdefer when tracing with callback")
         .          .    274:			}
         .          .    275:			frame.lr = 0
         .          .    276:		} else {
         .          .    277:			var lrPtr uintptr
         .          .    278:			if usesLR {
         .          .    279:				if n == 0 && frame.sp < frame.fp || frame.lr == 0 {
         .          .    280:					lrPtr = frame.sp
         .          .    281:					frame.lr = *(*uintptr)(unsafe.Pointer(lrPtr))
         .          .    282:				}
         .          .    283:			} else {
         .          .    284:				if frame.lr == 0 {
         .          .    285:					lrPtr = frame.fp - sys.RegSize
      20ms       20ms    286:					frame.lr = uintptr(*(*sys.Uintreg)(unsafe.Pointer(lrPtr)))
         .          .    287:				}
         .          .    288:			}
         .          .    289:			if frame.lr == stackBarrierPC {
         .          .    290:				// Recover original PC.
         .          .    291:				if len(stkbar) == 0 || stkbar[0].savedLRPtr != lrPtr {
         .          .    292:					print("found next stack barrier at ", hex(lrPtr), "; expected ")
         .          .    293:					gcPrintStkbars(stkbarG, len(stkbarG.stkbar)-len(stkbar))
         .          .    294:					print("\n")
         .          .    295:					throw("missed stack barrier")
         .          .    296:				}
         .          .    297:				frame.lr = stkbar[0].savedLRVal
         .          .    298:				stkbar = stkbar[1:]
         .          .    299:			}
         .       50ms    300:			flr = findfunc(frame.lr)
         .          .    301:			if flr == nil {
         .          .    302:				// This happens if you get a profiling interrupt at just the wrong time.
         .          .    303:				// In that context it is okay to stop early.
         .          .    304:				// But if callback is set, we're doing a garbage collection and must
         .          .    305:				// get everything, so crash loudly.
         .          .    306:				if callback != nil {
         .          .    307:					print("runtime: unexpected return pc for ", funcname(f), " called from ", hex(frame.lr), "\n")
         .          .    308:					throw("unknown caller pc")
         .          .    309:				}
         .          .    310:			}
         .          .    311:		}
         .          .    312:
      10ms       10ms    313:		frame.varp = frame.fp
         .          .    314:		if !usesLR {
         .          .    315:			// On x86, call instruction pushes return PC before entering new function.
         .          .    316:			frame.varp -= sys.RegSize
         .          .    317:		}
         .          .    318:
         .          .    319:		// If framepointer_enabled and there's a frame, then
         .          .    320:		// there's a saved bp here.
         .          .    321:		if framepointer_enabled && GOARCH == "amd64" && frame.varp > frame.sp {
         .          .    322:			frame.varp -= sys.RegSize
         .          .    323:		}
         .          .    324:
         .          .    325:		// Derive size of arguments.
         .          .    326:		// Most functions have a fixed-size argument block,
         .          .    327:		// so we can use metadata about the function f.
         .          .    328:		// Not all, though: there are some variadic functions
         .          .    329:		// in package runtime and reflect, and for those we use call-specific
         .          .    330:		// metadata recorded by f's caller.
         .          .    331:		if callback != nil || printing {
         .          .    332:			frame.argp = frame.fp + sys.MinFrameSize
      10ms       10ms    333:			frame.arglen, frame.argmap = getArgInfo(&frame, f, callback != nil)
         .          .    334:		}
         .          .    335:
         .          .    336:		// Determine frame's 'continuation PC', where it can continue.
         .          .    337:		// Normally this is the return address on the stack, but if sigpanic
         .          .    338:		// is immediately below this function on the stack, then the frame
         .          .    339:		// stopped executing due to a trap, and frame.pc is probably not
         .          .    340:		// a safe point for looking up liveness information. In this panicking case,
         .          .    341:		// the function either doesn't return at all (if it has no defers or if the
         .          .    342:		// defers do not recover) or it returns from one of the calls to
         .          .    343:		// deferproc a second time (if the corresponding deferred func recovers).
         .          .    344:		// It suffices to assume that the most recent deferproc is the one that
         .          .    345:		// returns; everything live at earlier deferprocs is still live at that one.
         .          .    346:		frame.continpc = frame.pc
         .          .    347:		if waspanic {
         .          .    348:			if _defer != nil && _defer.sp == frame.sp {
         .          .    349:				frame.continpc = _defer.pc
         .          .    350:			} else {
         .          .    351:				frame.continpc = 0
         .          .    352:			}
         .          .    353:		}
         .          .    354:
         .          .    355:		// Unwind our local defer stack past this frame.
         .          .    356:		for _defer != nil && (_defer.sp == frame.sp || _defer.sp == _NoArgs) {
      10ms       10ms    357:			_defer = _defer.link
         .          .    358:		}
         .          .    359:
         .          .    360:		if skip > 0 {
         .          .    361:			skip--
         .          .    362:			goto skipped
         .          .    363:		}
         .          .    364:
         .          .    365:		if pcbuf != nil {
         .          .    366:			(*[1 << 20]uintptr)(unsafe.Pointer(pcbuf))[n] = frame.pc
         .          .    367:		}
         .          .    368:		if callback != nil {
         .      360ms    369:			if !callback((*stkframe)(noescape(unsafe.Pointer(&frame))), v) {
         .          .    370:				return n
         .          .    371:			}
         .          .    372:		}
         .          .    373:		if printing {
         .          .    374:			if (flags&_TraceRuntimeFrames) != 0 || showframe(f, gp) {
         .          .    375:				// Print during crash.
         .          .    376:				//	main(0x1, 0x2, 0x3)
         .          .    377:				//		/home/rsc/go/src/runtime/x.go:23 +0xf
         .          .    378:				//
         .          .    379:				tracepc := frame.pc // back up to CALL instruction for funcline.
         .          .    380:				if (n > 0 || flags&_TraceTrap == 0) && frame.pc > f.entry && !waspanic {
         .          .    381:					tracepc--
         .          .    382:				}
         .          .    383:				name := funcname(f)
         .          .    384:				if name == "runtime.gopanic" {
         .          .    385:					name = "panic"
         .          .    386:				}
         .          .    387:				print(name, "(")
         .          .    388:				argp := (*[100]uintptr)(unsafe.Pointer(frame.argp))
         .          .    389:				for i := uintptr(0); i < frame.arglen/sys.PtrSize; i++ {
         .          .    390:					if i >= 10 {
         .          .    391:						print(", ...")
         .          .    392:						break
         .          .    393:					}
         .          .    394:					if i != 0 {
         .          .    395:						print(", ")
         .          .    396:					}
         .          .    397:					print(hex(argp[i]))
         .          .    398:				}
         .          .    399:				print(")\n")
         .          .    400:				file, line := funcline(f, tracepc)
         .          .    401:				print("\t", file, ":", line)
         .          .    402:				if frame.pc > f.entry {
         .          .    403:					print(" +", hex(frame.pc-f.entry))
         .          .    404:				}
         .          .    405:				if g.m.throwing > 0 && gp == g.m.curg || level >= 2 {
         .          .    406:					print(" fp=", hex(frame.fp), " sp=", hex(frame.sp))
         .          .    407:				}
         .          .    408:				print("\n")
         .          .    409:				nprint++
         .          .    410:			}
         .          .    411:		}
         .          .    412:		n++
         .          .    413:
         .          .    414:	skipped:
         .          .    415:		waspanic = f.entry == sigpanicPC
         .          .    416:
         .          .    417:		// Do not unwind past the bottom of the stack.
         .          .    418:		if flr == nil {
         .          .    419:			break
         .          .    420:		}
         .          .    421:
         .          .    422:		// Unwind to next frame.
         .          .    423:		frame.fn = flr
         .          .    424:		frame.pc = frame.lr
         .          .    425:		frame.lr = 0
      10ms       10ms    426:		frame.sp = frame.fp
         .          .    427:		frame.fp = 0
         .          .    428:		frame.argmap = nil
         .          .    429:
         .          .    430:		// On link register architectures, sighandler saves the LR on stack
         .          .    431:		// before faking a call to sigpanic.
ROUTINE ======================== runtime.getcallersp in /home/isucon/.local/go/src/runtime/asm_amd64.s
      40ms       40ms (flat, cum) 0.072% of Total
         .          .    813:	CALL	runtime·setNextBarrierPC(SB)
         .          .    814:	RET
         .          .    815:
         .          .    816:TEXT runtime·getcallersp(SB),NOSPLIT,$0-16
         .          .    817:	MOVQ	argp+0(FP), AX
      20ms       20ms    818:	MOVQ	AX, ret+8(FP)
      20ms       20ms    819:	RET
         .          .    820:
         .          .    821:// func cputicks() int64
         .          .    822:TEXT runtime·cputicks(SB),NOSPLIT,$0-0
         .          .    823:	CMPB	runtime·lfenceBeforeRdtsc(SB), $1
         .          .    824:	JNE	mfence
ROUTINE ======================== runtime.getitab in /home/isucon/.local/go/src/runtime/iface.go
     360ms      420ms (flat, cum)  0.75% of Total
         .          .     17:var (
         .          .     18:	ifaceLock mutex // lock for accessing hash
         .          .     19:	hash      [hashSize]*itab
         .          .     20:)
         .          .     21:
      40ms       40ms     22:func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
      70ms       70ms     23:	if len(inter.mhdr) == 0 {
         .          .     24:		throw("internal error - misuse of itab")
         .          .     25:	}
         .          .     26:
         .          .     27:	// easy case
      30ms       30ms     28:	x := typ.x
         .          .     29:	if x == nil {
         .          .     30:		if canfail {
      10ms       10ms     31:			return nil
         .          .     32:		}
         .          .     33:		panic(&TypeAssertionError{"", *typ._string, *inter.typ._string, *inter.mhdr[0].name})
         .          .     34:	}
         .          .     35:
         .          .     36:	// compiler has provided some good hash codes for us.
         .          .     37:	h := inter.typ.hash
      10ms       10ms     38:	h += 17 * typ.hash
         .          .     39:	// TODO(rsc): h += 23 * x.mhash ?
      50ms       50ms     40:	h %= hashSize
         .          .     41:
         .          .     42:	// look twice - once without lock, once with.
         .          .     43:	// common case will be no lock contention.
         .          .     44:	var m *itab
         .          .     45:	var locked int
         .          .     46:	for locked = 0; locked < 2; locked++ {
         .          .     47:		if locked != 0 {
         .          .     48:			lock(&ifaceLock)
         .          .     49:		}
      50ms      110ms     50:		for m = (*itab)(atomic.Loadp(unsafe.Pointer(&hash[h]))); m != nil; m = m.link {
      90ms       90ms     51:			if m.inter == inter && m._type == typ {
         .          .     52:				if m.bad != 0 {
         .          .     53:					m = nil
         .          .     54:					if !canfail {
         .          .     55:						// this can only happen if the conversion
         .          .     56:						// was already done once using the , ok form
         .          .     57:						// and we have a cached negative result.
         .          .     58:						// the cached result doesn't record which
         .          .     59:						// interface function was missing, so jump
         .          .     60:						// down to the interface check, which will
         .          .     61:						// do more work but give a better error.
         .          .     62:						goto search
         .          .     63:					}
         .          .     64:				}
         .          .     65:				if locked != 0 {
         .          .     66:					unlock(&ifaceLock)
         .          .     67:				}
      10ms       10ms     68:				return m
         .          .     69:			}
         .          .     70:		}
         .          .     71:	}
         .          .     72:
         .          .     73:	m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, &memstats.other_sys))
ROUTINE ======================== runtime.gfput in /home/isucon/.local/go/src/runtime/proc.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   2762:
         .          .   2763:	stksize := gp.stackAlloc
         .          .   2764:
         .          .   2765:	if stksize != _FixedStack {
         .          .   2766:		// non-standard stack size - free it.
         .       10ms   2767:		stackfree(gp.stack, gp.stackAlloc)
         .          .   2768:		gp.stack.lo = 0
         .          .   2769:		gp.stack.hi = 0
         .          .   2770:		gp.stackguard0 = 0
         .          .   2771:		gp.stkbar = nil
         .          .   2772:		gp.stkbarPos = 0
ROUTINE ======================== runtime.goexit in /home/isucon/.local/go/src/runtime/asm_amd64.s
         0     54.44s (flat, cum) 97.83% of Total
         .          .   1993:	RET
         .          .   1994:
         .          .   1995:// The top-most function running on a goroutine
         .          .   1996:// returns to goexit+PCQuantum.
         .          .   1997:TEXT runtime·goexit(SB),NOSPLIT,$0-0
         .     54.44s   1998:	BYTE	$0x90	// NOP
         .          .   1999:	CALL	runtime·goexit1(SB)	// does not return
         .          .   2000:	// traceback from goexit1 must hit code range of goexit
         .          .   2001:	BYTE	$0x90	// NOP
         .          .   2002:
         .          .   2003:TEXT runtime·prefetcht0(SB),NOSPLIT,$0-8
ROUTINE ======================== runtime.goexit0 in /home/isucon/.local/go/src/runtime/proc.go
         0       30ms (flat, cum) 0.054% of Total
         .          .   2204:	if _g_.m.locked&^_LockExternal != 0 {
         .          .   2205:		print("invalid m->locked = ", _g_.m.locked, "\n")
         .          .   2206:		throw("internal lockOSThread error")
         .          .   2207:	}
         .          .   2208:	_g_.m.locked = 0
         .       10ms   2209:	gfput(_g_.m.p.ptr(), gp)
         .       20ms   2210:	schedule()
         .          .   2211:}
         .          .   2212:
         .          .   2213://go:nosplit
         .          .   2214://go:nowritebarrier
         .          .   2215:func save(pc, sp uintptr) {
ROUTINE ======================== runtime.gopark in /home/isucon/.local/go/src/runtime/proc.go
      20ms       30ms (flat, cum) 0.054% of Total
         .          .    243:	mcall(gosched_m)
         .          .    244:}
         .          .    245:
         .          .    246:// Puts the current goroutine into a waiting state and calls unlockf.
         .          .    247:// If unlockf returns false, the goroutine is resumed.
      10ms       10ms    248:func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason string, traceEv byte, traceskip int) {
      10ms       10ms    249:	mp := acquirem()
         .          .    250:	gp := mp.curg
         .       10ms    251:	status := readgstatus(gp)
         .          .    252:	if status != _Grunning && status != _Gscanrunning {
         .          .    253:		throw("gopark: bad g status")
         .          .    254:	}
         .          .    255:	mp.waitlock = lock
         .          .    256:	mp.waitunlockf = *(*unsafe.Pointer)(unsafe.Pointer(&unlockf))
ROUTINE ======================== runtime.goparkunlock in /home/isucon/.local/go/src/runtime/proc.go
      10ms       30ms (flat, cum) 0.054% of Total
         .          .    263:}
         .          .    264:
         .          .    265:// Puts the current goroutine into a waiting state and unlocks the lock.
         .          .    266:// The goroutine can be made runnable again by calling goready(gp).
         .          .    267:func goparkunlock(lock *mutex, reason string, traceEv byte, traceskip int) {
         .       20ms    268:	gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)
      10ms       10ms    269:}
         .          .    270:
         .          .    271:func goready(gp *g, traceskip int) {
         .          .    272:	systemstack(func() {
         .          .    273:		ready(gp, traceskip)
         .          .    274:	})
ROUTINE ======================== runtime.gopreempt_m in /home/isucon/.local/go/src/runtime/proc.go
         0       30ms (flat, cum) 0.054% of Total
         .          .   2165:
         .          .   2166:func gopreempt_m(gp *g) {
         .          .   2167:	if trace.enabled {
         .          .   2168:		traceGoPreempt()
         .          .   2169:	}
         .       30ms   2170:	goschedImpl(gp)
         .          .   2171:}
         .          .   2172:
         .          .   2173:// Finishes execution of the current goroutine.
         .          .   2174:func goexit1() {
         .          .   2175:	if raceenabled {
ROUTINE ======================== runtime.goschedImpl in /home/isucon/.local/go/src/runtime/proc.go
         0       80ms (flat, cum)  0.14% of Total
         .          .   2146:		dumpgstatus(gp)
         .          .   2147:		throw("bad g status")
         .          .   2148:	}
         .          .   2149:	casgstatus(gp, _Grunning, _Grunnable)
         .          .   2150:	dropg()
         .       20ms   2151:	lock(&sched.lock)
         .          .   2152:	globrunqput(gp)
         .          .   2153:	unlock(&sched.lock)
         .          .   2154:
         .       60ms   2155:	schedule()
         .          .   2156:}
         .          .   2157:
         .          .   2158:// Gosched continuation on g0.
         .          .   2159:func gosched_m(gp *g) {
         .          .   2160:	if trace.enabled {
ROUTINE ======================== runtime.gosched_m in /home/isucon/.local/go/src/runtime/proc.go
         0       50ms (flat, cum)  0.09% of Total
         .          .   2158:// Gosched continuation on g0.
         .          .   2159:func gosched_m(gp *g) {
         .          .   2160:	if trace.enabled {
         .          .   2161:		traceGoSched()
         .          .   2162:	}
         .       50ms   2163:	goschedImpl(gp)
         .          .   2164:}
         .          .   2165:
         .          .   2166:func gopreempt_m(gp *g) {
         .          .   2167:	if trace.enabled {
         .          .   2168:		traceGoPreempt()
ROUTINE ======================== runtime.gosweepone in /home/isucon/.local/go/src/runtime/mgcsweep.go
      30ms      2.16s (flat, cum)  3.88% of Total
         .          .    116:		return npages
         .          .    117:	}
         .          .    118:}
         .          .    119:
         .          .    120://go:nowritebarrier
      20ms       20ms    121:func gosweepone() uintptr {
         .          .    122:	var ret uintptr
         .          .    123:	systemstack(func() {
         .          .    124:		ret = sweepone()
         .      2.13s    125:	})
      10ms       10ms    126:	return ret
         .          .    127:}
         .          .    128:
         .          .    129://go:nowritebarrier
         .          .    130:func gosweepdone() bool {
         .          .    131:	return mheap_.sweepdone != 0
ROUTINE ======================== runtime.gosweepone.func1 in /home/isucon/.local/go/src/runtime/mgcsweep.go
         0      2.38s (flat, cum)  4.28% of Total
         .          .    119:
         .          .    120://go:nowritebarrier
         .          .    121:func gosweepone() uintptr {
         .          .    122:	var ret uintptr
         .          .    123:	systemstack(func() {
         .      2.38s    124:		ret = sweepone()
         .          .    125:	})
         .          .    126:	return ret
         .          .    127:}
         .          .    128:
         .          .    129://go:nowritebarrier
ROUTINE ======================== runtime.greyobject in /home/isucon/.local/go/src/runtime/mgcmark.go
     560ms      1.04s (flat, cum)  1.87% of Total
         .          .   1036:
         .          .   1037:// obj is the start of an object with mark mbits.
         .          .   1038:// If it isn't already marked, mark it and enqueue into gcw.
         .          .   1039:// base and off are for debugging only and could be removed.
         .          .   1040://go:nowritebarrierrec
      60ms       60ms   1041:func greyobject(obj, base, off uintptr, hbits heapBits, span *mspan, gcw *gcWork) {
         .          .   1042:	// obj should be start of allocation, and so must be at least pointer-aligned.
      10ms       10ms   1043:	if obj&(sys.PtrSize-1) != 0 {
         .          .   1044:		throw("greyobject: obj not pointer-aligned")
         .          .   1045:	}
         .          .   1046:
      50ms       50ms   1047:	if useCheckmark {
         .          .   1048:		if !hbits.isMarked() {
         .          .   1049:			printlock()
         .          .   1050:			print("runtime:greyobject: checkmarks finds unexpected unmarked object obj=", hex(obj), "\n")
         .          .   1051:			print("runtime: found obj at *(", hex(base), "+", hex(off), ")\n")
         .          .   1052:
         .          .   1053:			// Dump the source (base) object
         .          .   1054:			gcDumpObject("base", base, off)
         .          .   1055:
         .          .   1056:			// Dump the object
         .          .   1057:			gcDumpObject("obj", obj, ^uintptr(0))
         .          .   1058:
         .          .   1059:			throw("checkmark found unmarked object")
         .          .   1060:		}
         .          .   1061:		if hbits.isCheckmarked(span.elemsize) {
         .          .   1062:			return
         .          .   1063:		}
         .          .   1064:		hbits.setCheckmarked(span.elemsize)
         .          .   1065:		if !hbits.isCheckmarked(span.elemsize) {
         .          .   1066:			throw("setCheckmarked and isCheckmarked disagree")
         .          .   1067:		}
         .          .   1068:	} else {
         .          .   1069:		// If marked we have nothing to do.
     250ms      250ms   1070:		if hbits.isMarked() {
         .          .   1071:			return
         .          .   1072:		}
      20ms      440ms   1073:		hbits.setMarked()
         .          .   1074:
         .          .   1075:		// If this is a noscan object, fast-track it to black
         .          .   1076:		// instead of greying it.
     130ms      130ms   1077:		if !hbits.hasPointers(span.elemsize) {
      20ms       20ms   1078:			gcw.bytesMarked += uint64(span.elemsize)
      10ms       10ms   1079:			return
         .          .   1080:		}
         .          .   1081:	}
         .          .   1082:
         .          .   1083:	// Queue the obj for scanning. The PREFETCH(obj) logic has been removed but
         .          .   1084:	// seems like a nice optimization that can be added back in.
         .          .   1085:	// There needs to be time between the PREFETCH and the use.
         .          .   1086:	// Previously we put the obj in an 8 element buffer that is drained at a rate
         .          .   1087:	// to give the PREFETCH time to do its work.
         .          .   1088:	// Use of PREFETCHNTA might be more appropriate than PREFETCH
         .          .   1089:
         .       60ms   1090:	gcw.put(obj)
      10ms       10ms   1091:}
         .          .   1092:
         .          .   1093:// gcDumpObject dumps the contents of obj for debugging and marks the
         .          .   1094:// field at byte offset off in obj.
         .          .   1095:func gcDumpObject(label string, obj, off uintptr) {
         .          .   1096:	if obj < mheap_.arena_start || obj >= mheap_.arena_used {
ROUTINE ======================== runtime.growWork in /home/isucon/.local/go/src/runtime/hashmap.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    834:func growWork(t *maptype, h *hmap, bucket uintptr) {
         .          .    835:	noldbuckets := uintptr(1) << (h.B - 1)
         .          .    836:
         .          .    837:	// make sure we evacuate the oldbucket corresponding
         .          .    838:	// to the bucket we're about to use
         .       20ms    839:	evacuate(t, h, bucket&(noldbuckets-1))
         .          .    840:
         .          .    841:	// evacuate one more oldbucket to make progress on growing
         .          .    842:	if h.oldbuckets != nil {
         .       10ms    843:		evacuate(t, h, h.nevacuate)
         .          .    844:	}
         .          .    845:}
         .          .    846:
         .          .    847:func evacuate(t *maptype, h *hmap, oldbucket uintptr) {
         .          .    848:	b := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))
ROUTINE ======================== runtime.growslice in /home/isucon/.local/go/src/runtime/slice.go
      30ms      140ms (flat, cum)  0.25% of Total
         .          .     47:// growslice handles slice growth during append.
         .          .     48:// It is passed the slice type, the old slice, and the desired new minimum capacity,
         .          .     49:// and it returns a new slice with at least that capacity, with the old data
         .          .     50:// copied into it.
         .          .     51:func growslice(t *slicetype, old slice, cap int) slice {
      30ms       30ms     52:	if cap < old.cap || t.elem.size > 0 && uintptr(cap) > _MaxMem/uintptr(t.elem.size) {
         .          .     53:		panic(errorString("growslice: cap out of range"))
         .          .     54:	}
         .          .     55:
         .          .     56:	if raceenabled {
         .          .     57:		callerpc := getcallerpc(unsafe.Pointer(&t))
         .          .     58:		racereadrangepc(old.array, uintptr(old.len*int(t.elem.size)), callerpc, funcPC(growslice))
         .          .     59:	}
         .          .     60:	if msanenabled {
         .          .     61:		msanread(old.array, uintptr(old.len*int(t.elem.size)))
         .          .     62:	}
         .          .     63:
         .          .     64:	et := t.elem
         .          .     65:	if et.size == 0 {
         .          .     66:		// append should not create a slice with nil pointer but non-zero len.
         .          .     67:		// We assume that append doesn't need to preserve old.array in this case.
         .          .     68:		return slice{unsafe.Pointer(&zerobase), old.len, cap}
         .          .     69:	}
         .          .     70:
         .          .     71:	newcap := old.cap
         .          .     72:	if newcap+newcap < cap {
         .          .     73:		newcap = cap
         .          .     74:	} else {
         .          .     75:		for {
         .          .     76:			if old.len < 1024 {
         .          .     77:				newcap += newcap
         .          .     78:			} else {
         .          .     79:				newcap += newcap / 4
         .          .     80:			}
         .          .     81:			if newcap >= cap {
         .          .     82:				break
         .          .     83:			}
         .          .     84:		}
         .          .     85:	}
         .          .     86:
         .          .     87:	if uintptr(newcap) >= _MaxMem/uintptr(et.size) {
         .          .     88:		panic(errorString("growslice: cap out of range"))
         .          .     89:	}
         .          .     90:	lenmem := uintptr(old.len) * uintptr(et.size)
         .          .     91:	capmem := roundupsize(uintptr(newcap) * uintptr(et.size))
         .          .     92:	newcap = int(capmem / uintptr(et.size))
         .          .     93:	var p unsafe.Pointer
         .          .     94:	if et.kind&kindNoPointers != 0 {
         .       10ms     95:		p = rawmem(capmem)
         .          .     96:		memmove(p, old.array, lenmem)
         .       20ms     97:		memclr(add(p, lenmem), capmem-lenmem)
         .          .     98:	} else {
         .          .     99:		// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.
         .       80ms    100:		p = newarray(et, uintptr(newcap))
         .          .    101:		if !writeBarrier.enabled {
         .          .    102:			memmove(p, old.array, lenmem)
         .          .    103:		} else {
         .          .    104:			for i := uintptr(0); i < lenmem; i += et.size {
         .          .    105:				typedmemmove(et, add(p, i), add(old.array, i))
ROUTINE ======================== runtime.growslice_n in /home/isucon/.local/go/src/runtime/slice.go
         0       30ms (flat, cum) 0.054% of Total
         .          .     39:// The compiler should change that code to use growslice directly (issue #11419).
         .          .     40:func growslice_n(t *slicetype, old slice, n int) slice {
         .          .     41:	if n < 1 {
         .          .     42:		panic(errorString("growslice: invalid n"))
         .          .     43:	}
         .       30ms     44:	return growslice(t, old, old.cap+n)
         .          .     45:}
         .          .     46:
         .          .     47:// growslice handles slice growth during append.
         .          .     48:// It is passed the slice type, the old slice, and the desired new minimum capacity,
         .          .     49:// and it returns a new slice with at least that capacity, with the old data
ROUTINE ======================== runtime.hashGrow in /home/isucon/.local/go/src/runtime/hashmap.go
         0       50ms (flat, cum)  0.09% of Total
         .          .    804:func hashGrow(t *maptype, h *hmap) {
         .          .    805:	if h.oldbuckets != nil {
         .          .    806:		throw("evacuation not done in time")
         .          .    807:	}
         .          .    808:	oldbuckets := h.buckets
         .       50ms    809:	newbuckets := newarray(t.bucket, uintptr(1)<<(h.B+1))
         .          .    810:	flags := h.flags &^ (iterator | oldIterator)
         .          .    811:	if h.flags&iterator != 0 {
         .          .    812:		flags |= oldIterator
         .          .    813:	}
         .          .    814:	// commit the grow (atomic wrt gc)
ROUTINE ======================== runtime.heapBits.initSpan in /home/isucon/.local/go/src/runtime/mbitmap.go
         0      130ms (flat, cum)  0.23% of Total
         .          .    509:			}
         .          .    510:			bitp = add1(bitp)
         .          .    511:		}
         .          .    512:		return
         .          .    513:	}
         .      130ms    514:	memclr(unsafe.Pointer(subtractb(h.bitp, nbyte-1)), nbyte)
         .          .    515:}
         .          .    516:
         .          .    517:// initCheckmarkSpan initializes a span for being checkmarked.
         .          .    518:// It clears the checkmark bits, which are set to 1 in normal operation.
         .          .    519:func (h heapBits) initCheckmarkSpan(size, n, total uintptr) {
ROUTINE ======================== runtime.heapBits.setMarked in /home/isucon/.local/go/src/runtime/mbitmap.go
     100ms      430ms (flat, cum)  0.77% of Total
         .          .    304:func (h heapBits) setMarked() {
         .          .    305:	// Each byte of GC bitmap holds info for four words.
         .          .    306:	// Might be racing with other updates, so use atomic update always.
         .          .    307:	// We used to be clever here and use a non-atomic update in certain
         .          .    308:	// cases, but it's not worth the risk.
      70ms      400ms    309:	atomic.Or8(h.bitp, bitMarked<<h.shift)
      30ms       30ms    310:}
         .          .    311:
         .          .    312:// setMarkedNonAtomic sets the marked bit in the heap bits, non-atomically.
         .          .    313:// h must describe the initial word of the object.
         .          .    314:func (h heapBits) setMarkedNonAtomic() {
         .          .    315:	*h.bitp |= bitMarked << h.shift
ROUTINE ======================== runtime.heapBitsBulkBarrier in /home/isucon/.local/go/src/runtime/mbitmap.go
     680ms      970ms (flat, cum)  1.74% of Total
         .          .    393:// no pointers at all; any caller of heapBitsBulkBarrier must first
         .          .    394:// make sure the underlying allocation contains pointers, usually
         .          .    395:// by checking typ.kind&kindNoPointers.
         .          .    396://
         .          .    397://go:nosplit
     100ms      100ms    398:func heapBitsBulkBarrier(p, size uintptr) {
     190ms      190ms    399:	if (p|size)&(sys.PtrSize-1) != 0 {
         .          .    400:		throw("heapBitsBulkBarrier: unaligned arguments")
         .          .    401:	}
      20ms       20ms    402:	if !writeBarrier.needed {
      10ms       10ms    403:		return
         .          .    404:	}
      20ms       20ms    405:	if !inheap(p) {
         .          .    406:		// If p is on the stack and in a higher frame than the
         .          .    407:		// caller, we either need to execute write barriers on
         .          .    408:		// it (which is what happens for normal stack writes
         .          .    409:		// through pointers to higher frames), or we need to
         .          .    410:		// force the mark termination stack scan to scan the
         .          .    411:		// frame containing p.
         .          .    412:		//
         .          .    413:		// Executing write barriers on p is complicated in the
         .          .    414:		// general case because we either need to unwind the
         .          .    415:		// stack to get the stack map, or we need the type's
         .          .    416:		// bitmap, which may be a GC program.
         .          .    417:		//
         .          .    418:		// Hence, we opt for forcing the re-scan to scan the
         .          .    419:		// frame containing p, which we can do by simply
         .          .    420:		// unwinding the stack barriers between the current SP
         .          .    421:		// and p's frame.
         .          .    422:		gp := getg().m.curg
      10ms       10ms    423:		if gp != nil && gp.stack.lo <= p && p < gp.stack.hi {
         .          .    424:			// Run on the system stack to give it more
         .          .    425:			// stack space.
         .          .    426:			systemstack(func() {
         .          .    427:				gcUnwindBarriers(gp, p)
         .       40ms    428:			})
         .          .    429:		}
         .          .    430:		return
         .          .    431:	}
         .          .    432:
      10ms       10ms    433:	h := heapBitsForAddr(p)
      30ms       30ms    434:	for i := uintptr(0); i < size; i += sys.PtrSize {
     140ms      140ms    435:		if h.isPointer() {
      10ms       10ms    436:			x := (*uintptr)(unsafe.Pointer(p + i))
      10ms      260ms    437:			writebarrierptr_nostore(x, *x)
         .          .    438:		}
     130ms      130ms    439:		h = h.next()
         .          .    440:	}
         .          .    441:}
         .          .    442:
         .          .    443:// typeBitsBulkBarrier executes writebarrierptr_nostore
         .          .    444:// for every pointer slot in the memory range [p, p+size),
ROUTINE ======================== runtime.heapBitsBulkBarrier.func1 in /home/isucon/.local/go/src/runtime/mbitmap.go
      10ms       60ms (flat, cum)  0.11% of Total
         .          .    422:		gp := getg().m.curg
         .          .    423:		if gp != nil && gp.stack.lo <= p && p < gp.stack.hi {
         .          .    424:			// Run on the system stack to give it more
         .          .    425:			// stack space.
         .          .    426:			systemstack(func() {
      10ms       60ms    427:				gcUnwindBarriers(gp, p)
         .          .    428:			})
         .          .    429:		}
         .          .    430:		return
         .          .    431:	}
         .          .    432:
ROUTINE ======================== runtime.heapBitsForObject in /home/isucon/.local/go/src/runtime/mbitmap.go
     940ms      940ms (flat, cum)  1.69% of Total
         .          .    188:// otherwise return the base of the object.
         .          .    189://
         .          .    190:// refBase and refOff optionally give the base address of the object
         .          .    191:// in which the pointer p was found and the byte offset at which it
         .          .    192:// was found. These are used for error reporting.
     120ms      120ms    193:func heapBitsForObject(p, refBase, refOff uintptr) (base uintptr, hbits heapBits, s *mspan) {
         .          .    194:	arenaStart := mheap_.arena_start
      40ms       40ms    195:	if p < arenaStart || p >= mheap_.arena_used {
         .          .    196:		return
         .          .    197:	}
      10ms       10ms    198:	off := p - arenaStart
         .          .    199:	idx := off >> _PageShift
         .          .    200:	// p points into the heap, but possibly to the middle of an object.
         .          .    201:	// Consult the span table to find the block beginning.
         .          .    202:	k := p >> _PageShift
      30ms       30ms    203:	s = h_spans[idx]
     340ms      340ms    204:	if s == nil || pageID(k) < s.start || p >= s.limit || s.state != mSpanInUse {
         .          .    205:		if s == nil || s.state == _MSpanStack {
         .          .    206:			// If s is nil, the virtual address has never been part of the heap.
         .          .    207:			// This pointer may be to some mmap'd region, so we allow it.
         .          .    208:			// Pointers into stacks are also ok, the runtime manages these explicitly.
         .          .    209:			return
         .          .    210:		}
         .          .    211:
         .          .    212:		// The following ensures that we are rigorous about what data
         .          .    213:		// structures hold valid pointers.
         .          .    214:		if debug.invalidptr != 0 {
         .          .    215:			// Typically this indicates an incorrect use
         .          .    216:			// of unsafe or cgo to store a bad pointer in
         .          .    217:			// the Go heap. It may also indicate a runtime
         .          .    218:			// bug.
         .          .    219:			//
         .          .    220:			// TODO(austin): We could be more aggressive
         .          .    221:			// and detect pointers to unallocated objects
         .          .    222:			// in allocated spans.
         .          .    223:			printlock()
         .          .    224:			print("runtime: pointer ", hex(p))
         .          .    225:			if s.state != mSpanInUse {
         .          .    226:				print(" to unallocated span")
         .          .    227:			} else {
         .          .    228:				print(" to unused region of span")
         .          .    229:			}
         .          .    230:			print("idx=", hex(idx), " span.start=", hex(s.start<<_PageShift), " span.limit=", hex(s.limit), " span.state=", s.state, "\n")
         .          .    231:			if refBase != 0 {
         .          .    232:				print("runtime: found in object at *(", hex(refBase), "+", hex(refOff), ")\n")
         .          .    233:				gcDumpObject("object", refBase, refOff)
         .          .    234:			}
         .          .    235:			throw("found bad pointer in Go heap (incorrect use of unsafe or cgo?)")
         .          .    236:		}
         .          .    237:		return
         .          .    238:	}
         .          .    239:	// If this span holds object of a power of 2 size, just mask off the bits to
         .          .    240:	// the interior of the object. Otherwise use the size to get the base.
      30ms       30ms    241:	if s.baseMask != 0 {
         .          .    242:		// optimize for power of 2 sized objects.
      40ms       40ms    243:		base = s.base()
         .          .    244:		base = base + (p-base)&s.baseMask
         .          .    245:		// base = p & s.baseMask is faster for small spans,
         .          .    246:		// but doesn't work for large spans.
         .          .    247:		// Overall, it's faster to use the more general computation above.
         .          .    248:	} else {
         .          .    249:		base = s.base()
      60ms       60ms    250:		if p-base >= s.elemsize {
         .          .    251:			// n := (p - base) / s.elemsize, using division by multiplication
      70ms       70ms    252:			n := uintptr(uint64(p-base) >> s.divShift * uint64(s.divMul) >> s.divShift2)
      30ms       30ms    253:			base += n * s.elemsize
         .          .    254:		}
         .          .    255:	}
         .          .    256:	// Now that we know the actual base, compute heapBits to return to caller.
     160ms      160ms    257:	hbits = heapBitsForAddr(base)
      10ms       10ms    258:	return
         .          .    259:}
         .          .    260:
         .          .    261:// prefetch the bits.
         .          .    262:func (h heapBits) prefetch() {
         .          .    263:	prefetchnta(uintptr(unsafe.Pointer((h.bitp))))
ROUTINE ======================== runtime.heapBitsForSpan in /home/isucon/.local/go/src/runtime/mbitmap.go
      20ms       20ms (flat, cum) 0.036% of Total
         .          .    168:	off := (addr - mheap_.arena_start) / sys.PtrSize
         .          .    169:	return heapBits{(*uint8)(unsafe.Pointer(mheap_.arena_start - off/4 - 1)), uint32(off & 3)}
         .          .    170:}
         .          .    171:
         .          .    172:// heapBitsForSpan returns the heapBits for the span base address base.
      20ms       20ms    173:func heapBitsForSpan(base uintptr) (hbits heapBits) {
         .          .    174:	if base < mheap_.arena_start || base >= mheap_.arena_used {
         .          .    175:		throw("heapBitsForSpan: base out of range")
         .          .    176:	}
         .          .    177:	hbits = heapBitsForAddr(base)
         .          .    178:	if hbits.shift != 0 {
ROUTINE ======================== runtime.heapBitsSetType in /home/isucon/.local/go/src/runtime/mbitmap.go
     2.47s      2.47s (flat, cum)  4.44% of Total
         .          .    674:// which can be setting the mark bit in the leading 2-bit entry
         .          .    675:// of an allocated block. The block we are modifying is not quite
         .          .    676:// allocated yet, so the GC marker is not racing with updates to x's bits,
         .          .    677:// but if the start or end of x shares a bitmap byte with an adjacent
         .          .    678:// object, the GC marker is racing with updates to those object's mark bits.
      80ms       80ms    679:func heapBitsSetType(x, size, dataSize uintptr, typ *_type) {
         .          .    680:	const doubleCheck = false // slow but helpful; enable to test modifications to this code
         .          .    681:
         .          .    682:	// dataSize is always size rounded up to the next malloc size class,
         .          .    683:	// except in the case of allocating a defer block, in which case
         .          .    684:	// size is sizeof(_defer{}) (at least 6 words) and dataSize may be
         .          .    685:	// arbitrarily larger.
         .          .    686:	//
         .          .    687:	// The checks for size == ptrSize and size == 2*ptrSize can therefore
         .          .    688:	// assume that dataSize == size without checking it explicitly.
         .          .    689:
      20ms       20ms    690:	if sys.PtrSize == 8 && size == sys.PtrSize {
         .          .    691:		// It's one word and it has pointers, it must be a pointer.
         .          .    692:		// In general we'd need an atomic update here if the
         .          .    693:		// concurrent GC were marking objects in this span,
         .          .    694:		// because each bitmap byte describes 3 other objects
         .          .    695:		// in addition to the one being allocated.
         .          .    696:		// However, since all allocated one-word objects are pointers
         .          .    697:		// (non-pointers are aggregated into tinySize allocations),
         .          .    698:		// initSpan sets the pointer bits for us. Nothing to do here.
         .          .    699:		if doubleCheck {
         .          .    700:			h := heapBitsForAddr(x)
         .          .    701:			if !h.isPointer() {
         .          .    702:				throw("heapBitsSetType: pointer bit missing")
         .          .    703:			}
         .          .    704:		}
         .          .    705:		return
         .          .    706:	}
         .          .    707:
     240ms      240ms    708:	h := heapBitsForAddr(x)
      10ms       10ms    709:	ptrmask := typ.gcdata // start of 1-bit pointer mask (or GC program, handled below)
         .          .    710:
         .          .    711:	// Heap bitmap bits for 2-word object are only 4 bits,
         .          .    712:	// so also shared with objects next to it; use atomic updates.
         .          .    713:	// This is called out as a special case primarily for 32-bit systems,
         .          .    714:	// so that on 32-bit systems the code below can assume all objects
         .          .    715:	// are 4-word aligned (because they're all 16-byte aligned).
      30ms       30ms    716:	if size == 2*sys.PtrSize {
         .          .    717:		if typ.size == sys.PtrSize {
         .          .    718:			// We're allocating a block big enough to hold two pointers.
         .          .    719:			// On 64-bit, that means the actual object must be two pointers,
         .          .    720:			// or else we'd have used the one-pointer-sized block.
         .          .    721:			// On 32-bit, however, this is the 8-byte block, the smallest one.
         .          .    722:			// So it could be that we're allocating one pointer and this was
         .          .    723:			// just the smallest block available. Distinguish by checking dataSize.
         .          .    724:			// (In general the number of instances of typ being allocated is
         .          .    725:			// dataSize/typ.size.)
         .          .    726:			if sys.PtrSize == 4 && dataSize == sys.PtrSize {
         .          .    727:				// 1 pointer.
         .          .    728:				if gcphase == _GCoff {
         .          .    729:					*h.bitp |= bitPointer << h.shift
         .          .    730:				} else {
         .          .    731:					atomic.Or8(h.bitp, bitPointer<<h.shift)
         .          .    732:				}
         .          .    733:			} else {
         .          .    734:				// 2-element slice of pointer.
         .          .    735:				if gcphase == _GCoff {
         .          .    736:					*h.bitp |= (bitPointer | bitPointer<<heapBitsShift) << h.shift
         .          .    737:				} else {
         .          .    738:					atomic.Or8(h.bitp, (bitPointer|bitPointer<<heapBitsShift)<<h.shift)
         .          .    739:				}
         .          .    740:			}
         .          .    741:			return
         .          .    742:		}
         .          .    743:		// Otherwise typ.size must be 2*ptrSize, and typ.kind&kindGCProg == 0.
         .          .    744:		if doubleCheck {
         .          .    745:			if typ.size != 2*sys.PtrSize || typ.kind&kindGCProg != 0 {
         .          .    746:				print("runtime: heapBitsSetType size=", size, " but typ.size=", typ.size, " gcprog=", typ.kind&kindGCProg != 0, "\n")
         .          .    747:				throw("heapBitsSetType")
         .          .    748:			}
         .          .    749:		}
         .          .    750:		b := uint32(*ptrmask)
         .          .    751:		hb := b & 3
      10ms       10ms    752:		if gcphase == _GCoff {
      20ms       20ms    753:			*h.bitp |= uint8(hb << h.shift)
         .          .    754:		} else {
         .          .    755:			atomic.Or8(h.bitp, uint8(hb<<h.shift))
         .          .    756:		}
         .          .    757:		return
         .          .    758:	}
         .          .    759:
         .          .    760:	// Copy from 1-bit ptrmask into 2-bit bitmap.
         .          .    761:	// The basic approach is to use a single uintptr as a bit buffer,
         .          .    762:	// alternating between reloading the buffer and writing bitmap bytes.
         .          .    763:	// In general, one load can supply two bitmap byte writes.
         .          .    764:	// This is a lot of lines of code, but it compiles into relatively few
         .          .    765:	// machine instructions.
         .          .    766:
         .          .    767:	var (
         .          .    768:		// Ptrmask input.
         .          .    769:		p     *byte   // last ptrmask byte read
      20ms       20ms    770:		b     uintptr // ptrmask bits already loaded
      40ms       40ms    771:		nb    uintptr // number of bits in b at next read
      20ms       20ms    772:		endp  *byte   // final ptrmask byte to read (then repeat)
         .          .    773:		endnb uintptr // number of valid bits in *endp
         .          .    774:		pbits uintptr // alternate source of bits
         .          .    775:
         .          .    776:		// Heap bitmap output.
      30ms       30ms    777:		w     uintptr // words processed
         .          .    778:		nw    uintptr // number of words to process
         .          .    779:		hbitp *byte   // next heap bitmap byte to write
         .          .    780:		hb    uintptr // bits being prepared for *hbitp
         .          .    781:	)
         .          .    782:
      50ms       50ms    783:	hbitp = h.bitp
         .          .    784:
         .          .    785:	// Handle GC program. Delayed until this part of the code
         .          .    786:	// so that we can use the same double-checking mechanism
         .          .    787:	// as the 1-bit case. Nothing above could have encountered
         .          .    788:	// GC programs: the cases were all too small.
      30ms       30ms    789:	if typ.kind&kindGCProg != 0 {
         .          .    790:		heapBitsSetTypeGCProg(h, typ.ptrdata, typ.size, dataSize, size, addb(typ.gcdata, 4))
         .          .    791:		if doubleCheck {
         .          .    792:			// Double-check the heap bits written by GC program
         .          .    793:			// by running the GC program to create a 1-bit pointer mask
         .          .    794:			// and then jumping to the double-check code below.
         .          .    795:			// This doesn't catch bugs shared between the 1-bit and 4-bit
         .          .    796:			// GC program execution, but it does catch mistakes specific
         .          .    797:			// to just one of those and bugs in heapBitsSetTypeGCProg's
         .          .    798:			// implementation of arrays.
         .          .    799:			lock(&debugPtrmask.lock)
         .          .    800:			if debugPtrmask.data == nil {
         .          .    801:				debugPtrmask.data = (*byte)(persistentalloc(1<<20, 1, &memstats.other_sys))
         .          .    802:			}
         .          .    803:			ptrmask = debugPtrmask.data
         .          .    804:			runGCProg(addb(typ.gcdata, 4), nil, ptrmask, 1)
         .          .    805:			goto Phase4
         .          .    806:		}
         .          .    807:		return
         .          .    808:	}
         .          .    809:
         .          .    810:	// Note about sizes:
         .          .    811:	//
         .          .    812:	// typ.size is the number of words in the object,
         .          .    813:	// and typ.ptrdata is the number of words in the prefix
         .          .    814:	// of the object that contains pointers. That is, the final
         .          .    815:	// typ.size - typ.ptrdata words contain no pointers.
         .          .    816:	// This allows optimization of a common pattern where
         .          .    817:	// an object has a small header followed by a large scalar
         .          .    818:	// buffer. If we know the pointers are over, we don't have
         .          .    819:	// to scan the buffer's heap bitmap at all.
         .          .    820:	// The 1-bit ptrmasks are sized to contain only bits for
         .          .    821:	// the typ.ptrdata prefix, zero padded out to a full byte
         .          .    822:	// of bitmap. This code sets nw (below) so that heap bitmap
         .          .    823:	// bits are only written for the typ.ptrdata prefix; if there is
         .          .    824:	// more room in the allocated object, the next heap bitmap
         .          .    825:	// entry is a 00, indicating that there are no more pointers
         .          .    826:	// to scan. So only the ptrmask for the ptrdata bytes is needed.
         .          .    827:	//
         .          .    828:	// Replicated copies are not as nice: if there is an array of
         .          .    829:	// objects with scalar tails, all but the last tail does have to
         .          .    830:	// be initialized, because there is no way to say "skip forward".
         .          .    831:	// However, because of the possibility of a repeated type with
         .          .    832:	// size not a multiple of 4 pointers (one heap bitmap byte),
         .          .    833:	// the code already must handle the last ptrmask byte specially
         .          .    834:	// by treating it as containing only the bits for endnb pointers,
         .          .    835:	// where endnb <= 4. We represent large scalar tails that must
         .          .    836:	// be expanded in the replication by setting endnb larger than 4.
         .          .    837:	// This will have the effect of reading many bits out of b,
         .          .    838:	// but once the real bits are shifted out, b will supply as many
         .          .    839:	// zero bits as we try to read, which is exactly what we need.
         .          .    840:
      50ms       50ms    841:	p = ptrmask
      30ms       30ms    842:	if typ.size < dataSize {
         .          .    843:		// Filling in bits for an array of typ.
         .          .    844:		// Set up for repetition of ptrmask during main loop.
         .          .    845:		// Note that ptrmask describes only a prefix of
         .          .    846:		const maxBits = sys.PtrSize*8 - 7
         .          .    847:		if typ.ptrdata/sys.PtrSize <= maxBits {
         .          .    848:			// Entire ptrmask fits in uintptr with room for a byte fragment.
         .          .    849:			// Load into pbits and never read from ptrmask again.
         .          .    850:			// This is especially important when the ptrmask has
         .          .    851:			// fewer than 8 bits in it; otherwise the reload in the middle
         .          .    852:			// of the Phase 2 loop would itself need to loop to gather
         .          .    853:			// at least 8 bits.
         .          .    854:
         .          .    855:			// Accumulate ptrmask into b.
         .          .    856:			// ptrmask is sized to describe only typ.ptrdata, but we record
         .          .    857:			// it as describing typ.size bytes, since all the high bits are zero.
         .          .    858:			nb = typ.ptrdata / sys.PtrSize
         .          .    859:			for i := uintptr(0); i < nb; i += 8 {
      10ms       10ms    860:				b |= uintptr(*p) << i
         .          .    861:				p = add1(p)
         .          .    862:			}
         .          .    863:			nb = typ.size / sys.PtrSize
         .          .    864:
         .          .    865:			// Replicate ptrmask to fill entire pbits uintptr.
         .          .    866:			// Doubling and truncating is fewer steps than
         .          .    867:			// iterating by nb each time. (nb could be 1.)
         .          .    868:			// Since we loaded typ.ptrdata/ptrSize bits
         .          .    869:			// but are pretending to have typ.size/ptrSize,
         .          .    870:			// there might be no replication necessary/possible.
      10ms       10ms    871:			pbits = b
         .          .    872:			endnb = nb
      10ms       10ms    873:			if nb+nb <= maxBits {
         .          .    874:				for endnb <= sys.PtrSize*8 {
         .          .    875:					pbits |= pbits << endnb
         .          .    876:					endnb += endnb
         .          .    877:				}
         .          .    878:				// Truncate to a multiple of original ptrmask.
         .          .    879:				endnb = maxBits / nb * nb
         .          .    880:				pbits &= 1<<endnb - 1
         .          .    881:				b = pbits
         .          .    882:				nb = endnb
         .          .    883:			}
         .          .    884:
         .          .    885:			// Clear p and endp as sentinel for using pbits.
         .          .    886:			// Checked during Phase 2 loop.
         .          .    887:			p = nil
         .          .    888:			endp = nil
         .          .    889:		} else {
         .          .    890:			// Ptrmask is larger. Read it multiple times.
         .          .    891:			n := (typ.ptrdata/sys.PtrSize+7)/8 - 1
         .          .    892:			endp = addb(ptrmask, n)
         .          .    893:			endnb = typ.size/sys.PtrSize - n*8
         .          .    894:		}
         .          .    895:	}
     110ms      110ms    896:	if p != nil {
      50ms       50ms    897:		b = uintptr(*p)
     130ms      130ms    898:		p = add1(p)
      30ms       30ms    899:		nb = 8
         .          .    900:	}
         .          .    901:
      30ms       30ms    902:	if typ.size == dataSize {
         .          .    903:		// Single entry: can stop once we reach the non-pointer data.
      40ms       40ms    904:		nw = typ.ptrdata / sys.PtrSize
         .          .    905:	} else {
         .          .    906:		// Repeated instances of typ in an array.
         .          .    907:		// Have to process first N-1 entries in full, but can stop
         .          .    908:		// once we reach the non-pointer data in the final entry.
      10ms       10ms    909:		nw = ((dataSize/typ.size-1)*typ.size + typ.ptrdata) / sys.PtrSize
         .          .    910:	}
         .          .    911:	if nw == 0 {
         .          .    912:		// No pointers! Caller was supposed to check.
         .          .    913:		println("runtime: invalid type ", *typ._string)
         .          .    914:		throw("heapBitsSetType: called with non-pointer type")
         .          .    915:		return
         .          .    916:	}
     110ms      110ms    917:	if nw < 2 {
         .          .    918:		// Must write at least 2 words, because the "no scan"
         .          .    919:		// encoding doesn't take effect until the third word.
         .          .    920:		nw = 2
         .          .    921:	}
         .          .    922:
         .          .    923:	// Phase 1: Special case for leading byte (shift==0) or half-byte (shift==4).
         .          .    924:	// The leading byte is special because it contains the bits for words 0 and 1,
         .          .    925:	// which do not have the marked bits set.
         .          .    926:	// The leading half-byte is special because it's a half a byte and must be
         .          .    927:	// manipulated atomically.
         .          .    928:	switch {
         .          .    929:	default:
         .          .    930:		throw("heapBitsSetType: unexpected shift")
         .          .    931:
      30ms       30ms    932:	case h.shift == 0:
         .          .    933:		// Ptrmask and heap bitmap are aligned.
         .          .    934:		// Handle first byte of bitmap specially.
         .          .    935:		// The first byte we write out contains the first two words of the object.
         .          .    936:		// In those words, the mark bits are mark and checkmark, respectively,
         .          .    937:		// and must not be set. In all following words, we want to set the mark bit
         .          .    938:		// as a signal that the object continues to the next 2-bit entry in the bitmap.
      10ms       10ms    939:		hb = b & bitPointerAll
      10ms       10ms    940:		hb |= bitMarked<<(2*heapBitsShift) | bitMarked<<(3*heapBitsShift)
      20ms       20ms    941:		if w += 4; w >= nw {
         .          .    942:			goto Phase3
         .          .    943:		}
         .          .    944:		*hbitp = uint8(hb)
         .          .    945:		hbitp = subtract1(hbitp)
         .          .    946:		b >>= 4
      10ms       10ms    947:		nb -= 4
         .          .    948:
         .          .    949:	case sys.PtrSize == 8 && h.shift == 2:
         .          .    950:		// Ptrmask and heap bitmap are misaligned.
         .          .    951:		// The bits for the first two words are in a byte shared with another object
         .          .    952:		// and must be updated atomically.
         .          .    953:		// NOTE(rsc): The atomic here may not be necessary.
         .          .    954:		// We took care of 1-word and 2-word objects above,
         .          .    955:		// so this is at least a 6-word object, so our start bits
         .          .    956:		// are shared only with the type bits of another object,
         .          .    957:		// not with its mark bit. Since there is only one allocation
         .          .    958:		// from a given span at a time, we should be able to set
         .          .    959:		// these bits non-atomically. Not worth the risk right now.
         .          .    960:		hb = (b & 3) << (2 * heapBitsShift)
         .          .    961:		b >>= 2
         .          .    962:		nb -= 2
         .          .    963:		// Note: no bitMarker in hb because the first two words don't get markers from us.
         .          .    964:		if gcphase == _GCoff {
         .          .    965:			*hbitp |= uint8(hb)
         .          .    966:		} else {
         .          .    967:			atomic.Or8(hbitp, uint8(hb))
         .          .    968:		}
         .          .    969:		hbitp = subtract1(hbitp)
         .          .    970:		if w += 2; w >= nw {
         .          .    971:			// We know that there is more data, because we handled 2-word objects above.
         .          .    972:			// This must be at least a 6-word object. If we're out of pointer words,
         .          .    973:			// mark no scan in next bitmap byte and finish.
         .          .    974:			hb = 0
         .          .    975:			w += 4
         .          .    976:			goto Phase3
         .          .    977:		}
         .          .    978:	}
         .          .    979:
         .          .    980:	// Phase 2: Full bytes in bitmap, up to but not including write to last byte (full or partial) in bitmap.
         .          .    981:	// The loop computes the bits for that last write but does not execute the write;
         .          .    982:	// it leaves the bits in hb for processing by phase 3.
         .          .    983:	// To avoid repeated adjustment of nb, we subtract out the 4 bits we're going to
         .          .    984:	// use in the first half of the loop right now, and then we only adjust nb explicitly
         .          .    985:	// if the 8 bits used by each iteration isn't balanced by 8 bits loaded mid-loop.
         .          .    986:	nb -= 4
         .          .    987:	for {
         .          .    988:		// Emit bitmap byte.
         .          .    989:		// b has at least nb+4 bits, with one exception:
         .          .    990:		// if w+4 >= nw, then b has only nw-w bits,
         .          .    991:		// but we'll stop at the break and then truncate
         .          .    992:		// appropriately in Phase 3.
      30ms       30ms    993:		hb = b & bitPointerAll
      10ms       10ms    994:		hb |= bitMarkedAll
     110ms      110ms    995:		if w += 4; w >= nw {
         .          .    996:			break
         .          .    997:		}
         .          .    998:		*hbitp = uint8(hb)
      60ms       60ms    999:		hbitp = subtract1(hbitp)
      20ms       20ms   1000:		b >>= 4
         .          .   1001:
         .          .   1002:		// Load more bits. b has nb right now.
      60ms       60ms   1003:		if p != endp {
         .          .   1004:			// Fast path: keep reading from ptrmask.
         .          .   1005:			// nb unmodified: we just loaded 8 bits,
         .          .   1006:			// and the next iteration will consume 8 bits,
         .          .   1007:			// leaving us with the same nb the next time we're here.
         .          .   1008:			if nb < 8 {
         .          .   1009:				b |= uintptr(*p) << nb
         .          .   1010:				p = add1(p)
         .          .   1011:			} else {
         .          .   1012:				// Reduce the number of bits in b.
         .          .   1013:				// This is important if we skipped
         .          .   1014:				// over a scalar tail, since nb could
         .          .   1015:				// be larger than the bit width of b.
         .          .   1016:				nb -= 8
         .          .   1017:			}
      20ms       20ms   1018:		} else if p == nil {
         .          .   1019:			// Almost as fast path: track bit count and refill from pbits.
         .          .   1020:			// For short repetitions.
      20ms       20ms   1021:			if nb < 8 {
      10ms       10ms   1022:				b |= pbits << nb
      20ms       20ms   1023:				nb += endnb
         .          .   1024:			}
      70ms       70ms   1025:			nb -= 8 // for next iteration
         .          .   1026:		} else {
         .          .   1027:			// Slow path: reached end of ptrmask.
         .          .   1028:			// Process final partial byte and rewind to start.
         .          .   1029:			b |= uintptr(*p) << nb
         .          .   1030:			nb += endnb
         .          .   1031:			if nb < 8 {
         .          .   1032:				b |= uintptr(*ptrmask) << nb
         .          .   1033:				p = add1(ptrmask)
         .          .   1034:			} else {
         .          .   1035:				nb -= 8
         .          .   1036:				p = ptrmask
         .          .   1037:			}
         .          .   1038:		}
         .          .   1039:
         .          .   1040:		// Emit bitmap byte.
      20ms       20ms   1041:		hb = b & bitPointerAll
      40ms       40ms   1042:		hb |= bitMarkedAll
     140ms      140ms   1043:		if w += 4; w >= nw {
         .          .   1044:			break
         .          .   1045:		}
      10ms       10ms   1046:		*hbitp = uint8(hb)
      70ms       70ms   1047:		hbitp = subtract1(hbitp)
      60ms       60ms   1048:		b >>= 4
         .          .   1049:	}
         .          .   1050:
         .          .   1051:Phase3:
         .          .   1052:	// Phase 3: Write last byte or partial byte and zero the rest of the bitmap entries.
      20ms       20ms   1053:	if w > nw {
         .          .   1054:		// Counting the 4 entries in hb not yet written to memory,
         .          .   1055:		// there are more entries than possible pointer slots.
         .          .   1056:		// Discard the excess entries (can't be more than 3).
     100ms      100ms   1057:		mask := uintptr(1)<<(4-(w-nw)) - 1
      30ms       30ms   1058:		hb &= mask | mask<<4 // apply mask to both pointer bits and mark bits
         .          .   1059:	}
         .          .   1060:
         .          .   1061:	// Change nw from counting possibly-pointer words to total words in allocation.
      40ms       40ms   1062:	nw = size / sys.PtrSize
         .          .   1063:
         .          .   1064:	// Write whole bitmap bytes.
         .          .   1065:	// The first is hb, the rest are zero.
         .          .   1066:	if w <= nw {
      20ms       20ms   1067:		*hbitp = uint8(hb)
      60ms       60ms   1068:		hbitp = subtract1(hbitp)
         .          .   1069:		hb = 0 // for possible final half-byte below
      50ms       50ms   1070:		for w += 4; w <= nw; w += 4 {
         .          .   1071:			*hbitp = 0
         .          .   1072:			hbitp = subtract1(hbitp)
         .          .   1073:		}
         .          .   1074:	}
         .          .   1075:
         .          .   1076:	// Write final partial bitmap byte if any.
         .          .   1077:	// We know w > nw, or else we'd still be in the loop above.
         .          .   1078:	// It can be bigger only due to the 4 entries in hb that it counts.
         .          .   1079:	// If w == nw+4 then there's nothing left to do: we wrote all nw entries
         .          .   1080:	// and can discard the 4 sitting in hb.
         .          .   1081:	// But if w == nw+2, we need to write first two in hb.
         .          .   1082:	// The byte is shared with the next object so we may need an atomic.
      20ms       20ms   1083:	if w == nw+2 {
      10ms       10ms   1084:		if gcphase == _GCoff {
      10ms       10ms   1085:			*hbitp = *hbitp&^(bitPointer|bitMarked|(bitPointer|bitMarked)<<heapBitsShift) | uint8(hb)
         .          .   1086:		} else {
         .          .   1087:			atomic.And8(hbitp, ^uint8(bitPointer|bitMarked|(bitPointer|bitMarked)<<heapBitsShift))
         .          .   1088:			atomic.Or8(hbitp, uint8(hb))
         .          .   1089:		}
         .          .   1090:	}
         .          .   1091:
         .          .   1092:Phase4:
         .          .   1093:	// Phase 4: all done, but perhaps double check.
         .          .   1094:	if doubleCheck {
         .          .   1095:		end := heapBitsForAddr(x + size)
         .          .   1096:		if typ.kind&kindGCProg == 0 && (hbitp != end.bitp || (w == nw+2) != (end.shift == 2)) {
         .          .   1097:			println("ended at wrong bitmap byte for", *typ._string, "x", dataSize/typ.size)
         .          .   1098:			print("typ.size=", typ.size, " typ.ptrdata=", typ.ptrdata, " dataSize=", dataSize, " size=", size, "\n")
         .          .   1099:			print("w=", w, " nw=", nw, " b=", hex(b), " nb=", nb, " hb=", hex(hb), "\n")
         .          .   1100:			h0 := heapBitsForAddr(x)
         .          .   1101:			print("initial bits h0.bitp=", h0.bitp, " h0.shift=", h0.shift, "\n")
         .          .   1102:			print("ended at hbitp=", hbitp, " but next starts at bitp=", end.bitp, " shift=", end.shift, "\n")
         .          .   1103:			throw("bad heapBitsSetType")
         .          .   1104:		}
         .          .   1105:
         .          .   1106:		// Double-check that bits to be written were written correctly.
         .          .   1107:		// Does not check that other bits were not written, unfortunately.
         .          .   1108:		h := heapBitsForAddr(x)
         .          .   1109:		nptr := typ.ptrdata / sys.PtrSize
         .          .   1110:		ndata := typ.size / sys.PtrSize
         .          .   1111:		count := dataSize / typ.size
         .          .   1112:		totalptr := ((count-1)*typ.size + typ.ptrdata) / sys.PtrSize
         .          .   1113:		for i := uintptr(0); i < size/sys.PtrSize; i++ {
         .          .   1114:			j := i % ndata
         .          .   1115:			var have, want uint8
         .          .   1116:			have = (*h.bitp >> h.shift) & (bitPointer | bitMarked)
         .          .   1117:			if i >= totalptr {
         .          .   1118:				want = 0 // deadmarker
         .          .   1119:				if typ.kind&kindGCProg != 0 && i < (totalptr+3)/4*4 {
         .          .   1120:					want = bitMarked
         .          .   1121:				}
         .          .   1122:			} else {
         .          .   1123:				if j < nptr && (*addb(ptrmask, j/8)>>(j%8))&1 != 0 {
         .          .   1124:					want |= bitPointer
         .          .   1125:				}
         .          .   1126:				if i >= 2 {
         .          .   1127:					want |= bitMarked
         .          .   1128:				} else {
         .          .   1129:					have &^= bitMarked
         .          .   1130:				}
         .          .   1131:			}
         .          .   1132:			if have != want {
         .          .   1133:				println("mismatch writing bits for", *typ._string, "x", dataSize/typ.size)
         .          .   1134:				print("typ.size=", typ.size, " typ.ptrdata=", typ.ptrdata, " dataSize=", dataSize, " size=", size, "\n")
         .          .   1135:				print("kindGCProg=", typ.kind&kindGCProg != 0, "\n")
         .          .   1136:				print("w=", w, " nw=", nw, " b=", hex(b), " nb=", nb, " hb=", hex(hb), "\n")
         .          .   1137:				h0 := heapBitsForAddr(x)
         .          .   1138:				print("initial bits h0.bitp=", h0.bitp, " h0.shift=", h0.shift, "\n")
         .          .   1139:				print("current bits h.bitp=", h.bitp, " h.shift=", h.shift, " *h.bitp=", hex(*h.bitp), "\n")
         .          .   1140:				print("ptrmask=", ptrmask, " p=", p, " endp=", endp, " endnb=", endnb, " pbits=", hex(pbits), " b=", hex(b), " nb=", nb, "\n")
         .          .   1141:				println("at word", i, "offset", i*sys.PtrSize, "have", have, "want", want)
         .          .   1142:				if typ.kind&kindGCProg != 0 {
         .          .   1143:					println("GC program:")
         .          .   1144:					dumpGCProg(addb(typ.gcdata, 4))
         .          .   1145:				}
         .          .   1146:				throw("bad heapBitsSetType")
         .          .   1147:			}
         .          .   1148:			h = h.next()
         .          .   1149:		}
         .          .   1150:		if ptrmask == debugPtrmask.data {
         .          .   1151:			unlock(&debugPtrmask.lock)
         .          .   1152:		}
         .          .   1153:	}
      40ms       40ms   1154:}
         .          .   1155:
         .          .   1156:var debugPtrmask struct {
         .          .   1157:	lock mutex
         .          .   1158:	data *byte
         .          .   1159:}
ROUTINE ======================== runtime.heapBitsSweepSpan in /home/isucon/.local/go/src/runtime/mbitmap.go
     830ms      3.19s (flat, cum)  5.73% of Total
         .          .    561:// bits for the first two words (or one for single-word objects) to typeDead
         .          .    562:// and then calls f(p), where p is the object's base address.
         .          .    563:// f is expected to add the object to a free list.
         .          .    564:// For non-free objects, heapBitsSweepSpan turns off the marked bit.
         .          .    565:func heapBitsSweepSpan(base, size, n uintptr, f func(uintptr)) {
         .       10ms    566:	h := heapBitsForSpan(base)
         .          .    567:	switch {
         .          .    568:	default:
         .          .    569:		throw("heapBitsSweepSpan")
         .          .    570:	case sys.PtrSize == 8 && size == sys.PtrSize:
         .          .    571:		// Consider mark bits in all four 2-bit entries of each bitmap byte.
         .          .    572:		bitp := h.bitp
         .          .    573:		for i := uintptr(0); i < n; i += 4 {
         .          .    574:			x := uint32(*bitp)
         .          .    575:			// Note that unlike the other size cases, we leave the pointer bits set here.
         .          .    576:			// These are initialized during initSpan when the span is created and left
         .          .    577:			// in place the whole time the span is used for pointer-sized objects.
         .          .    578:			// That lets heapBitsSetType avoid an atomic update to set the pointer bit
         .          .    579:			// during allocation.
         .          .    580:			if x&bitMarked != 0 {
         .          .    581:				x &^= bitMarked
         .          .    582:			} else {
         .          .    583:				f(base + i*sys.PtrSize)
         .          .    584:			}
         .          .    585:			if x&(bitMarked<<heapBitsShift) != 0 {
         .          .    586:				x &^= bitMarked << heapBitsShift
         .          .    587:			} else {
         .          .    588:				f(base + (i+1)*sys.PtrSize)
         .          .    589:			}
         .          .    590:			if x&(bitMarked<<(2*heapBitsShift)) != 0 {
         .          .    591:				x &^= bitMarked << (2 * heapBitsShift)
         .          .    592:			} else {
         .          .    593:				f(base + (i+2)*sys.PtrSize)
         .          .    594:			}
         .          .    595:			if x&(bitMarked<<(3*heapBitsShift)) != 0 {
         .          .    596:				x &^= bitMarked << (3 * heapBitsShift)
         .          .    597:			} else {
         .          .    598:				f(base + (i+3)*sys.PtrSize)
         .          .    599:			}
         .          .    600:			*bitp = uint8(x)
         .          .    601:			bitp = subtract1(bitp)
         .          .    602:		}
         .          .    603:
         .          .    604:	case size%(4*sys.PtrSize) == 0:
         .          .    605:		// Mark bit is in first word of each object.
         .          .    606:		// Each object starts at bit 0 of a heap bitmap byte.
         .          .    607:		bitp := h.bitp
         .          .    608:		step := size / heapBitmapScale
      10ms       10ms    609:		for i := uintptr(0); i < n; i++ {
      30ms       30ms    610:			x := uint32(*bitp)
     170ms      170ms    611:			if x&bitMarked != 0 {
      40ms       40ms    612:				x &^= bitMarked
         .          .    613:			} else {
      20ms       20ms    614:				x = 0
     160ms      2.06s    615:				f(base + i*size)
         .          .    616:			}
      30ms       30ms    617:			*bitp = uint8(x)
      70ms       70ms    618:			bitp = subtractb(bitp, step)
         .          .    619:		}
         .          .    620:
         .          .    621:	case size%(4*sys.PtrSize) == 2*sys.PtrSize:
         .          .    622:		// Mark bit is in first word of each object,
         .          .    623:		// but every other object starts halfway through a heap bitmap byte.
         .          .    624:		// Unroll loop 2x to handle alternating shift count and step size.
         .          .    625:		bitp := h.bitp
         .          .    626:		step := size / heapBitmapScale
         .          .    627:		var i uintptr
      30ms       30ms    628:		for i = uintptr(0); i < n; i += 2 {
      20ms       20ms    629:			x := uint32(*bitp)
      10ms       10ms    630:			if x&bitMarked != 0 {
      10ms       10ms    631:				x &^= bitMarked
         .          .    632:			} else {
      10ms       10ms    633:				x &^= bitMarked | bitPointer | (bitMarked|bitPointer)<<heapBitsShift
      50ms      250ms    634:				f(base + i*size)
         .          .    635:				if size > 2*sys.PtrSize {
         .          .    636:					x = 0
         .          .    637:				}
         .          .    638:			}
      10ms       10ms    639:			*bitp = uint8(x)
      50ms       50ms    640:			if i+1 >= n {
         .          .    641:				break
         .          .    642:			}
         .          .    643:			bitp = subtractb(bitp, step)
      10ms       10ms    644:			x = uint32(*bitp)
      20ms       20ms    645:			if x&(bitMarked<<(2*heapBitsShift)) != 0 {
         .          .    646:				x &^= bitMarked << (2 * heapBitsShift)
         .          .    647:			} else {
         .          .    648:				x &^= (bitMarked|bitPointer)<<(2*heapBitsShift) | (bitMarked|bitPointer)<<(3*heapBitsShift)
      30ms      280ms    649:				f(base + (i+1)*size)
         .          .    650:				if size > 2*sys.PtrSize {
         .          .    651:					*subtract1(bitp) = 0
         .          .    652:				}
         .          .    653:			}
      20ms       20ms    654:			*bitp = uint8(x)
      20ms       20ms    655:			bitp = subtractb(bitp, step+1)
         .          .    656:		}
         .          .    657:	}
      10ms       10ms    658:}
         .          .    659:
         .          .    660:// heapBitsSetType records that the new allocation [x, x+size)
         .          .    661:// holds in [x, x+dataSize) one or more values of type typ.
         .          .    662:// (The number of values is given by dataSize / typ.size.)
         .          .    663:// If dataSize < size, the fragment [x+dataSize, x+size) is
ROUTINE ======================== runtime.ifaceeq in /home/isucon/.local/go/src/runtime/alg.go
      20ms       20ms (flat, cum) 0.036% of Total
         .          .    249:	if isDirectIface(t) {
         .          .    250:		return eq(noescape(unsafe.Pointer(&x.data)), noescape(unsafe.Pointer(&y.data)))
         .          .    251:	}
         .          .    252:	return eq(x.data, y.data)
         .          .    253:}
      10ms       10ms    254:func ifaceeq(x, y iface) bool {
         .          .    255:	xtab := x.tab
         .          .    256:	if xtab != y.tab {
         .          .    257:		return false
         .          .    258:	}
         .          .    259:	if xtab == nil {
         .          .    260:		return true
         .          .    261:	}
         .          .    262:	t := xtab._type
         .          .    263:	eq := t.alg.equal
         .          .    264:	if eq == nil {
         .          .    265:		panic(errorString("comparing uncomparable type " + *t._string))
         .          .    266:	}
         .          .    267:	if isDirectIface(t) {
      10ms       10ms    268:		return eq(noescape(unsafe.Pointer(&x.data)), noescape(unsafe.Pointer(&y.data)))
         .          .    269:	}
         .          .    270:	return eq(x.data, y.data)
         .          .    271:}
         .          .    272:
         .          .    273:// Testing adapters for hash quality tests (see hash_test.go)
ROUTINE ======================== runtime.ifacethash in /home/isucon/.local/go/src/runtime/iface.go
      30ms       30ms (flat, cum) 0.054% of Total
         .          .    401:func ifacethash(i iface) uint32 {
         .          .    402:	tab := i.tab
         .          .    403:	if tab == nil {
         .          .    404:		return 0
         .          .    405:	}
      30ms       30ms    406:	return tab._type.hash
         .          .    407:}
         .          .    408:
         .          .    409:func efacethash(e eface) uint32 {
         .          .    410:	t := e._type
         .          .    411:	if t == nil {
ROUTINE ======================== runtime.indexbytebody in /home/isucon/.local/go/src/runtime/asm_amd64.s
      20ms       20ms (flat, cum) 0.036% of Total
         .          .   1896:	RET
         .          .   1897:
         .          .   1898:// handle for lengths < 16
         .          .   1899:small:
         .          .   1900:	MOVQ BX, CX
      10ms       10ms   1901:	REPN; SCASB
         .          .   1902:	JZ success
         .          .   1903:	MOVQ $-1, (R8)
         .          .   1904:	RET
         .          .   1905:
         .          .   1906:avx2:
         .          .   1907:	CMPB   runtime·support_avx2(SB), $1
         .          .   1908:	JNE no_avx2
         .          .   1909:	MOVD AX, X0
         .          .   1910:	LEAQ -32(SI)(BX*1), R11
         .          .   1911:	VPBROADCASTB  X0, Y1
         .          .   1912:avx2_loop:
         .          .   1913:	VMOVDQU (DI), Y2
         .          .   1914:	VPCMPEQB Y1, Y2, Y3
      10ms       10ms   1915:	VPTEST Y3, Y3
         .          .   1916:	JNZ avx2success
         .          .   1917:	ADDQ $32, DI
         .          .   1918:	CMPQ DI, R11
         .          .   1919:	JLT avx2_loop
         .          .   1920:	MOVQ R11, DI
ROUTINE ======================== runtime.injectglist in /home/isucon/.local/go/src/runtime/proc.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   2009:	lock(&sched.lock)
         .          .   2010:	var n int
         .          .   2011:	for n = 0; glist != nil; n++ {
         .          .   2012:		gp := glist
         .          .   2013:		glist = gp.schedlink.ptr()
         .       10ms   2014:		casgstatus(gp, _Gwaiting, _Grunnable)
         .          .   2015:		globrunqput(gp)
         .          .   2016:	}
         .          .   2017:	unlock(&sched.lock)
         .          .   2018:	for ; n != 0 && sched.npidle != 0; n-- {
         .          .   2019:		startm(nil, false)
ROUTINE ======================== runtime.interequal in /home/isucon/.local/go/src/runtime/alg.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    227:}
         .          .    228:func strequal(p, q unsafe.Pointer) bool {
         .          .    229:	return *(*string)(p) == *(*string)(q)
         .          .    230:}
         .          .    231:func interequal(p, q unsafe.Pointer) bool {
         .       10ms    232:	return ifaceeq(*(*iface)(p), *(*iface)(q))
         .          .    233:}
         .          .    234:func nilinterequal(p, q unsafe.Pointer) bool {
         .          .    235:	return efaceeq(*(*eface)(p), *(*eface)(q))
         .          .    236:}
         .          .    237:func efaceeq(x, y eface) bool {
ROUTINE ======================== runtime.interhash in /home/isucon/.local/go/src/runtime/alg.go
      20ms       20ms (flat, cum) 0.036% of Total
         .          .    151:func c128hash(p unsafe.Pointer, h uintptr) uintptr {
         .          .    152:	x := (*[2]float64)(p)
         .          .    153:	return f64hash(unsafe.Pointer(&x[1]), f64hash(unsafe.Pointer(&x[0]), h))
         .          .    154:}
         .          .    155:
      10ms       10ms    156:func interhash(p unsafe.Pointer, h uintptr) uintptr {
         .          .    157:	a := (*iface)(p)
         .          .    158:	tab := a.tab
         .          .    159:	if tab == nil {
         .          .    160:		return h
         .          .    161:	}
         .          .    162:	t := tab._type
         .          .    163:	fn := t.alg.hash
      10ms       10ms    164:	if fn == nil {
         .          .    165:		panic(errorString("hash of unhashable type " + *t._string))
         .          .    166:	}
         .          .    167:	if isDirectIface(t) {
         .          .    168:		return c1 * fn(unsafe.Pointer(&a.data), h^c0)
         .          .    169:	} else {
ROUTINE ======================== runtime.jmpdefer in /home/isucon/.local/go/src/runtime/asm_amd64.s
      70ms       70ms (flat, cum)  0.13% of Total
         .          .    519:	MOVQ	fv+0(FP), DX	// fn
         .          .    520:	MOVQ	argp+8(FP), BX	// caller sp
         .          .    521:	LEAQ	-8(BX), SP	// caller sp after CALL
         .          .    522:	SUBQ	$5, (SP)	// return to CALL again
         .          .    523:	MOVQ	0(DX), BX
      70ms       70ms    524:	JMP	BX	// but first run the deferred function
         .          .    525:
         .          .    526:// Save state of caller into g->sched. Smashes R8, R9.
         .          .    527:TEXT gosave<>(SB),NOSPLIT,$0
         .          .    528:	get_tls(R8)
         .          .    529:	MOVQ	g(R8), R8
ROUTINE ======================== runtime.largeAlloc in /home/isucon/.local/go/src/runtime/malloc.go
         0      2.72s (flat, cum)  4.89% of Total
         .          .    761:	// Deduct credit for this span allocation and sweep if
         .          .    762:	// necessary. mHeap_Alloc will also sweep npages, so this only
         .          .    763:	// pays the debt down to npage pages.
         .          .    764:	deductSweepCredit(npages*_PageSize, npages)
         .          .    765:
         .      2.68s    766:	s := mheap_.alloc(npages, 0, true, flag&_FlagNoZero == 0)
         .          .    767:	if s == nil {
         .          .    768:		throw("out of memory")
         .          .    769:	}
         .          .    770:	s.limit = uintptr(s.start)<<_PageShift + size
         .       40ms    771:	heapBitsForSpan(s.base()).initSpan(s.layout())
         .          .    772:	return s
         .          .    773:}
         .          .    774:
         .          .    775:// implementation of new builtin
         .          .    776:func newobject(typ *_type) unsafe.Pointer {
ROUTINE ======================== runtime.lock in /home/isucon/.local/go/src/runtime/lock_futex.go
      40ms      100ms (flat, cum)  0.18% of Total
         .          .     43:}
         .          .     44:
         .          .     45:func lock(l *mutex) {
         .          .     46:	gp := getg()
         .          .     47:
      20ms       20ms     48:	if gp.m.locks < 0 {
         .          .     49:		throw("runtime·lock: lock count")
         .          .     50:	}
         .          .     51:	gp.m.locks++
         .          .     52:
         .          .     53:	// Speculative grab for lock.
      20ms       80ms     54:	v := atomic.Xchg(key32(&l.key), mutex_locked)
         .          .     55:	if v == mutex_unlocked {
         .          .     56:		return
         .          .     57:	}
         .          .     58:
         .          .     59:	// wait is either MUTEX_LOCKED or MUTEX_SLEEPING
ROUTINE ======================== runtime.mProf_GC in /home/isucon/.local/go/src/runtime/mprof.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    224:}
         .          .    225:
         .          .    226:// Record that a gc just happened: all the 'recent' statistics are now real.
         .          .    227:func mProf_GC() {
         .          .    228:	lock(&proflock)
         .       20ms    229:	mprof_GC()
         .          .    230:	unlock(&proflock)
         .          .    231:}
         .          .    232:
         .          .    233:// Called by malloc to record a profiled block.
         .          .    234:func mProf_Malloc(p unsafe.Pointer, size uintptr) {
ROUTINE ======================== runtime.mProf_Malloc in /home/isucon/.local/go/src/runtime/mprof.go
         0      240ms (flat, cum)  0.43% of Total
         .          .    231:}
         .          .    232:
         .          .    233:// Called by malloc to record a profiled block.
         .          .    234:func mProf_Malloc(p unsafe.Pointer, size uintptr) {
         .          .    235:	var stk [maxStack]uintptr
         .      230ms    236:	nstk := callers(4, stk[:])
         .          .    237:	lock(&proflock)
         .          .    238:	b := stkbucket(memProfile, size, stk[:nstk], true)
         .          .    239:	mp := b.mp()
         .          .    240:	mp.recent_allocs++
         .          .    241:	mp.recent_alloc_bytes += size
         .          .    242:	unlock(&proflock)
         .          .    243:
         .          .    244:	// Setprofilebucket locks a bunch of other mutexes, so we call it outside of proflock.
         .          .    245:	// This reduces potential contention and chances of deadlocks.
         .          .    246:	// Since the object must be alive during call to mProf_Malloc,
         .          .    247:	// it's fine to do this non-atomically.
         .          .    248:	systemstack(func() {
         .          .    249:		setprofilebucket(p, b)
         .       10ms    250:	})
         .          .    251:}
         .          .    252:
         .          .    253:// Called when freeing a profiled block.
         .          .    254:func mProf_Free(b *bucket, size uintptr) {
         .          .    255:	lock(&proflock)
ROUTINE ======================== runtime.mProf_Malloc.func1 in /home/isucon/.local/go/src/runtime/mprof.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    244:	// Setprofilebucket locks a bunch of other mutexes, so we call it outside of proflock.
         .          .    245:	// This reduces potential contention and chances of deadlocks.
         .          .    246:	// Since the object must be alive during call to mProf_Malloc,
         .          .    247:	// it's fine to do this non-atomically.
         .          .    248:	systemstack(func() {
         .       10ms    249:		setprofilebucket(p, b)
         .          .    250:	})
         .          .    251:}
         .          .    252:
         .          .    253:// Called when freeing a profiled block.
         .          .    254:func mProf_Free(b *bucket, size uintptr) {
ROUTINE ======================== runtime.main in /home/isucon/.local/go/src/runtime/proc.go
         0      380ms (flat, cum)  0.68% of Total
         .          .    183:	if isarchive || islibrary {
         .          .    184:		// A program compiled with -buildmode=c-archive or c-shared
         .          .    185:		// has a main, but it is not executed.
         .          .    186:		return
         .          .    187:	}
         .      380ms    188:	main_main()
         .          .    189:	if raceenabled {
         .          .    190:		racefini()
         .          .    191:	}
         .          .    192:
         .          .    193:	// Make racy client program work: if panicking on
ROUTINE ======================== runtime.makemap in /home/isucon/.local/go/src/runtime/hashmap.go
      40ms      110ms (flat, cum)   0.2% of Total
         .          .    186:// If the compiler has determined that the map or the first bucket
         .          .    187:// can be created on the stack, h and/or bucket may be non-nil.
         .          .    188:// If h != nil, the map can be created directly in h.
         .          .    189:// If bucket != nil, bucket can be used as the first bucket.
         .          .    190:func makemap(t *maptype, hint int64, h *hmap, bucket unsafe.Pointer) *hmap {
      10ms       10ms    191:	if sz := unsafe.Sizeof(hmap{}); sz > 48 || sz != uintptr(t.hmap.size) {
         .          .    192:		println("runtime: sizeof(hmap) =", sz, ", t.hmap.size =", t.hmap.size)
         .          .    193:		throw("bad hmap size")
         .          .    194:	}
         .          .    195:
         .          .    196:	if hint < 0 || int64(int32(hint)) != hint {
         .          .    197:		panic("makemap: size out of range")
         .          .    198:		// TODO: make hint an int, then none of this nonsense
         .          .    199:	}
         .          .    200:
         .          .    201:	if !ismapkey(t.key) {
         .          .    202:		throw("runtime.makemap: unsupported map key type")
         .          .    203:	}
         .          .    204:
         .          .    205:	// check compiler's and reflect's math
         .          .    206:	if t.key.size > maxKeySize && (!t.indirectkey || t.keysize != uint8(sys.PtrSize)) ||
         .          .    207:		t.key.size <= maxKeySize && (t.indirectkey || t.keysize != uint8(t.key.size)) {
         .          .    208:		throw("key size wrong")
         .          .    209:	}
         .          .    210:	if t.elem.size > maxValueSize && (!t.indirectvalue || t.valuesize != uint8(sys.PtrSize)) ||
         .          .    211:		t.elem.size <= maxValueSize && (t.indirectvalue || t.valuesize != uint8(t.elem.size)) {
         .          .    212:		throw("value size wrong")
         .          .    213:	}
         .          .    214:
         .          .    215:	// invariants we depend on.  We should probably check these at compile time
         .          .    216:	// somewhere, but for now we'll do it here.
         .          .    217:	if t.key.align > bucketCnt {
         .          .    218:		throw("key align too big")
         .          .    219:	}
      10ms       10ms    220:	if t.elem.align > bucketCnt {
         .          .    221:		throw("value align too big")
         .          .    222:	}
         .          .    223:	if uintptr(t.key.size)%uintptr(t.key.align) != 0 {
         .          .    224:		throw("key size not a multiple of key align")
         .          .    225:	}
         .          .    226:	if uintptr(t.elem.size)%uintptr(t.elem.align) != 0 {
         .          .    227:		throw("value size not a multiple of value align")
         .          .    228:	}
         .          .    229:	if bucketCnt < 8 {
         .          .    230:		throw("bucketsize too small for proper alignment")
         .          .    231:	}
         .          .    232:	if dataOffset%uintptr(t.key.align) != 0 {
         .          .    233:		throw("need padding in bucket (key)")
         .          .    234:	}
      20ms       20ms    235:	if dataOffset%uintptr(t.elem.align) != 0 {
         .          .    236:		throw("need padding in bucket (value)")
         .          .    237:	}
         .          .    238:
         .          .    239:	// make sure zeroptr is large enough
         .       10ms    240:	mapzero(t.elem)
         .          .    241:
         .          .    242:	// find size parameter which will hold the requested # of elements
         .          .    243:	B := uint8(0)
         .          .    244:	for ; hint > bucketCnt && float32(hint) > loadFactor*float32(uintptr(1)<<B); B++ {
         .          .    245:	}
         .          .    246:
         .          .    247:	// allocate initial hash table
         .          .    248:	// if B == 0, the buckets field is allocated lazily later (in mapassign)
         .          .    249:	// If hint is large zeroing this memory could take a while.
         .          .    250:	buckets := bucket
         .          .    251:	if B != 0 {
         .          .    252:		buckets = newarray(t.bucket, uintptr(1)<<B)
         .          .    253:	}
         .          .    254:
         .          .    255:	// initialize Hmap
         .          .    256:	if h == nil {
         .       60ms    257:		h = (*hmap)(newobject(t.hmap))
         .          .    258:	}
         .          .    259:	h.count = 0
         .          .    260:	h.B = B
         .          .    261:	h.flags = 0
         .          .    262:	h.hash0 = fastrand1()
ROUTINE ======================== runtime.makeslice in /home/isucon/.local/go/src/runtime/slice.go
      90ms      2.38s (flat, cum)  4.28% of Total
         .          .     13:	len   int
         .          .     14:	cap   int
         .          .     15:}
         .          .     16:
         .          .     17:// TODO: take uintptrs instead of int64s?
      20ms       20ms     18:func makeslice(t *slicetype, len64, cap64 int64) slice {
         .          .     19:	// NOTE: The len > MaxMem/elemsize check here is not strictly necessary,
         .          .     20:	// but it produces a 'len out of range' error instead of a 'cap out of range' error
         .          .     21:	// when someone does make([]T, bignumber). 'cap out of range' is true too,
         .          .     22:	// but since the cap is only being supplied implicitly, saying len is clearer.
         .          .     23:	// See issue 4085.
         .          .     24:	len := int(len64)
      60ms       60ms     25:	if len64 < 0 || int64(len) != len64 || t.elem.size > 0 && uintptr(len) > _MaxMem/uintptr(t.elem.size) {
         .          .     26:		panic(errorString("makeslice: len out of range"))
         .          .     27:	}
         .          .     28:	cap := int(cap64)
      10ms       10ms     29:	if cap < len || int64(cap) != cap64 || t.elem.size > 0 && uintptr(cap) > _MaxMem/uintptr(t.elem.size) {
         .          .     30:		panic(errorString("makeslice: cap out of range"))
         .          .     31:	}
         .      2.29s     32:	p := newarray(t.elem, uintptr(cap))
         .          .     33:	return slice{p, len, cap}
         .          .     34:}
         .          .     35:
         .          .     36:// growslice_n is a variant of growslice that takes the number of new elements
         .          .     37:// instead of the new minimum capacity.
ROUTINE ======================== runtime.mallocgc in /home/isucon/.local/go/src/runtime/malloc.go
     3.76s     15.56s (flat, cum) 27.96% of Total
         .          .    494:)
         .          .    495:
         .          .    496:// Allocate an object of size bytes.
         .          .    497:// Small objects are allocated from the per-P cache's free lists.
         .          .    498:// Large objects (> 32 kB) are allocated straight from the heap.
     130ms      130ms    499:func mallocgc(size uintptr, typ *_type, flags uint32) unsafe.Pointer {
      20ms       20ms    500:	if gcphase == _GCmarktermination {
         .          .    501:		throw("mallocgc called with gcphase == _GCmarktermination")
         .          .    502:	}
         .          .    503:
      20ms       20ms    504:	if size == 0 {
         .          .    505:		return unsafe.Pointer(&zerobase)
         .          .    506:	}
         .          .    507:
      20ms       20ms    508:	if flags&flagNoScan == 0 && typ == nil {
         .          .    509:		throw("malloc missing type")
         .          .    510:	}
         .          .    511:
      20ms       20ms    512:	if debug.sbrk != 0 {
         .          .    513:		align := uintptr(16)
         .          .    514:		if typ != nil {
         .          .    515:			align = uintptr(typ.align)
         .          .    516:		}
         .          .    517:		return persistentalloc(size, align, &memstats.other_sys)
         .          .    518:	}
         .          .    519:
         .          .    520:	// assistG is the G to charge for this allocation, or nil if
         .          .    521:	// GC is not currently active.
         .          .    522:	var assistG *g
      20ms       20ms    523:	if gcBlackenEnabled != 0 {
         .          .    524:		// Charge the current user G for this allocation.
         .          .    525:		assistG = getg()
         .          .    526:		if assistG.m.curg != nil {
         .          .    527:			assistG = assistG.m.curg
         .          .    528:		}
         .          .    529:		// Charge the allocation against the G. We'll account
         .          .    530:		// for internal fragmentation at the end of mallocgc.
      10ms       10ms    531:		assistG.gcAssistBytes -= int64(size)
         .          .    532:
      10ms       10ms    533:		if assistG.gcAssistBytes < 0 {
         .          .    534:			// This G is in debt. Assist the GC to correct
         .          .    535:			// this before allocating. This must happen
         .          .    536:			// before disabling preemption.
         .      3.53s    537:			gcAssistAlloc(assistG)
         .          .    538:		}
         .          .    539:	}
         .          .    540:
         .          .    541:	// Set mp.mallocing to keep from being preempted by GC.
     350ms      350ms    542:	mp := acquirem()
      30ms       30ms    543:	if mp.mallocing != 0 {
         .          .    544:		throw("malloc deadlock")
         .          .    545:	}
      40ms       40ms    546:	if mp.gsignal == getg() {
         .          .    547:		throw("malloc during signal")
         .          .    548:	}
      10ms       10ms    549:	mp.mallocing = 1
         .          .    550:
      50ms       50ms    551:	shouldhelpgc := false
         .          .    552:	dataSize := size
     160ms      160ms    553:	c := gomcache()
         .          .    554:	var s *mspan
         .          .    555:	var x unsafe.Pointer
      20ms       20ms    556:	if size <= maxSmallSize {
      50ms       50ms    557:		if flags&flagNoScan != 0 && size < maxTinySize {
         .          .    558:			// Tiny allocator.
         .          .    559:			//
         .          .    560:			// Tiny allocator combines several tiny allocation requests
         .          .    561:			// into a single memory block. The resulting memory block
         .          .    562:			// is freed when all subobjects are unreachable. The subobjects
         .          .    563:			// must be FlagNoScan (don't have pointers), this ensures that
         .          .    564:			// the amount of potentially wasted memory is bounded.
         .          .    565:			//
         .          .    566:			// Size of the memory block used for combining (maxTinySize) is tunable.
         .          .    567:			// Current setting is 16 bytes, which relates to 2x worst case memory
         .          .    568:			// wastage (when all but one subobjects are unreachable).
         .          .    569:			// 8 bytes would result in no wastage at all, but provides less
         .          .    570:			// opportunities for combining.
         .          .    571:			// 32 bytes provides more opportunities for combining,
         .          .    572:			// but can lead to 4x worst case wastage.
         .          .    573:			// The best case winning is 8x regardless of block size.
         .          .    574:			//
         .          .    575:			// Objects obtained from tiny allocator must not be freed explicitly.
         .          .    576:			// So when an object will be freed explicitly, we ensure that
         .          .    577:			// its size >= maxTinySize.
         .          .    578:			//
         .          .    579:			// SetFinalizer has a special case for objects potentially coming
         .          .    580:			// from tiny allocator, it such case it allows to set finalizers
         .          .    581:			// for an inner byte of a memory block.
         .          .    582:			//
         .          .    583:			// The main targets of tiny allocator are small strings and
         .          .    584:			// standalone escaping variables. On a json benchmark
         .          .    585:			// the allocator reduces number of allocations by ~12% and
         .          .    586:			// reduces heap size by ~20%.
         .          .    587:			off := c.tinyoffset
         .          .    588:			// Align tiny pointer for required (conservative) alignment.
      30ms       30ms    589:			if size&7 == 0 {
         .          .    590:				off = round(off, 8)
         .          .    591:			} else if size&3 == 0 {
      40ms       40ms    592:				off = round(off, 4)
      10ms       10ms    593:			} else if size&1 == 0 {
         .          .    594:				off = round(off, 2)
         .          .    595:			}
      60ms       60ms    596:			if off+size <= maxTinySize && c.tiny != 0 {
         .          .    597:				// The object fits into existing tiny block.
         .          .    598:				x = unsafe.Pointer(c.tiny + off)
      10ms       10ms    599:				c.tinyoffset = off + size
         .          .    600:				c.local_tinyallocs++
      10ms       10ms    601:				mp.mallocing = 0
      10ms       10ms    602:				releasem(mp)
         .          .    603:				return x
         .          .    604:			}
         .          .    605:			// Allocate a new maxTinySize block.
      10ms       10ms    606:			s = c.alloc[tinySizeClass]
         .          .    607:			v := s.freelist
      70ms       70ms    608:			if v.ptr() == nil {
         .          .    609:				systemstack(func() {
         .          .    610:					c.refill(tinySizeClass)
         .       70ms    611:				})
         .          .    612:				shouldhelpgc = true
         .          .    613:				s = c.alloc[tinySizeClass]
         .          .    614:				v = s.freelist
         .          .    615:			}
      40ms       40ms    616:			s.freelist = v.ptr().next
         .          .    617:			s.ref++
         .          .    618:			// prefetchnta offers best performance, see change list message.
         .       40ms    619:			prefetchnta(uintptr(v.ptr().next))
         .          .    620:			x = unsafe.Pointer(v)
      60ms       60ms    621:			(*[2]uint64)(x)[0] = 0
         .          .    622:			(*[2]uint64)(x)[1] = 0
         .          .    623:			// See if we need to replace the existing tiny block with the new one
         .          .    624:			// based on amount of remaining free space.
      40ms       40ms    625:			if size < c.tinyoffset || c.tiny == 0 {
         .          .    626:				c.tiny = uintptr(x)
         .          .    627:				c.tinyoffset = size
         .          .    628:			}
         .          .    629:			size = maxTinySize
         .          .    630:		} else {
         .          .    631:			var sizeclass int8
      10ms       10ms    632:			if size <= 1024-8 {
     200ms      200ms    633:				sizeclass = size_to_class8[(size+7)>>3]
         .          .    634:			} else {
         .          .    635:				sizeclass = size_to_class128[(size-1024+127)>>7]
         .          .    636:			}
     120ms      120ms    637:			size = uintptr(class_to_size[sizeclass])
      30ms       30ms    638:			s = c.alloc[sizeclass]
     100ms      100ms    639:			v := s.freelist
     330ms      330ms    640:			if v.ptr() == nil {
      10ms       10ms    641:				systemstack(func() {
         .          .    642:					c.refill(int32(sizeclass))
         .      1.14s    643:				})
      10ms       10ms    644:				shouldhelpgc = true
         .          .    645:				s = c.alloc[sizeclass]
         .          .    646:				v = s.freelist
         .          .    647:			}
     220ms      220ms    648:			s.freelist = v.ptr().next
      90ms       90ms    649:			s.ref++
         .          .    650:			// prefetchnta offers best performance, see change list message.
      30ms      190ms    651:			prefetchnta(uintptr(v.ptr().next))
         .          .    652:			x = unsafe.Pointer(v)
      60ms       60ms    653:			if flags&flagNoZero == 0 {
     170ms      170ms    654:				v.ptr().next = 0
      50ms       50ms    655:				if size > 2*sys.PtrSize && ((*[2]uintptr)(x))[1] != 0 {
      30ms      230ms    656:					memclr(unsafe.Pointer(v), size)
         .          .    657:				}
         .          .    658:			}
         .          .    659:		}
         .          .    660:	} else {
         .          .    661:		var s *mspan
         .          .    662:		shouldhelpgc = true
         .          .    663:		systemstack(func() {
         .          .    664:			s = largeAlloc(size, uint32(flags))
         .      3.89s    665:		})
         .          .    666:		x = unsafe.Pointer(uintptr(s.start << pageShift))
         .          .    667:		size = uintptr(s.elemsize)
         .          .    668:	}
         .          .    669:
      20ms       20ms    670:	if flags&flagNoScan != 0 {
         .          .    671:		// All objects are pre-marked as noscan. Nothing to do.
         .          .    672:	} else {
         .          .    673:		// If allocating a defer+arg block, now that we've picked a malloc size
         .          .    674:		// large enough to hold everything, cut the "asked for" size down to
         .          .    675:		// just the defer header, so that the GC bitmap will record the arg block
         .          .    676:		// as containing nothing at all (as if it were unused space at the end of
         .          .    677:		// a malloc block caused by size rounding).
         .          .    678:		// The defer arg areas are scanned as part of scanstack.
      50ms       50ms    679:		if typ == deferType {
         .          .    680:			dataSize = unsafe.Sizeof(_defer{})
         .          .    681:		}
     190ms      2.66s    682:		heapBitsSetType(uintptr(x), size, dataSize, typ)
      90ms       90ms    683:		if dataSize > typ.size {
         .          .    684:			// Array allocation. If there are any
         .          .    685:			// pointers, GC has to scan to the last
         .          .    686:			// element.
         .          .    687:			if typ.ptrdata != 0 {
         .          .    688:				c.local_scan += dataSize - typ.size + typ.ptrdata
         .          .    689:			}
         .          .    690:		} else {
      60ms       60ms    691:			c.local_scan += typ.ptrdata
         .          .    692:		}
         .          .    693:
         .          .    694:		// Ensure that the stores above that initialize x to
         .          .    695:		// type-safe memory and set the heap bits occur before
         .          .    696:		// the caller can make x observable to the garbage
         .          .    697:		// collector. Otherwise, on weakly ordered machines,
         .          .    698:		// the garbage collector could follow a pointer to x,
         .          .    699:		// but see uninitialized memory or stale heap bits.
      60ms       80ms    700:		publicationBarrier()
         .          .    701:	}
         .          .    702:
         .          .    703:	// GCmarkterminate allocates black
         .          .    704:	// All slots hold nil so no scanning is needed.
         .          .    705:	// This may be racing with GC so do it atomically if there can be
         .          .    706:	// a race marking the bit.
      70ms       70ms    707:	if gcphase == _GCmarktermination || gcBlackenPromptly {
         .          .    708:		systemstack(func() {
         .          .    709:			gcmarknewobject_m(uintptr(x), size)
         .       20ms    710:		})
         .          .    711:	}
         .          .    712:
         .          .    713:	if raceenabled {
         .          .    714:		racemalloc(x, size)
         .          .    715:	}
         .          .    716:	if msanenabled {
         .          .    717:		msanmalloc(x, size)
         .          .    718:	}
         .          .    719:
      20ms       20ms    720:	mp.mallocing = 0
     180ms      180ms    721:	releasem(mp)
         .          .    722:
      10ms       10ms    723:	if debug.allocfreetrace != 0 {
         .          .    724:		tracealloc(x, size, typ)
         .          .    725:	}
         .          .    726:
      60ms       60ms    727:	if rate := MemProfileRate; rate > 0 {
      50ms       50ms    728:		if size < uintptr(rate) && int32(size) < c.next_sample {
      50ms       50ms    729:			c.next_sample -= int32(size)
         .          .    730:		} else {
         .          .    731:			mp := acquirem()
         .      260ms    732:			profilealloc(mp, x, size)
         .          .    733:			releasem(mp)
         .          .    734:		}
         .          .    735:	}
         .          .    736:
      30ms       30ms    737:	if assistG != nil {
         .          .    738:		// Account for internal fragmentation in the assist
         .          .    739:		// debt now that we know it.
         .          .    740:		assistG.gcAssistBytes -= int64(size - dataSize)
         .          .    741:	}
         .          .    742:
      10ms       10ms    743:	if shouldhelpgc && gcShouldStart(false) {
         .          .    744:		gcStart(gcBackgroundMode, false)
         .          .    745:	}
         .          .    746:
         .          .    747:	return x
         .          .    748:}
ROUTINE ======================== runtime.mallocgc.func1 in /home/isucon/.local/go/src/runtime/malloc.go
         0       60ms (flat, cum)  0.11% of Total
         .          .    605:			// Allocate a new maxTinySize block.
         .          .    606:			s = c.alloc[tinySizeClass]
         .          .    607:			v := s.freelist
         .          .    608:			if v.ptr() == nil {
         .          .    609:				systemstack(func() {
         .       60ms    610:					c.refill(tinySizeClass)
         .          .    611:				})
         .          .    612:				shouldhelpgc = true
         .          .    613:				s = c.alloc[tinySizeClass]
         .          .    614:				v = s.freelist
         .          .    615:			}
ROUTINE ======================== runtime.mallocgc.func2 in /home/isucon/.local/go/src/runtime/malloc.go
         0      760ms (flat, cum)  1.37% of Total
         .          .    637:			size = uintptr(class_to_size[sizeclass])
         .          .    638:			s = c.alloc[sizeclass]
         .          .    639:			v := s.freelist
         .          .    640:			if v.ptr() == nil {
         .          .    641:				systemstack(func() {
         .      760ms    642:					c.refill(int32(sizeclass))
         .          .    643:				})
         .          .    644:				shouldhelpgc = true
         .          .    645:				s = c.alloc[sizeclass]
         .          .    646:				v = s.freelist
         .          .    647:			}
ROUTINE ======================== runtime.mallocgc.func3 in /home/isucon/.local/go/src/runtime/malloc.go
         0      2.72s (flat, cum)  4.89% of Total
         .          .    659:		}
         .          .    660:	} else {
         .          .    661:		var s *mspan
         .          .    662:		shouldhelpgc = true
         .          .    663:		systemstack(func() {
         .      2.72s    664:			s = largeAlloc(size, uint32(flags))
         .          .    665:		})
         .          .    666:		x = unsafe.Pointer(uintptr(s.start << pageShift))
         .          .    667:		size = uintptr(s.elemsize)
         .          .    668:	}
         .          .    669:
ROUTINE ======================== runtime.mallocgc.func4 in /home/isucon/.local/go/src/runtime/malloc.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .    704:	// All slots hold nil so no scanning is needed.
         .          .    705:	// This may be racing with GC so do it atomically if there can be
         .          .    706:	// a race marking the bit.
         .          .    707:	if gcphase == _GCmarktermination || gcBlackenPromptly {
         .          .    708:		systemstack(func() {
         .       10ms    709:			gcmarknewobject_m(uintptr(x), size)
      10ms       10ms    710:		})
         .          .    711:	}
         .          .    712:
         .          .    713:	if raceenabled {
         .          .    714:		racemalloc(x, size)
         .          .    715:	}
ROUTINE ======================== runtime.mapaccess1 in /home/isucon/.local/go/src/runtime/hashmap.go
      20ms       30ms (flat, cum) 0.054% of Total
         .          .    280:		raceReadObjectPC(t.key, key, callerpc, pc)
         .          .    281:	}
         .          .    282:	if msanenabled && h != nil {
         .          .    283:		msanread(key, t.key.size)
         .          .    284:	}
      10ms       10ms    285:	if h == nil || h.count == 0 {
         .          .    286:		return atomic.Loadp(unsafe.Pointer(&zeroptr))
         .          .    287:	}
         .          .    288:	if h.flags&hashWriting != 0 {
         .          .    289:		throw("concurrent map read and map write")
         .          .    290:	}
         .          .    291:	alg := t.key.alg
         .          .    292:	hash := alg.hash(key, uintptr(h.hash0))
         .          .    293:	m := uintptr(1)<<h.B - 1
         .          .    294:	b := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))
         .          .    295:	if c := h.oldbuckets; c != nil {
         .          .    296:		oldb := (*bmap)(add(c, (hash&(m>>1))*uintptr(t.bucketsize)))
         .          .    297:		if !evacuated(oldb) {
         .          .    298:			b = oldb
         .          .    299:		}
         .          .    300:	}
         .          .    301:	top := uint8(hash >> (sys.PtrSize*8 - 8))
         .          .    302:	if top < minTopHash {
         .          .    303:		top += minTopHash
         .          .    304:	}
         .          .    305:	for {
         .          .    306:		for i := uintptr(0); i < bucketCnt; i++ {
         .          .    307:			if b.tophash[i] != top {
         .          .    308:				continue
         .          .    309:			}
         .          .    310:			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
         .          .    311:			if t.indirectkey {
         .          .    312:				k = *((*unsafe.Pointer)(k))
         .          .    313:			}
         .       10ms    314:			if alg.equal(key, k) {
         .          .    315:				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
         .          .    316:				if t.indirectvalue {
         .          .    317:					v = *((*unsafe.Pointer)(v))
         .          .    318:				}
      10ms       10ms    319:				return v
         .          .    320:			}
         .          .    321:		}
         .          .    322:		b = b.overflow(t)
         .          .    323:		if b == nil {
         .          .    324:			return atomic.Loadp(unsafe.Pointer(&zeroptr))
ROUTINE ======================== runtime.mapaccess1_faststr in /home/isucon/.local/go/src/runtime/hashmap_fast.go
      50ms       50ms (flat, cum)  0.09% of Total
         .          .    188:			return atomic.Loadp(unsafe.Pointer(&zeroptr)), false
         .          .    189:		}
         .          .    190:	}
         .          .    191:}
         .          .    192:
      10ms       10ms    193:func mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer {
         .          .    194:	if raceenabled && h != nil {
         .          .    195:		callerpc := getcallerpc(unsafe.Pointer(&t))
         .          .    196:		racereadpc(unsafe.Pointer(h), callerpc, funcPC(mapaccess1_faststr))
         .          .    197:	}
         .          .    198:	if h == nil || h.count == 0 {
         .          .    199:		return atomic.Loadp(unsafe.Pointer(&zeroptr))
         .          .    200:	}
         .          .    201:	if h.flags&hashWriting != 0 {
         .          .    202:		throw("concurrent map read and map write")
         .          .    203:	}
         .          .    204:	key := stringStructOf(&ky)
         .          .    205:	if h.B == 0 {
         .          .    206:		// One-bucket table.
         .          .    207:		b := (*bmap)(h.buckets)
         .          .    208:		if key.len < 32 {
         .          .    209:			// short key, doing lots of comparisons is ok
         .          .    210:			for i := uintptr(0); i < bucketCnt; i++ {
         .          .    211:				x := *((*uint8)(add(unsafe.Pointer(b), i))) // b.topbits[i] without the bounds check
         .          .    212:				if x == empty {
         .          .    213:					continue
         .          .    214:				}
         .          .    215:				k := (*stringStruct)(add(unsafe.Pointer(b), dataOffset+i*2*sys.PtrSize))
      10ms       10ms    216:				if k.len != key.len {
         .          .    217:					continue
         .          .    218:				}
         .          .    219:				if k.str == key.str || memeq(k.str, key.str, uintptr(key.len)) {
         .          .    220:					return add(unsafe.Pointer(b), dataOffset+bucketCnt*2*sys.PtrSize+i*uintptr(t.valuesize))
         .          .    221:				}
         .          .    222:			}
      10ms       10ms    223:			return atomic.Loadp(unsafe.Pointer(&zeroptr))
         .          .    224:		}
         .          .    225:		// long key, try not to do more comparisons than necessary
         .          .    226:		keymaybe := uintptr(bucketCnt)
         .          .    227:		for i := uintptr(0); i < bucketCnt; i++ {
         .          .    228:			x := *((*uint8)(add(unsafe.Pointer(b), i))) // b.topbits[i] without the bounds check
         .          .    229:			if x == empty {
         .          .    230:				continue
         .          .    231:			}
         .          .    232:			k := (*stringStruct)(add(unsafe.Pointer(b), dataOffset+i*2*sys.PtrSize))
         .          .    233:			if k.len != key.len {
         .          .    234:				continue
         .          .    235:			}
         .          .    236:			if k.str == key.str {
         .          .    237:				return add(unsafe.Pointer(b), dataOffset+bucketCnt*2*sys.PtrSize+i*uintptr(t.valuesize))
         .          .    238:			}
         .          .    239:			// check first 4 bytes
         .          .    240:			// TODO: on amd64/386 at least, make this compile to one 4-byte comparison instead of
         .          .    241:			// four 1-byte comparisons.
         .          .    242:			if *((*[4]byte)(key.str)) != *((*[4]byte)(k.str)) {
         .          .    243:				continue
         .          .    244:			}
         .          .    245:			// check last 4 bytes
         .          .    246:			if *((*[4]byte)(add(key.str, uintptr(key.len)-4))) != *((*[4]byte)(add(k.str, uintptr(key.len)-4))) {
         .          .    247:				continue
         .          .    248:			}
         .          .    249:			if keymaybe != bucketCnt {
         .          .    250:				// Two keys are potential matches.  Use hash to distinguish them.
         .          .    251:				goto dohash
         .          .    252:			}
         .          .    253:			keymaybe = i
         .          .    254:		}
         .          .    255:		if keymaybe != bucketCnt {
         .          .    256:			k := (*stringStruct)(add(unsafe.Pointer(b), dataOffset+keymaybe*2*sys.PtrSize))
         .          .    257:			if memeq(k.str, key.str, uintptr(key.len)) {
         .          .    258:				return add(unsafe.Pointer(b), dataOffset+bucketCnt*2*sys.PtrSize+keymaybe*uintptr(t.valuesize))
         .          .    259:			}
         .          .    260:		}
         .          .    261:		return atomic.Loadp(unsafe.Pointer(&zeroptr))
         .          .    262:	}
         .          .    263:dohash:
         .          .    264:	hash := t.key.alg.hash(noescape(unsafe.Pointer(&ky)), uintptr(h.hash0))
         .          .    265:	m := uintptr(1)<<h.B - 1
         .          .    266:	b := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))
         .          .    267:	if c := h.oldbuckets; c != nil {
         .          .    268:		oldb := (*bmap)(add(c, (hash&(m>>1))*uintptr(t.bucketsize)))
         .          .    269:		if !evacuated(oldb) {
         .          .    270:			b = oldb
         .          .    271:		}
         .          .    272:	}
      10ms       10ms    273:	top := uint8(hash >> (sys.PtrSize*8 - 8))
         .          .    274:	if top < minTopHash {
         .          .    275:		top += minTopHash
         .          .    276:	}
         .          .    277:	for {
         .          .    278:		for i := uintptr(0); i < bucketCnt; i++ {
         .          .    279:			x := *((*uint8)(add(unsafe.Pointer(b), i))) // b.topbits[i] without the bounds check
      10ms       10ms    280:			if x != top {
         .          .    281:				continue
         .          .    282:			}
         .          .    283:			k := (*stringStruct)(add(unsafe.Pointer(b), dataOffset+i*2*sys.PtrSize))
         .          .    284:			if k.len != key.len {
         .          .    285:				continue
ROUTINE ======================== runtime.mapaccess2 in /home/isucon/.local/go/src/runtime/hashmap.go
      40ms       70ms (flat, cum)  0.13% of Total
         .          .    340:		return atomic.Loadp(unsafe.Pointer(&zeroptr)), false
         .          .    341:	}
         .          .    342:	if h.flags&hashWriting != 0 {
         .          .    343:		throw("concurrent map read and map write")
         .          .    344:	}
      10ms       10ms    345:	alg := t.key.alg
      30ms       50ms    346:	hash := alg.hash(key, uintptr(h.hash0))
         .          .    347:	m := uintptr(1)<<h.B - 1
         .          .    348:	b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + (hash&m)*uintptr(t.bucketsize)))
         .          .    349:	if c := h.oldbuckets; c != nil {
         .          .    350:		oldb := (*bmap)(unsafe.Pointer(uintptr(c) + (hash&(m>>1))*uintptr(t.bucketsize)))
         .          .    351:		if !evacuated(oldb) {
         .          .    352:			b = oldb
         .          .    353:		}
         .          .    354:	}
         .          .    355:	top := uint8(hash >> (sys.PtrSize*8 - 8))
         .          .    356:	if top < minTopHash {
         .          .    357:		top += minTopHash
         .          .    358:	}
         .          .    359:	for {
         .          .    360:		for i := uintptr(0); i < bucketCnt; i++ {
         .          .    361:			if b.tophash[i] != top {
         .          .    362:				continue
         .          .    363:			}
         .          .    364:			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
         .          .    365:			if t.indirectkey {
         .          .    366:				k = *((*unsafe.Pointer)(k))
         .          .    367:			}
         .       10ms    368:			if alg.equal(key, k) {
         .          .    369:				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
         .          .    370:				if t.indirectvalue {
         .          .    371:					v = *((*unsafe.Pointer)(v))
         .          .    372:				}
         .          .    373:				return v, true
ROUTINE ======================== runtime.mapaccess2_fast64 in /home/isucon/.local/go/src/runtime/hashmap_fast.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    159:	var b *bmap
         .          .    160:	if h.B == 0 {
         .          .    161:		// One-bucket table.  No need to hash.
         .          .    162:		b = (*bmap)(h.buckets)
         .          .    163:	} else {
         .       10ms    164:		hash := t.key.alg.hash(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))
         .          .    165:		m := uintptr(1)<<h.B - 1
         .          .    166:		b = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))
         .          .    167:		if c := h.oldbuckets; c != nil {
         .          .    168:			oldb := (*bmap)(add(c, (hash&(m>>1))*uintptr(t.bucketsize)))
         .          .    169:			if !evacuated(oldb) {
ROUTINE ======================== runtime.mapaccess2_faststr in /home/isucon/.local/go/src/runtime/hashmap_fast.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    362:			}
         .          .    363:		}
         .          .    364:		return atomic.Loadp(unsafe.Pointer(&zeroptr)), false
         .          .    365:	}
         .          .    366:dohash:
         .       10ms    367:	hash := t.key.alg.hash(noescape(unsafe.Pointer(&ky)), uintptr(h.hash0))
         .          .    368:	m := uintptr(1)<<h.B - 1
         .          .    369:	b := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))
         .          .    370:	if c := h.oldbuckets; c != nil {
         .          .    371:		oldb := (*bmap)(add(c, (hash&(m>>1))*uintptr(t.bucketsize)))
         .          .    372:		if !evacuated(oldb) {
         .          .    373:			b = oldb
         .          .    374:		}
         .          .    375:	}
         .          .    376:	top := uint8(hash >> (sys.PtrSize*8 - 8))
         .          .    377:	if top < minTopHash {
         .          .    378:		top += minTopHash
         .          .    379:	}
         .          .    380:	for {
         .          .    381:		for i := uintptr(0); i < bucketCnt; i++ {
         .          .    382:			x := *((*uint8)(add(unsafe.Pointer(b), i))) // b.topbits[i] without the bounds check
         .          .    383:			if x != top {
         .          .    384:				continue
         .          .    385:			}
         .          .    386:			k := (*stringStruct)(add(unsafe.Pointer(b), dataOffset+i*2*sys.PtrSize))
         .          .    387:			if k.len != key.len {
         .          .    388:				continue
         .          .    389:			}
         .       10ms    390:			if k.str == key.str || memeq(k.str, key.str, uintptr(key.len)) {
         .          .    391:				return add(unsafe.Pointer(b), dataOffset+bucketCnt*2*sys.PtrSize+i*uintptr(t.valuesize)), true
         .          .    392:			}
         .          .    393:		}
         .          .    394:		b = b.overflow(t)
         .          .    395:		if b == nil {
ROUTINE ======================== runtime.mapassign1 in /home/isucon/.local/go/src/runtime/hashmap.go
      60ms      240ms (flat, cum)  0.43% of Total
         .          .    439:	}
         .          .    440:	if msanenabled {
         .          .    441:		msanread(key, t.key.size)
         .          .    442:		msanread(val, t.elem.size)
         .          .    443:	}
      10ms       10ms    444:	if h.flags&hashWriting != 0 {
         .          .    445:		throw("concurrent map writes")
         .          .    446:	}
      10ms       10ms    447:	h.flags |= hashWriting
         .          .    448:
         .          .    449:	alg := t.key.alg
      20ms       50ms    450:	hash := alg.hash(key, uintptr(h.hash0))
         .          .    451:
         .          .    452:	if h.buckets == nil {
         .       20ms    453:		h.buckets = newarray(t.bucket, 1)
         .          .    454:	}
         .          .    455:
         .          .    456:again:
         .          .    457:	bucket := hash & (uintptr(1)<<h.B - 1)
         .          .    458:	if h.oldbuckets != nil {
         .       30ms    459:		growWork(t, h, bucket)
         .          .    460:	}
         .          .    461:	b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize)))
         .          .    462:	top := uint8(hash >> (sys.PtrSize*8 - 8))
         .          .    463:	if top < minTopHash {
         .          .    464:		top += minTopHash
         .          .    465:	}
         .          .    466:
         .          .    467:	var inserti *uint8
         .          .    468:	var insertk unsafe.Pointer
         .          .    469:	var insertv unsafe.Pointer
         .          .    470:	for {
         .          .    471:		for i := uintptr(0); i < bucketCnt; i++ {
      20ms       20ms    472:			if b.tophash[i] != top {
         .          .    473:				if b.tophash[i] == empty && inserti == nil {
         .          .    474:					inserti = &b.tophash[i]
         .          .    475:					insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
         .          .    476:					insertv = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
         .          .    477:				}
         .          .    478:				continue
         .          .    479:			}
         .          .    480:			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
         .          .    481:			k2 := k
         .          .    482:			if t.indirectkey {
         .          .    483:				k2 = *((*unsafe.Pointer)(k2))
         .          .    484:			}
         .          .    485:			if !alg.equal(key, k2) {
         .          .    486:				continue
         .          .    487:			}
         .          .    488:			// already have a mapping for key.  Update it.
         .          .    489:			if t.needkeyupdate {
         .          .    490:				typedmemmove(t.key, k2, key)
         .          .    491:			}
         .          .    492:			v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))
         .          .    493:			v2 := v
         .          .    494:			if t.indirectvalue {
         .          .    495:				v2 = *((*unsafe.Pointer)(v2))
         .          .    496:			}
         .          .    497:			typedmemmove(t.elem, v2, val)
         .          .    498:			goto done
         .          .    499:		}
         .          .    500:		ovf := b.overflow(t)
         .          .    501:		if ovf == nil {
         .          .    502:			break
         .          .    503:		}
         .          .    504:		b = ovf
         .          .    505:	}
         .          .    506:
         .          .    507:	// did not find mapping for key.  Allocate new cell & add entry.
         .          .    508:	if float32(h.count) >= loadFactor*float32((uintptr(1)<<h.B)) && h.count >= bucketCnt {
         .       50ms    509:		hashGrow(t, h)
         .          .    510:		goto again // Growing the table invalidates everything, so try again
         .          .    511:	}
         .          .    512:
         .          .    513:	if inserti == nil {
         .          .    514:		// all current buckets are full, allocate a new one.
         .          .    515:		newb := (*bmap)(newobject(t.bucket))
         .          .    516:		h.setoverflow(t, b, newb)
         .          .    517:		inserti = &newb.tophash[0]
         .          .    518:		insertk = add(unsafe.Pointer(newb), dataOffset)
         .          .    519:		insertv = add(insertk, bucketCnt*uintptr(t.keysize))
         .          .    520:	}
         .          .    521:
         .          .    522:	// store new key/value at insert position
         .          .    523:	if t.indirectkey {
         .          .    524:		kmem := newobject(t.key)
         .          .    525:		*(*unsafe.Pointer)(insertk) = kmem
         .          .    526:		insertk = kmem
         .          .    527:	}
         .          .    528:	if t.indirectvalue {
         .          .    529:		vmem := newobject(t.elem)
         .          .    530:		*(*unsafe.Pointer)(insertv) = vmem
         .          .    531:		insertv = vmem
         .          .    532:	}
         .       30ms    533:	typedmemmove(t.key, insertk, key)
         .       20ms    534:	typedmemmove(t.elem, insertv, val)
         .          .    535:	*inserti = top
         .          .    536:	h.count++
         .          .    537:
         .          .    538:done:
         .          .    539:	if h.flags&hashWriting == 0 {
ROUTINE ======================== runtime.mapdelete in /home/isucon/.local/go/src/runtime/hashmap.go
      20ms       40ms (flat, cum) 0.072% of Total
         .          .    556:		return
         .          .    557:	}
         .          .    558:	if h.flags&hashWriting != 0 {
         .          .    559:		throw("concurrent map writes")
         .          .    560:	}
      10ms       10ms    561:	h.flags |= hashWriting
         .          .    562:
         .          .    563:	alg := t.key.alg
      10ms       20ms    564:	hash := alg.hash(key, uintptr(h.hash0))
         .          .    565:	bucket := hash & (uintptr(1)<<h.B - 1)
         .          .    566:	if h.oldbuckets != nil {
         .          .    567:		growWork(t, h, bucket)
         .          .    568:	}
         .          .    569:	b := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize)))
         .          .    570:	top := uint8(hash >> (sys.PtrSize*8 - 8))
         .          .    571:	if top < minTopHash {
         .          .    572:		top += minTopHash
         .          .    573:	}
         .          .    574:	for {
         .          .    575:		for i := uintptr(0); i < bucketCnt; i++ {
         .          .    576:			if b.tophash[i] != top {
         .          .    577:				continue
         .          .    578:			}
         .          .    579:			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))
         .          .    580:			k2 := k
         .          .    581:			if t.indirectkey {
         .          .    582:				k2 = *((*unsafe.Pointer)(k2))
         .          .    583:			}
         .       10ms    584:			if !alg.equal(key, k2) {
         .          .    585:				continue
         .          .    586:			}
         .          .    587:			memclr(k, uintptr(t.keysize))
         .          .    588:			v := unsafe.Pointer(uintptr(unsafe.Pointer(b)) + dataOffset + bucketCnt*uintptr(t.keysize) + i*uintptr(t.valuesize))
         .          .    589:			memclr(v, uintptr(t.valuesize))
ROUTINE ======================== runtime.mapiterinit in /home/isucon/.local/go/src/runtime/hashmap.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    661:	// Can run concurrently with another hash_iter_init().
         .          .    662:	if old := h.flags; old&(iterator|oldIterator) != iterator|oldIterator {
         .          .    663:		atomic.Or8(&h.flags, iterator|oldIterator)
         .          .    664:	}
         .          .    665:
         .       10ms    666:	mapiternext(it)
         .          .    667:}
         .          .    668:
         .          .    669:func mapiternext(it *hiter) {
         .          .    670:	h := it.h
         .          .    671:	if raceenabled {
ROUTINE ======================== runtime.mapiternext in /home/isucon/.local/go/src/runtime/hashmap.go
      30ms       40ms (flat, cum) 0.072% of Total
         .          .    710:			it.wrapped = true
         .          .    711:		}
         .          .    712:		i = 0
         .          .    713:	}
         .          .    714:	for ; i < bucketCnt; i++ {
      10ms       10ms    715:		offi := (i + it.offset) & (bucketCnt - 1)
         .          .    716:		k := add(unsafe.Pointer(b), dataOffset+uintptr(offi)*uintptr(t.keysize))
      10ms       10ms    717:		v := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+uintptr(offi)*uintptr(t.valuesize))
         .          .    718:		if b.tophash[offi] != empty && b.tophash[offi] != evacuatedEmpty {
         .          .    719:			if checkBucket != noCheck {
         .          .    720:				// Special case: iterator was started during a grow and the
         .          .    721:				// grow is not done yet.  We're working on a bucket whose
         .          .    722:				// oldbucket has not been evacuated yet.  Or at least, it wasn't
         .          .    723:				// evacuated when we started the bucket.  So we're iterating
         .          .    724:				// through the oldbucket, skipping any keys that will go
         .          .    725:				// to the other new bucket (each oldbucket expands to two
         .          .    726:				// buckets during a grow).
         .          .    727:				k2 := k
         .          .    728:				if t.indirectkey {
         .          .    729:					k2 = *((*unsafe.Pointer)(k2))
         .          .    730:				}
         .          .    731:				if t.reflexivekey || alg.equal(k2, k2) {
         .          .    732:					// If the item in the oldbucket is not destined for
         .          .    733:					// the current new bucket in the iteration, skip it.
         .          .    734:					hash := alg.hash(k2, uintptr(h.hash0))
         .          .    735:					if hash&(uintptr(1)<<it.B-1) != checkBucket {
         .          .    736:						continue
         .          .    737:					}
         .          .    738:				} else {
         .          .    739:					// Hash isn't repeatable if k != k (NaNs).  We need a
         .          .    740:					// repeatable and randomish choice of which direction
         .          .    741:					// to send NaNs during evacuation.  We'll use the low
         .          .    742:					// bit of tophash to decide which way NaNs go.
         .          .    743:					// NOTE: this case is why we need two evacuate tophash
         .          .    744:					// values, evacuatedX and evacuatedY, that differ in
         .          .    745:					// their low bit.
         .          .    746:					if checkBucket>>(it.B-1) != uintptr(b.tophash[offi]&1) {
         .          .    747:						continue
         .          .    748:					}
         .          .    749:				}
         .          .    750:			}
         .          .    751:			if b.tophash[offi] != evacuatedX && b.tophash[offi] != evacuatedY {
         .          .    752:				// this is the golden data, we can return it.
         .          .    753:				if t.indirectkey {
         .          .    754:					k = *((*unsafe.Pointer)(k))
         .          .    755:				}
         .          .    756:				it.key = k
         .          .    757:				if t.indirectvalue {
         .          .    758:					v = *((*unsafe.Pointer)(v))
         .          .    759:				}
         .          .    760:				it.value = v
         .          .    761:			} else {
         .          .    762:				// The hash table has grown since the iterator was started.
         .          .    763:				// The golden data for this key is now somewhere else.
         .          .    764:				k2 := k
         .          .    765:				if t.indirectkey {
         .          .    766:					k2 = *((*unsafe.Pointer)(k2))
         .          .    767:				}
         .          .    768:				if t.reflexivekey || alg.equal(k2, k2) {
         .          .    769:					// Check the current hash table for the data.
         .          .    770:					// This code handles the case where the key
         .          .    771:					// has been deleted, updated, or deleted and reinserted.
         .          .    772:					// NOTE: we need to regrab the key as it has potentially been
         .          .    773:					// updated to an equal() but not identical key (e.g. +0.0 vs -0.0).
         .          .    774:					rk, rv := mapaccessK(t, h, k2)
         .          .    775:					if rk == nil {
         .          .    776:						continue // key has been deleted
         .          .    777:					}
         .          .    778:					it.key = rk
         .          .    779:					it.value = rv
         .          .    780:				} else {
         .          .    781:					// if key!=key then the entry can't be deleted or
         .          .    782:					// updated, so we can just return it.  That's lucky for
         .          .    783:					// us because when key!=key we can't look it up
         .          .    784:					// successfully in the current table.
         .          .    785:					it.key = k2
         .          .    786:					if t.indirectvalue {
         .          .    787:						v = *((*unsafe.Pointer)(v))
         .          .    788:					}
         .          .    789:					it.value = v
         .          .    790:				}
         .          .    791:			}
         .          .    792:			it.bucket = bucket
         .       10ms    793:			it.bptr = b
         .          .    794:			it.i = i + 1
         .          .    795:			it.checkBucket = checkBucket
      10ms       10ms    796:			return
         .          .    797:		}
         .          .    798:	}
         .          .    799:	b = b.overflow(t)
         .          .    800:	i = 0
         .          .    801:	goto next
ROUTINE ======================== runtime.mapzero in /home/isucon/.local/go/src/runtime/hashmap.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .   1053:var zeroptr unsafe.Pointer = unsafe.Pointer(&zeroinitial)
         .          .   1054:var zerosize uintptr = initialZeroSize
         .          .   1055:
         .          .   1056:// mapzero ensures that zeroptr points to a buffer large enough to
         .          .   1057:// serve as the zero value for t.
      10ms       10ms   1058:func mapzero(t *_type) {
         .          .   1059:	// Is the type small enough for existing buffer?
         .          .   1060:	cursize := uintptr(atomic.Loadp(unsafe.Pointer(&zerosize)))
         .          .   1061:	if t.size <= cursize {
         .          .   1062:		return
         .          .   1063:	}
ROUTINE ======================== runtime.markroot in /home/isucon/.local/go/src/runtime/mgcmark.go
         0      1.11s (flat, cum)  1.99% of Total
         .          .    109:
         .          .    110:	// Note: if you add a case here, please also update heapdump.go:dumproots.
         .          .    111:	switch {
         .          .    112:	case baseData <= i && i < baseBSS:
         .          .    113:		for datap := &firstmoduledata; datap != nil; datap = datap.next {
         .       20ms    114:			markrootBlock(datap.data, datap.edata-datap.data, datap.gcdatamask.bytedata, &gcw, int(i-baseData))
         .          .    115:		}
         .          .    116:
         .          .    117:	case baseBSS <= i && i < baseSpans:
         .          .    118:		for datap := &firstmoduledata; datap != nil; datap = datap.next {
         .       30ms    119:			markrootBlock(datap.bss, datap.ebss-datap.bss, datap.gcbssmask.bytedata, &gcw, int(i-baseBSS))
         .          .    120:		}
         .          .    121:
         .          .    122:	case i == fixedRootFinalizers:
         .          .    123:		for fb := allfin; fb != nil; fb = fb.alllink {
         .          .    124:			scanblock(uintptr(unsafe.Pointer(&fb.fin[0])), uintptr(fb.cnt)*unsafe.Sizeof(fb.fin[0]), &finptrmask[0], &gcw)
         .          .    125:		}
         .          .    126:
         .          .    127:	case i == fixedRootFlushCaches:
         .          .    128:		if gcphase == _GCmarktermination { // Do not flush mcaches during concurrent phase.
         .       10ms    129:			flushallmcaches()
         .          .    130:		}
         .          .    131:
         .          .    132:	case baseSpans <= i && i < baseStacks:
         .          .    133:		// mark MSpan.specials
         .       20ms    134:		markrootSpans(&gcw, int(i-baseSpans))
         .          .    135:
         .          .    136:	default:
         .          .    137:		// the rest is scanning goroutine stacks
         .          .    138:		if uintptr(i-baseStacks) >= allglen {
         .          .    139:			throw("markroot: bad index")
         .          .    140:		}
         .          .    141:		gp := allgs[i-baseStacks]
         .          .    142:
         .          .    143:		// remember when we've first observed the G blocked
         .          .    144:		// needed only to output in traceback
         .       10ms    145:		status := readgstatus(gp) // We are not in a scan state
         .          .    146:		if (status == _Gwaiting || status == _Gsyscall) && gp.waitsince == 0 {
         .          .    147:			gp.waitsince = work.tstart
         .          .    148:		}
         .          .    149:
         .          .    150:		// Shrink a stack if not much of it is being used but not in the scan phase.
         .          .    151:		if gcphase == _GCmarktermination {
         .          .    152:			// Shrink during STW GCmarktermination phase thus avoiding
         .          .    153:			// complications introduced by shrinking during
         .          .    154:			// non-STW phases.
         .          .    155:			shrinkstack(gp)
         .          .    156:		}
         .          .    157:
         .          .    158:		if gcphase != _GCmarktermination && gp.startpc == gcBgMarkWorkerPC {
         .          .    159:			// GC background workers may be
         .          .    160:			// non-preemptible, so we may deadlock if we
         .          .    161:			// try to scan them during a concurrent phase.
         .          .    162:			// They also have tiny stacks, so just ignore
         .          .    163:			// them until mark termination.
         .          .    164:			gp.gcscandone = true
         .          .    165:			break
         .          .    166:		}
         .          .    167:
         .          .    168:		// scang must be done on the system stack in case
         .          .    169:		// we're trying to scan our own stack.
         .          .    170:		systemstack(func() {
         .          .    171:			// If this is a self-scan, put the user G in
         .          .    172:			// _Gwaiting to prevent self-deadlock. It may
         .          .    173:			// already be in _Gwaiting if this is mark
         .          .    174:			// termination.
         .          .    175:			userG := getg().m.curg
         .          .    176:			selfScan := gp == userG && readgstatus(userG) == _Grunning
         .          .    177:			if selfScan {
         .          .    178:				casgstatus(userG, _Grunning, _Gwaiting)
         .          .    179:				userG.waitreason = "garbage collection scan"
         .          .    180:			}
         .          .    181:
         .          .    182:			// TODO: scang blocks until gp's stack has
         .          .    183:			// been scanned, which may take a while for
         .          .    184:			// running goroutines. Consider doing this in
         .          .    185:			// two phases where the first is non-blocking:
         .          .    186:			// we scan the stacks we can and ask running
         .          .    187:			// goroutines to scan themselves; and the
         .          .    188:			// second blocks.
         .          .    189:			scang(gp)
         .          .    190:
         .          .    191:			if selfScan {
         .          .    192:				casgstatus(userG, _Gwaiting, _Grunning)
         .          .    193:			}
         .      1.02s    194:		})
         .          .    195:	}
         .          .    196:
         .          .    197:	gcw.dispose()
         .          .    198:}
         .          .    199:
ROUTINE ======================== runtime.markroot.func1 in /home/isucon/.local/go/src/runtime/mgcmark.go
         0      1.05s (flat, cum)  1.89% of Total
         .          .    184:			// running goroutines. Consider doing this in
         .          .    185:			// two phases where the first is non-blocking:
         .          .    186:			// we scan the stacks we can and ask running
         .          .    187:			// goroutines to scan themselves; and the
         .          .    188:			// second blocks.
         .      1.05s    189:			scang(gp)
         .          .    190:
         .          .    191:			if selfScan {
         .          .    192:				casgstatus(userG, _Gwaiting, _Grunning)
         .          .    193:			}
         .          .    194:		})
ROUTINE ======================== runtime.markrootBlock in /home/isucon/.local/go/src/runtime/mgcmark.go
         0       50ms (flat, cum)  0.09% of Total
         .          .    216:	if b+n > b0+n0 {
         .          .    217:		n = b0 + n0 - b
         .          .    218:	}
         .          .    219:
         .          .    220:	// Scan this shard.
         .       50ms    221:	scanblock(b, n, ptrmask, gcw)
         .          .    222:}
         .          .    223:
         .          .    224:// markrootSpans marks roots for one shard of work.spans.
         .          .    225://
         .          .    226://go:nowritebarrier
ROUTINE ======================== runtime.markrootSpans in /home/isucon/.local/go/src/runtime/mgcmark.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    296:			p := uintptr(s.start<<_PageShift) + uintptr(spf.special.offset)/s.elemsize*s.elemsize
         .          .    297:
         .          .    298:			// Mark everything that can be reached from
         .          .    299:			// the object (but *not* the object itself or
         .          .    300:			// we'll never collect it).
         .       20ms    301:			scanobject(p, gcw)
         .          .    302:
         .          .    303:			// The special itself is a root.
         .          .    304:			scanblock(uintptr(unsafe.Pointer(&spf.fn)), sys.PtrSize, &oneptrmask[0], gcw)
         .          .    305:		}
         .          .    306:
ROUTINE ======================== runtime.mcall in /home/isucon/.local/go/src/runtime/asm_amd64.s
      20ms      260ms (flat, cum)  0.47% of Total
         .          .    204:// func mcall(fn func(*g))
         .          .    205:// Switch to m->g0's stack, call fn(g).
         .          .    206:// Fn must never return.  It should gogo(&g->sched)
         .          .    207:// to keep running g.
         .          .    208:TEXT runtime·mcall(SB), NOSPLIT, $0-8
      10ms       10ms    209:	MOVQ	fn+0(FP), DI
         .          .    210:	
         .          .    211:	get_tls(CX)
         .          .    212:	MOVQ	g(CX), AX	// save state in g->sched
         .          .    213:	MOVQ	0(SP), BX	// caller's PC
         .          .    214:	MOVQ	BX, (g_sched+gobuf_pc)(AX)
         .          .    215:	LEAQ	fn+0(FP), BX	// caller's SP
         .          .    216:	MOVQ	BX, (g_sched+gobuf_sp)(AX)
         .          .    217:	MOVQ	AX, (g_sched+gobuf_g)(AX)
         .          .    218:	MOVQ	BP, (g_sched+gobuf_bp)(AX)
         .          .    219:
         .          .    220:	// switch to m->g0 & its stack, call fn
         .          .    221:	MOVQ	g(CX), BX
         .          .    222:	MOVQ	g_m(BX), BX
         .          .    223:	MOVQ	m_g0(BX), SI
         .          .    224:	CMPQ	SI, AX	// if g == m->g0 call badmcall
         .          .    225:	JNE	3(PC)
         .          .    226:	MOVQ	$runtime·badmcall(SB), AX
         .          .    227:	JMP	AX
         .          .    228:	MOVQ	SI, g(CX)	// g = m->g0
         .          .    229:	MOVQ	(g_sched+gobuf_sp)(SI), SP	// sp = m->g0->sched.sp
      10ms       10ms    230:	PUSHQ	AX
         .          .    231:	MOVQ	DI, DX
         .          .    232:	MOVQ	0(DI), DI
         .      240ms    233:	CALL	DI
         .          .    234:	POPQ	AX
         .          .    235:	MOVQ	$runtime·badmcall2(SB), AX
         .          .    236:	JMP	AX
         .          .    237:	RET
         .          .    238:
ROUTINE ======================== runtime.memclr in /home/isucon/.local/go/src/runtime/memclr_amd64.s
     3.26s      3.26s (flat, cum)  5.86% of Total
         .          .      8:
         .          .      9:// NOTE: Windows externalthreadhandler expects memclr to preserve DX.
         .          .     10:
         .          .     11:// void runtime·memclr(void*, uintptr)
         .          .     12:TEXT runtime·memclr(SB), NOSPLIT, $0-16
      20ms       20ms     13:	MOVQ	ptr+0(FP), DI
         .          .     14:	MOVQ	n+8(FP), BX
      20ms       20ms     15:	XORQ	AX, AX
         .          .     16:
         .          .     17:	// MOVOU seems always faster than REP STOSQ.
         .          .     18:tail:
         .          .     19:	TESTQ	BX, BX
         .          .     20:	JEQ	_0
         .          .     21:	CMPQ	BX, $2
         .          .     22:	JBE	_1or2
         .          .     23:	CMPQ	BX, $4
         .          .     24:	JBE	_3or4
      10ms       10ms     25:	CMPQ	BX, $8
         .          .     26:	JB	_5through7
      10ms       10ms     27:	JE	_8
      10ms       10ms     28:	CMPQ	BX, $16
         .          .     29:	JBE	_9through16
         .          .     30:	PXOR	X0, X0
      20ms       20ms     31:	CMPQ	BX, $32
         .          .     32:	JBE	_17through32
      10ms       10ms     33:	CMPQ	BX, $64
         .          .     34:	JBE	_33through64
         .          .     35:	CMPQ	BX, $128
         .          .     36:	JBE	_65through128
      10ms       10ms     37:	CMPQ	BX, $256
         .          .     38:	JBE	_129through256
         .          .     39:	CMPB	runtime·support_avx2(SB), $1
         .          .     40:	JE loop_preheader_avx2
         .          .     41:	// TODO: use branch table and BSR to make this just a single dispatch
         .          .     42:	// TODO: for really big clears, use MOVNTDQ, even without AVX2.
         .          .     43:
         .          .     44:loop:
         .          .     45:	MOVOU	X0, 0(DI)
         .          .     46:	MOVOU	X0, 16(DI)
         .          .     47:	MOVOU	X0, 32(DI)
         .          .     48:	MOVOU	X0, 48(DI)
         .          .     49:	MOVOU	X0, 64(DI)
         .          .     50:	MOVOU	X0, 80(DI)
         .          .     51:	MOVOU	X0, 96(DI)
         .          .     52:	MOVOU	X0, 112(DI)
         .          .     53:	MOVOU	X0, 128(DI)
         .          .     54:	MOVOU	X0, 144(DI)
         .          .     55:	MOVOU	X0, 160(DI)
         .          .     56:	MOVOU	X0, 176(DI)
         .          .     57:	MOVOU	X0, 192(DI)
         .          .     58:	MOVOU	X0, 208(DI)
         .          .     59:	MOVOU	X0, 224(DI)
         .          .     60:	MOVOU	X0, 240(DI)
         .          .     61:	SUBQ	$256, BX
         .          .     62:	ADDQ	$256, DI
         .          .     63:	CMPQ	BX, $256
         .          .     64:	JAE	loop
         .          .     65:	JMP	tail
         .          .     66:
         .          .     67:loop_preheader_avx2:
         .          .     68:	VPXOR Y0, Y0, Y0
         .          .     69:	// For smaller sizes MOVNTDQ may be faster or slower depending on hardware.
         .          .     70:	// For larger sizes it is always faster, even on dual Xeons with 30M cache.
         .          .     71:	// TODO take into account actual LLC size. E. g. glibc uses LLC size/2.
         .          .     72:	CMPQ    BX, $0x2000000
         .          .     73:	JAE     loop_preheader_avx2_huge
         .          .     74:loop_avx2:
     1.91s      1.91s     75:	VMOVDQU	Y0, 0(DI)
     530ms      530ms     76:	VMOVDQU	Y0, 32(DI)
     350ms      350ms     77:	VMOVDQU	Y0, 64(DI)
     120ms      120ms     78:	VMOVDQU	Y0, 96(DI)
     100ms      100ms     79:	SUBQ	$128, BX
         .          .     80:	ADDQ	$128, DI
      70ms       70ms     81:	CMPQ	BX, $128
         .          .     82:	JAE	loop_avx2
         .          .     83:	VMOVDQU  Y0, -32(DI)(BX*1)
         .          .     84:	VMOVDQU  Y0, -64(DI)(BX*1)
         .          .     85:	VMOVDQU  Y0, -96(DI)(BX*1)
         .          .     86:	VMOVDQU  Y0, -128(DI)(BX*1)
         .          .     87:	VZEROUPPER
         .          .     88:	RET
         .          .     89:loop_preheader_avx2_huge:
         .          .     90:	// Align to 32 byte boundary
         .          .     91:	VMOVDQU  Y0, 0(DI)
         .          .     92:	MOVQ	DI, SI
         .          .     93:	ADDQ	$32, DI
         .          .     94:	ANDQ	$~31, DI
         .          .     95:	SUBQ	DI, SI
         .          .     96:	ADDQ	SI, BX
         .          .     97:loop_avx2_huge:
         .          .     98:	VMOVNTDQ	Y0, 0(DI)
         .          .     99:	VMOVNTDQ	Y0, 32(DI)
         .          .    100:	VMOVNTDQ	Y0, 64(DI)
         .          .    101:	VMOVNTDQ	Y0, 96(DI)
         .          .    102:	SUBQ	$128, BX
         .          .    103:	ADDQ	$128, DI
         .          .    104:	CMPQ	BX, $128
         .          .    105:	JAE	loop_avx2_huge
         .          .    106:	// In the desciption of MOVNTDQ in [1]
         .          .    107:	// "... fencing operation implemented with the SFENCE or MFENCE instruction
         .          .    108:	// should be used in conjunction with MOVNTDQ instructions..."
         .          .    109:	// [1] 64-ia-32-architectures-software-developer-manual-325462.pdf
         .          .    110:	SFENCE
         .          .    111:	VMOVDQU  Y0, -32(DI)(BX*1)
         .          .    112:	VMOVDQU  Y0, -64(DI)(BX*1)
         .          .    113:	VMOVDQU  Y0, -96(DI)(BX*1)
         .          .    114:	VMOVDQU  Y0, -128(DI)(BX*1)
         .          .    115:	VZEROUPPER
         .          .    116:	RET
         .          .    117:
         .          .    118:_1or2:
         .          .    119:	MOVB	AX, (DI)
         .          .    120:	MOVB	AX, -1(DI)(BX*1)
         .          .    121:	RET
         .          .    122:_0:
         .          .    123:	RET
         .          .    124:_3or4:
         .          .    125:	MOVW	AX, (DI)
         .          .    126:	MOVW	AX, -2(DI)(BX*1)
         .          .    127:	RET
         .          .    128:_5through7:
         .          .    129:	MOVL	AX, (DI)
         .          .    130:	MOVL	AX, -4(DI)(BX*1)
         .          .    131:	RET
         .          .    132:_8:
         .          .    133:	// We need a separate case for 8 to make sure we clear pointers atomically.
         .          .    134:	MOVQ	AX, (DI)
         .          .    135:	RET
         .          .    136:_9through16:
         .          .    137:	MOVQ	AX, (DI)
         .          .    138:	MOVQ	AX, -8(DI)(BX*1)
         .          .    139:	RET
         .          .    140:_17through32:
      10ms       10ms    141:	MOVOU	X0, (DI)
      10ms       10ms    142:	MOVOU	X0, -16(DI)(BX*1)
         .          .    143:	RET
         .          .    144:_33through64:
         .          .    145:	MOVOU	X0, (DI)
         .          .    146:	MOVOU	X0, 16(DI)
         .          .    147:	MOVOU	X0, -32(DI)(BX*1)
         .          .    148:	MOVOU	X0, -16(DI)(BX*1)
         .          .    149:	RET
         .          .    150:_65through128:
         .          .    151:	MOVOU	X0, (DI)
         .          .    152:	MOVOU	X0, 16(DI)
         .          .    153:	MOVOU	X0, 32(DI)
         .          .    154:	MOVOU	X0, 48(DI)
         .          .    155:	MOVOU	X0, -64(DI)(BX*1)
         .          .    156:	MOVOU	X0, -48(DI)(BX*1)
         .          .    157:	MOVOU	X0, -32(DI)(BX*1)
         .          .    158:	MOVOU	X0, -16(DI)(BX*1)
         .          .    159:	RET
         .          .    160:_129through256:
      10ms       10ms    161:	MOVOU	X0, (DI)
         .          .    162:	MOVOU	X0, 16(DI)
         .          .    163:	MOVOU	X0, 32(DI)
         .          .    164:	MOVOU	X0, 48(DI)
      30ms       30ms    165:	MOVOU	X0, 64(DI)
         .          .    166:	MOVOU	X0, 80(DI)
         .          .    167:	MOVOU	X0, 96(DI)
         .          .    168:	MOVOU	X0, 112(DI)
         .          .    169:	MOVOU	X0, -128(DI)(BX*1)
         .          .    170:	MOVOU	X0, -112(DI)(BX*1)
         .          .    171:	MOVOU	X0, -96(DI)(BX*1)
      10ms       10ms    172:	MOVOU	X0, -80(DI)(BX*1)
         .          .    173:	MOVOU	X0, -64(DI)(BX*1)
         .          .    174:	MOVOU	X0, -48(DI)(BX*1)
         .          .    175:	MOVOU	X0, -32(DI)(BX*1)
         .          .    176:	MOVOU	X0, -16(DI)(BX*1)
         .          .    177:	RET
ROUTINE ======================== runtime.memeqbody in /home/isucon/.local/go/src/runtime/asm_amd64.s
     400ms      400ms (flat, cum)  0.72% of Total
         .          .   1309:// a in SI
         .          .   1310:// b in DI
         .          .   1311:// count in BX
         .          .   1312:// address of result byte in AX
         .          .   1313:TEXT runtime·memeqbody(SB),NOSPLIT,$0-0
      10ms       10ms   1314:	CMPQ	BX, $8
         .          .   1315:	JB	small
         .          .   1316:	CMPQ	BX, $64
         .          .   1317:	JB	bigloop
         .          .   1318:	CMPB    runtime·support_avx2(SB), $1
         .          .   1319:	JE	hugeloop_avx2
         .          .   1320:	
         .          .   1321:	// 64 bytes at a time using xmm registers
         .          .   1322:hugeloop:
         .          .   1323:	CMPQ	BX, $64
         .          .   1324:	JB	bigloop
         .          .   1325:	MOVOU	(SI), X0
         .          .   1326:	MOVOU	(DI), X1
         .          .   1327:	MOVOU	16(SI), X2
         .          .   1328:	MOVOU	16(DI), X3
         .          .   1329:	MOVOU	32(SI), X4
         .          .   1330:	MOVOU	32(DI), X5
         .          .   1331:	MOVOU	48(SI), X6
         .          .   1332:	MOVOU	48(DI), X7
         .          .   1333:	PCMPEQB	X1, X0
         .          .   1334:	PCMPEQB	X3, X2
         .          .   1335:	PCMPEQB	X5, X4
         .          .   1336:	PCMPEQB	X7, X6
         .          .   1337:	PAND	X2, X0
         .          .   1338:	PAND	X6, X4
         .          .   1339:	PAND	X4, X0
         .          .   1340:	PMOVMSKB X0, DX
         .          .   1341:	ADDQ	$64, SI
         .          .   1342:	ADDQ	$64, DI
         .          .   1343:	SUBQ	$64, BX
         .          .   1344:	CMPL	DX, $0xffff
         .          .   1345:	JEQ	hugeloop
         .          .   1346:	MOVB	$0, (AX)
         .          .   1347:	RET
         .          .   1348:
         .          .   1349:	// 64 bytes at a time using ymm registers
         .          .   1350:hugeloop_avx2:
         .          .   1351:	CMPQ	BX, $64
         .          .   1352:	JB	bigloop_avx2
         .          .   1353:	VMOVDQU	(SI), Y0
         .          .   1354:	VMOVDQU	(DI), Y1
         .          .   1355:	VMOVDQU	32(SI), Y2
         .          .   1356:	VMOVDQU	32(DI), Y3
         .          .   1357:	VPCMPEQB	Y1, Y0, Y4
         .          .   1358:	VPCMPEQB	Y2, Y3, Y5
         .          .   1359:	VPAND	Y4, Y5, Y6
         .          .   1360:	VPMOVMSKB Y6, DX
         .          .   1361:	ADDQ	$64, SI
         .          .   1362:	ADDQ	$64, DI
         .          .   1363:	SUBQ	$64, BX
         .          .   1364:	CMPL	DX, $0xffffffff
         .          .   1365:	JEQ	hugeloop_avx2
         .          .   1366:	VZEROUPPER
         .          .   1367:	MOVB	$0, (AX)
         .          .   1368:	RET
         .          .   1369:
         .          .   1370:bigloop_avx2:
         .          .   1371:	VZEROUPPER
         .          .   1372:
         .          .   1373:	// 8 bytes at a time using 64-bit register
         .          .   1374:bigloop:
         .          .   1375:	CMPQ	BX, $8
         .          .   1376:	JBE	leftover
         .          .   1377:	MOVQ	(SI), CX
      60ms       60ms   1378:	MOVQ	(DI), DX
      30ms       30ms   1379:	ADDQ	$8, SI
         .          .   1380:	ADDQ	$8, DI
         .          .   1381:	SUBQ	$8, BX
         .          .   1382:	CMPQ	CX, DX
         .          .   1383:	JEQ	bigloop
         .          .   1384:	MOVB	$0, (AX)
         .          .   1385:	RET
         .          .   1386:
         .          .   1387:	// remaining 0-8 bytes
         .          .   1388:leftover:
         .          .   1389:	MOVQ	-8(SI)(BX*1), CX
         .          .   1390:	MOVQ	-8(DI)(BX*1), DX
         .          .   1391:	CMPQ	CX, DX
         .          .   1392:	SETEQ	(AX)
         .          .   1393:	RET
         .          .   1394:
         .          .   1395:small:
      30ms       30ms   1396:	CMPQ	BX, $0
         .          .   1397:	JEQ	equal
         .          .   1398:
         .          .   1399:	LEAQ	0(BX*8), CX
         .          .   1400:	NEGQ	CX
         .          .   1401:
         .          .   1402:	CMPB	SI, $0xf8
      20ms       20ms   1403:	JA	si_high
         .          .   1404:
         .          .   1405:	// load at SI won't cross a page boundary.
      10ms       10ms   1406:	MOVQ	(SI), SI
         .          .   1407:	JMP	si_finish
         .          .   1408:si_high:
         .          .   1409:	// address ends in 11111xxx.  Load up to bytes we want, move to correct position.
         .          .   1410:	MOVQ	-8(SI)(BX*1), SI
         .          .   1411:	SHRQ	CX, SI
         .          .   1412:si_finish:
         .          .   1413:
         .          .   1414:	// same for DI.
      10ms       10ms   1415:	CMPB	DI, $0xf8
         .          .   1416:	JA	di_high
         .          .   1417:	MOVQ	(DI), DI
         .          .   1418:	JMP	di_finish
         .          .   1419:di_high:
         .          .   1420:	MOVQ	-8(DI)(BX*1), DI
         .          .   1421:	SHRQ	CX, DI
         .          .   1422:di_finish:
         .          .   1423:
     100ms      100ms   1424:	SUBQ	SI, DI
      50ms       50ms   1425:	SHLQ	CX, DI
         .          .   1426:equal:
      40ms       40ms   1427:	SETEQ	(AX)
      40ms       40ms   1428:	RET
         .          .   1429:
         .          .   1430:TEXT runtime·cmpstring(SB),NOSPLIT,$0-40
         .          .   1431:	MOVQ	s1_base+0(FP), SI
         .          .   1432:	MOVQ	s1_len+8(FP), BX
         .          .   1433:	MOVQ	s2_base+16(FP), DI
ROUTINE ======================== runtime.memequal64 in /home/isucon/.local/go/src/runtime/alg.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    206:}
         .          .    207:func memequal32(p, q unsafe.Pointer) bool {
         .          .    208:	return *(*int32)(p) == *(*int32)(q)
         .          .    209:}
         .          .    210:func memequal64(p, q unsafe.Pointer) bool {
      10ms       10ms    211:	return *(*int64)(p) == *(*int64)(q)
         .          .    212:}
         .          .    213:func memequal128(p, q unsafe.Pointer) bool {
         .          .    214:	return *(*[2]int64)(p) == *(*[2]int64)(q)
         .          .    215:}
         .          .    216:func f32equal(p, q unsafe.Pointer) bool {
ROUTINE ======================== runtime.memmove in /home/isucon/.local/go/src/runtime/memmove_amd64.s
     2.28s      2.28s (flat, cum)  4.10% of Total
         .          .     28:#include "textflag.h"
         .          .     29:
         .          .     30:// void runtime·memmove(void*, void*, uintptr)
         .          .     31:TEXT runtime·memmove(SB), NOSPLIT, $0-24
         .          .     32:
      30ms       30ms     33:	MOVQ	to+0(FP), DI
      60ms       60ms     34:	MOVQ	from+8(FP), SI
      40ms       40ms     35:	MOVQ	n+16(FP), BX
         .          .     36:
         .          .     37:	// REP instructions have a high startup cost, so we handle small sizes
         .          .     38:	// with some straightline code.  The REP MOVSQ instruction is really fast
         .          .     39:	// for large sizes.  The cutover is approximately 2K.
         .          .     40:tail:
         .          .     41:	// move_129through256 or smaller work whether or not the source and the
         .          .     42:	// destination memory regions overlap because they load all data into
         .          .     43:	// registers before writing it back.  move_256through2048 on the other
         .          .     44:	// hand can be used only when the memory regions don't overlap or the copy
         .          .     45:	// direction is forward.
     160ms      160ms     46:	TESTQ	BX, BX
         .          .     47:	JEQ	move_0
      70ms       70ms     48:	CMPQ	BX, $2
         .          .     49:	JBE	move_1or2
      40ms       40ms     50:	CMPQ	BX, $4
         .          .     51:	JBE	move_3or4
      40ms       40ms     52:	CMPQ	BX, $8
         .          .     53:	JB	move_5through7
      60ms       60ms     54:	JE	move_8
     100ms      100ms     55:	CMPQ	BX, $16
         .          .     56:	JBE	move_9through16
      40ms       40ms     57:	CMPQ	BX, $32
         .          .     58:	JBE	move_17through32
      10ms       10ms     59:	CMPQ	BX, $64
         .          .     60:	JBE	move_33through64
      10ms       10ms     61:	CMPQ	BX, $128
         .          .     62:	JBE	move_65through128
         .          .     63:	CMPQ	BX, $256
         .          .     64:	JBE	move_129through256
         .          .     65:	// TODO: use branch table and BSR to make this just a single dispatch
         .          .     66:
         .          .     67:/*
         .          .     68: * check and set for backwards
         .          .     69: */
         .          .     70:	CMPQ	SI, DI
         .          .     71:	JLS	back
         .          .     72:
         .          .     73:/*
         .          .     74: * forward copy loop
         .          .     75: */
         .          .     76:forward:
         .          .     77:	CMPQ	BX, $2048
         .          .     78:	JLS	move_256through2048
         .          .     79:
         .          .     80:	MOVQ	BX, CX
         .          .     81:	SHRQ	$3, CX
         .          .     82:	ANDQ	$7, BX
     810ms      810ms     83:	REP;	MOVSQ
         .          .     84:	JMP	tail
         .          .     85:
         .          .     86:back:
         .          .     87:/*
         .          .     88: * check overlap
         .          .     89: */
         .          .     90:	MOVQ	SI, CX
         .          .     91:	ADDQ	BX, CX
         .          .     92:	CMPQ	CX, DI
         .          .     93:	JLS	forward
         .          .     94:	
         .          .     95:/*
         .          .     96: * whole thing backwards has
         .          .     97: * adjusted addresses
         .          .     98: */
         .          .     99:	ADDQ	BX, DI
         .          .    100:	ADDQ	BX, SI
         .          .    101:	STD
         .          .    102:
         .          .    103:/*
         .          .    104: * copy
         .          .    105: */
         .          .    106:	MOVQ	BX, CX
         .          .    107:	SHRQ	$3, CX
         .          .    108:	ANDQ	$7, BX
         .          .    109:
         .          .    110:	SUBQ	$8, DI
         .          .    111:	SUBQ	$8, SI
         .          .    112:	REP;	MOVSQ
         .          .    113:
         .          .    114:	CLD
         .          .    115:	ADDQ	$8, DI
         .          .    116:	ADDQ	$8, SI
         .          .    117:	SUBQ	BX, DI
         .          .    118:	SUBQ	BX, SI
         .          .    119:	JMP	tail
         .          .    120:
         .          .    121:move_1or2:
      10ms       10ms    122:	MOVB	(SI), AX
      20ms       20ms    123:	MOVB	-1(SI)(BX*1), CX
         .          .    124:	MOVB	AX, (DI)
         .          .    125:	MOVB	CX, -1(DI)(BX*1)
         .          .    126:	RET
         .          .    127:move_0:
      10ms       10ms    128:	RET
         .          .    129:move_3or4:
         .          .    130:	MOVW	(SI), AX
      20ms       20ms    131:	MOVW	-2(SI)(BX*1), CX
         .          .    132:	MOVW	AX, (DI)
      10ms       10ms    133:	MOVW	CX, -2(DI)(BX*1)
         .          .    134:	RET
         .          .    135:move_5through7:
         .          .    136:	MOVL	(SI), AX
      20ms       20ms    137:	MOVL	-4(SI)(BX*1), CX
         .          .    138:	MOVL	AX, (DI)
         .          .    139:	MOVL	CX, -4(DI)(BX*1)
         .          .    140:	RET
         .          .    141:move_8:
         .          .    142:	// We need a separate case for 8 to make sure we write pointers atomically.
      10ms       10ms    143:	MOVQ	(SI), AX
      20ms       20ms    144:	MOVQ	AX, (DI)
         .          .    145:	RET
         .          .    146:move_9through16:
         .          .    147:	MOVQ	(SI), AX
         .          .    148:	MOVQ	-8(SI)(BX*1), CX
         .          .    149:	MOVQ	AX, (DI)
         .          .    150:	MOVQ	CX, -8(DI)(BX*1)
      10ms       10ms    151:	RET
         .          .    152:move_17through32:
      30ms       30ms    153:	MOVOU	(SI), X0
     120ms      120ms    154:	MOVOU	-16(SI)(BX*1), X1
      90ms       90ms    155:	MOVOU	X0, (DI)
      60ms       60ms    156:	MOVOU	X1, -16(DI)(BX*1)
     130ms      130ms    157:	RET
         .          .    158:move_33through64:
         .          .    159:	MOVOU	(SI), X0
      20ms       20ms    160:	MOVOU	16(SI), X1
         .          .    161:	MOVOU	-32(SI)(BX*1), X2
         .          .    162:	MOVOU	-16(SI)(BX*1), X3
      30ms       30ms    163:	MOVOU	X0, (DI)
         .          .    164:	MOVOU	X1, 16(DI)
         .          .    165:	MOVOU	X2, -32(DI)(BX*1)
      10ms       10ms    166:	MOVOU	X3, -16(DI)(BX*1)
         .          .    167:	RET
         .          .    168:move_65through128:
      20ms       20ms    169:	MOVOU	(SI), X0
      10ms       10ms    170:	MOVOU	16(SI), X1
         .          .    171:	MOVOU	32(SI), X2
         .          .    172:	MOVOU	48(SI), X3
         .          .    173:	MOVOU	-64(SI)(BX*1), X4
         .          .    174:	MOVOU	-48(SI)(BX*1), X5
         .          .    175:	MOVOU	-32(SI)(BX*1), X6
         .          .    176:	MOVOU	-16(SI)(BX*1), X7
      20ms       20ms    177:	MOVOU	X0, (DI)
         .          .    178:	MOVOU	X1, 16(DI)
         .          .    179:	MOVOU	X2, 32(DI)
         .          .    180:	MOVOU	X3, 48(DI)
      10ms       10ms    181:	MOVOU	X4, -64(DI)(BX*1)
         .          .    182:	MOVOU	X5, -48(DI)(BX*1)
         .          .    183:	MOVOU	X6, -32(DI)(BX*1)
         .          .    184:	MOVOU	X7, -16(DI)(BX*1)
         .          .    185:	RET
         .          .    186:move_129through256:
         .          .    187:	MOVOU	(SI), X0
      20ms       20ms    188:	MOVOU	16(SI), X1
         .          .    189:	MOVOU	32(SI), X2
         .          .    190:	MOVOU	48(SI), X3
      10ms       10ms    191:	MOVOU	64(SI), X4
         .          .    192:	MOVOU	80(SI), X5
         .          .    193:	MOVOU	96(SI), X6
      20ms       20ms    194:	MOVOU	112(SI), X7
      10ms       10ms    195:	MOVOU	-128(SI)(BX*1), X8
         .          .    196:	MOVOU	-112(SI)(BX*1), X9
         .          .    197:	MOVOU	-96(SI)(BX*1), X10
      20ms       20ms    198:	MOVOU	-80(SI)(BX*1), X11
         .          .    199:	MOVOU	-64(SI)(BX*1), X12
         .          .    200:	MOVOU	-48(SI)(BX*1), X13
         .          .    201:	MOVOU	-32(SI)(BX*1), X14
      10ms       10ms    202:	MOVOU	-16(SI)(BX*1), X15
         .          .    203:	MOVOU	X0, (DI)
         .          .    204:	MOVOU	X1, 16(DI)
         .          .    205:	MOVOU	X2, 32(DI)
      10ms       10ms    206:	MOVOU	X3, 48(DI)
         .          .    207:	MOVOU	X4, 64(DI)
         .          .    208:	MOVOU	X5, 80(DI)
      10ms       10ms    209:	MOVOU	X6, 96(DI)
         .          .    210:	MOVOU	X7, 112(DI)
         .          .    211:	MOVOU	X8, -128(DI)(BX*1)
         .          .    212:	MOVOU	X9, -112(DI)(BX*1)
         .          .    213:	MOVOU	X10, -96(DI)(BX*1)
         .          .    214:	MOVOU	X11, -80(DI)(BX*1)
      10ms       10ms    215:	MOVOU	X12, -64(DI)(BX*1)
         .          .    216:	MOVOU	X13, -48(DI)(BX*1)
         .          .    217:	MOVOU	X14, -32(DI)(BX*1)
      10ms       10ms    218:	MOVOU	X15, -16(DI)(BX*1)
         .          .    219:	RET
         .          .    220:move_256through2048:
         .          .    221:	SUBQ	$256, BX
         .          .    222:	MOVOU	(SI), X0
         .          .    223:	MOVOU	16(SI), X1
ROUTINE ======================== runtime.morestack in /home/isucon/.local/go/src/runtime/asm_amd64.s
         0      530ms (flat, cum)  0.95% of Total
         .          .    354:
         .          .    355:	// Call newstack on m->g0's stack.
         .          .    356:	MOVQ	m_g0(BX), BX
         .          .    357:	MOVQ	BX, g(CX)
         .          .    358:	MOVQ	(g_sched+gobuf_sp)(BX), SP
         .      530ms    359:	CALL	runtime·newstack(SB)
         .          .    360:	MOVQ	$0, 0x1003	// crash if newstack returns
         .          .    361:	RET
         .          .    362:
         .          .    363:// morestack but not preserving ctxt.
         .          .    364:TEXT runtime·morestack_noctxt(SB),NOSPLIT,$0
ROUTINE ======================== runtime.mprof_GC in /home/isucon/.local/go/src/runtime/mprof.go
      20ms       20ms (flat, cum) 0.036% of Total
         .          .    204:}
         .          .    205:
         .          .    206:func mprof_GC() {
         .          .    207:	for b := mbuckets; b != nil; b = b.allnext {
         .          .    208:		mp := b.mp()
      10ms       10ms    209:		mp.allocs += mp.prev_allocs
      10ms       10ms    210:		mp.frees += mp.prev_frees
         .          .    211:		mp.alloc_bytes += mp.prev_alloc_bytes
         .          .    212:		mp.free_bytes += mp.prev_free_bytes
         .          .    213:
         .          .    214:		mp.prev_allocs = mp.recent_allocs
         .          .    215:		mp.prev_frees = mp.recent_frees
ROUTINE ======================== runtime.mstart in /home/isucon/.local/go/src/runtime/proc.go
         0       30ms (flat, cum) 0.054% of Total
         .          .   1063:	}
         .          .   1064:	// Initialize stack guards so that we can start calling
         .          .   1065:	// both Go and C functions with stack growth prologues.
         .          .   1066:	_g_.stackguard0 = _g_.stack.lo + _StackGuard
         .          .   1067:	_g_.stackguard1 = _g_.stackguard0
         .       30ms   1068:	mstart1()
         .          .   1069:}
         .          .   1070:
         .          .   1071:func mstart1() {
         .          .   1072:	_g_ := getg()
         .          .   1073:
ROUTINE ======================== runtime.mstart1 in /home/isucon/.local/go/src/runtime/proc.go
         0       30ms (flat, cum) 0.054% of Total
         .          .   1093:		}
         .          .   1094:		initsig(false)
         .          .   1095:	}
         .          .   1096:
         .          .   1097:	if fn := _g_.m.mstartfn; fn != nil {
         .       30ms   1098:		fn()
         .          .   1099:	}
         .          .   1100:
         .          .   1101:	if _g_.m.helpgc != 0 {
         .          .   1102:		_g_.m.helpgc = 0
         .          .   1103:		stopm()
ROUTINE ======================== runtime.netpoll in /home/isucon/.local/go/src/runtime/netpoll_epoll.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     62:	if !block {
         .          .     63:		waitms = 0
         .          .     64:	}
         .          .     65:	var events [128]epollevent
         .          .     66:retry:
         .       20ms     67:	n := epollwait(epfd, &events[0], int32(len(events)), waitms)
         .          .     68:	if n < 0 {
         .          .     69:		if n != -_EINTR {
         .          .     70:			println("runtime: epollwait on fd", epfd, "failed with", -n)
         .          .     71:			throw("epollwait failed")
         .          .     72:		}
ROUTINE ======================== runtime.netpollblock in /home/isucon/.local/go/src/runtime/netpoll.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    336:
         .          .    337:	// need to recheck error states after setting gpp to WAIT
         .          .    338:	// this is necessary because runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl
         .          .    339:	// do the opposite: store to closing/rd/wd, membarrier, load of rg/wg
         .          .    340:	if waitio || netpollcheckerr(pd, mode) == 0 {
         .       10ms    341:		gopark(netpollblockcommit, unsafe.Pointer(gpp), "IO wait", traceEvGoBlockNet, 5)
         .          .    342:	}
         .          .    343:	// be careful to not lose concurrent READY notification
         .          .    344:	old := atomic.Xchguintptr(gpp, 0)
         .          .    345:	if old > pdWait {
         .          .    346:		throw("netpollblock: corrupted state")
ROUTINE ======================== runtime.netpollclose in /home/isucon/.local/go/src/runtime/netpoll_epoll.go
         0       30ms (flat, cum) 0.054% of Total
         .          .     43:	return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), &ev)
         .          .     44:}
         .          .     45:
         .          .     46:func netpollclose(fd uintptr) int32 {
         .          .     47:	var ev epollevent
         .       30ms     48:	return -epollctl(epfd, _EPOLL_CTL_DEL, int32(fd), &ev)
         .          .     49:}
         .          .     50:
         .          .     51:func netpollarm(pd *pollDesc, mode int) {
         .          .     52:	throw("unused")
         .          .     53:}
ROUTINE ======================== runtime.netpollopen in /home/isucon/.local/go/src/runtime/netpoll_epoll.go
         0       40ms (flat, cum) 0.072% of Total
         .          .     38:
         .          .     39:func netpollopen(fd uintptr, pd *pollDesc) int32 {
         .          .     40:	var ev epollevent
         .          .     41:	ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET
         .          .     42:	*(**pollDesc)(unsafe.Pointer(&ev.data)) = pd
         .       40ms     43:	return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), &ev)
         .          .     44:}
         .          .     45:
         .          .     46:func netpollclose(fd uintptr) int32 {
         .          .     47:	var ev epollevent
         .          .     48:	return -epollctl(epfd, _EPOLL_CTL_DEL, int32(fd), &ev)
ROUTINE ======================== runtime.newarray in /home/isucon/.local/go/src/runtime/malloc.go
      50ms      5.95s (flat, cum) 10.69% of Total
         .          .    787:}
         .          .    788:
         .          .    789:// implementation of make builtin for slices
         .          .    790:func newarray(typ *_type, n uintptr) unsafe.Pointer {
         .          .    791:	flags := uint32(0)
      20ms       20ms    792:	if typ.kind&kindNoPointers != 0 {
         .          .    793:		flags |= flagNoScan
         .          .    794:	}
      30ms       30ms    795:	if int(n) < 0 || (typ.size > 0 && n > _MaxMem/uintptr(typ.size)) {
         .          .    796:		panic("runtime: allocation size out of range")
         .          .    797:	}
         .      5.90s    798:	return mallocgc(uintptr(typ.size)*n, typ, flags)
         .          .    799:}
         .          .    800:
         .          .    801://go:linkname reflect_unsafe_NewArray reflect.unsafe_NewArray
         .          .    802:func reflect_unsafe_NewArray(typ *_type, n uintptr) unsafe.Pointer {
         .          .    803:	return newarray(typ, n)
ROUTINE ======================== runtime.newdefer in /home/isucon/.local/go/src/runtime/panic.go
     130ms      130ms (flat, cum)  0.23% of Total
         .          .    180:// Allocate a Defer, usually using per-P pool.
         .          .    181:// Each defer must be released with freedefer.
         .          .    182:// Note: runs on g0 stack
         .          .    183:func newdefer(siz int32) *_defer {
         .          .    184:	var d *_defer
      10ms       10ms    185:	sc := deferclass(uintptr(siz))
         .          .    186:	mp := acquirem()
         .          .    187:	if sc < uintptr(len(p{}.deferpool)) {
         .          .    188:		pp := mp.p.ptr()
      20ms       20ms    189:		if len(pp.deferpool[sc]) == 0 && sched.deferpool[sc] != nil {
         .          .    190:			lock(&sched.deferlock)
         .          .    191:			for len(pp.deferpool[sc]) < cap(pp.deferpool[sc])/2 && sched.deferpool[sc] != nil {
         .          .    192:				d := sched.deferpool[sc]
         .          .    193:				sched.deferpool[sc] = d.link
         .          .    194:				d.link = nil
         .          .    195:				pp.deferpool[sc] = append(pp.deferpool[sc], d)
         .          .    196:			}
         .          .    197:			unlock(&sched.deferlock)
         .          .    198:		}
      10ms       10ms    199:		if n := len(pp.deferpool[sc]); n > 0 {
         .          .    200:			d = pp.deferpool[sc][n-1]
      30ms       30ms    201:			pp.deferpool[sc][n-1] = nil
         .          .    202:			pp.deferpool[sc] = pp.deferpool[sc][:n-1]
         .          .    203:		}
         .          .    204:	}
         .          .    205:	if d == nil {
         .          .    206:		// Allocate new defer+args.
         .          .    207:		total := roundupsize(totaldefersize(uintptr(siz)))
         .          .    208:		d = (*_defer)(mallocgc(total, deferType, 0))
         .          .    209:	}
      10ms       10ms    210:	d.siz = siz
      20ms       20ms    211:	gp := mp.curg
         .          .    212:	d.link = gp._defer
         .          .    213:	gp._defer = d
      30ms       30ms    214:	releasem(mp)
         .          .    215:	return d
         .          .    216:}
         .          .    217:
         .          .    218:// Free the given defer.
         .          .    219:// The defer cannot be used after this call.
ROUTINE ======================== runtime.newobject in /home/isucon/.local/go/src/runtime/malloc.go
     340ms      8.07s (flat, cum) 14.50% of Total
         .          .    771:	heapBitsForSpan(s.base()).initSpan(s.layout())
         .          .    772:	return s
         .          .    773:}
         .          .    774:
         .          .    775:// implementation of new builtin
      90ms       90ms    776:func newobject(typ *_type) unsafe.Pointer {
         .          .    777:	flags := uint32(0)
     140ms      140ms    778:	if typ.kind&kindNoPointers != 0 {
         .          .    779:		flags |= flagNoScan
         .          .    780:	}
     110ms      7.84s    781:	return mallocgc(uintptr(typ.size), typ, flags)
         .          .    782:}
         .          .    783:
         .          .    784://go:linkname reflect_unsafe_New reflect.unsafe_New
         .          .    785:func reflect_unsafe_New(typ *_type) unsafe.Pointer {
         .          .    786:	return newobject(typ)
ROUTINE ======================== runtime.newproc in /home/isucon/.local/go/src/runtime/proc.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   2657:func newproc(siz int32, fn *funcval) {
         .          .   2658:	argp := add(unsafe.Pointer(&fn), sys.PtrSize)
         .          .   2659:	pc := getcallerpc(unsafe.Pointer(&siz))
         .          .   2660:	systemstack(func() {
         .          .   2661:		newproc1(fn, (*uint8)(argp), siz, 0, pc)
         .       10ms   2662:	})
         .          .   2663:}
         .          .   2664:
         .          .   2665:// Create a new g running fn with narg bytes of arguments starting
         .          .   2666:// at argp and returning nret bytes of results.  callerpc is the
         .          .   2667:// address of the go statement that created this.  The new g is put
ROUTINE ======================== runtime.newproc.func1 in /home/isucon/.local/go/src/runtime/proc.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   2656://go:nosplit
         .          .   2657:func newproc(siz int32, fn *funcval) {
         .          .   2658:	argp := add(unsafe.Pointer(&fn), sys.PtrSize)
         .          .   2659:	pc := getcallerpc(unsafe.Pointer(&siz))
         .          .   2660:	systemstack(func() {
         .       10ms   2661:		newproc1(fn, (*uint8)(argp), siz, 0, pc)
         .          .   2662:	})
         .          .   2663:}
         .          .   2664:
         .          .   2665:// Create a new g running fn with narg bytes of arguments starting
         .          .   2666:// at argp and returning nret bytes of results.  callerpc is the
ROUTINE ======================== runtime.newproc1 in /home/isucon/.local/go/src/runtime/proc.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   2739:		newg.racectx = racegostart(callerpc)
         .          .   2740:	}
         .          .   2741:	if trace.enabled {
         .          .   2742:		traceGoCreate(newg, newg.startpc)
         .          .   2743:	}
         .       10ms   2744:	runqput(_p_, newg, true)
         .          .   2745:
         .          .   2746:	if atomic.Load(&sched.npidle) != 0 && atomic.Load(&sched.nmspinning) == 0 && unsafe.Pointer(fn.fn) != unsafe.Pointer(funcPC(main)) { // TODO: fast atomic
         .          .   2747:		wakep()
         .          .   2748:	}
         .          .   2749:	_g_.m.locks--
ROUTINE ======================== runtime.newstack in /home/isucon/.local/go/src/runtime/stack.go
         0      530ms (flat, cum)  0.95% of Total
         .          .    927:			gogo(&gp.sched) // never return
         .          .    928:		}
         .          .    929:
         .          .    930:		// Act like goroutine called runtime.Gosched.
         .          .    931:		casgstatus(gp, _Gwaiting, _Grunning)
         .       30ms    932:		gopreempt_m(gp) // never return
         .          .    933:	}
         .          .    934:
         .          .    935:	// Allocate a bigger segment and move the stack.
         .          .    936:	oldsize := int(gp.stackAlloc)
         .          .    937:	newsize := oldsize * 2
         .          .    938:	if uintptr(newsize) > maxstacksize {
         .          .    939:		print("runtime: goroutine stack exceeds ", maxstacksize, "-byte limit\n")
         .          .    940:		throw("stack overflow")
         .          .    941:	}
         .          .    942:
         .          .    943:	casgstatus(gp, _Gwaiting, _Gcopystack)
         .          .    944:
         .          .    945:	// The concurrent GC will not scan the stack while we are doing the copy since
         .          .    946:	// the gp is in a Gcopystack status.
         .      500ms    947:	copystack(gp, uintptr(newsize))
         .          .    948:	if stackDebug >= 1 {
         .          .    949:		print("stack grow done\n")
         .          .    950:	}
         .          .    951:	casgstatus(gp, _Gcopystack, _Grunning)
         .          .    952:	gogo(&gp.sched)
ROUTINE ======================== runtime.nextSample in /home/isucon/.local/go/src/runtime/malloc.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    846:	// -log_e(q)/m = x
         .          .    847:	// x = -log_e(q) * period
         .          .    848:	// x = log_2(q) * (-log_e(2)) * period    ; Using log_2 for efficiency
         .          .    849:	const randomBitCount = 26
         .          .    850:	q := uint32(fastrand1())%(1<<randomBitCount) + 1
         .       20ms    851:	qlog := fastlog2(float64(q)) - randomBitCount
         .          .    852:	if qlog > 0 {
         .          .    853:		qlog = 0
         .          .    854:	}
         .          .    855:	const minusLog2 = -0.6931471805599453 // -ln(2)
         .          .    856:	return int32(qlog*(minusLog2*float64(period))) + 1
ROUTINE ======================== runtime.nilinterequal in /home/isucon/.local/go/src/runtime/alg.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    230:}
         .          .    231:func interequal(p, q unsafe.Pointer) bool {
         .          .    232:	return ifaceeq(*(*iface)(p), *(*iface)(q))
         .          .    233:}
         .          .    234:func nilinterequal(p, q unsafe.Pointer) bool {
         .       10ms    235:	return efaceeq(*(*eface)(p), *(*eface)(q))
         .          .    236:}
         .          .    237:func efaceeq(x, y eface) bool {
         .          .    238:	t := x._type
         .          .    239:	if t != y._type {
         .          .    240:		return false
ROUTINE ======================== runtime.nilinterhash in /home/isucon/.local/go/src/runtime/alg.go
      10ms       30ms (flat, cum) 0.054% of Total
         .          .    169:	} else {
         .          .    170:		return c1 * fn(a.data, h^c0)
         .          .    171:	}
         .          .    172:}
         .          .    173:
      10ms       10ms    174:func nilinterhash(p unsafe.Pointer, h uintptr) uintptr {
         .          .    175:	a := (*eface)(p)
         .          .    176:	t := a._type
         .          .    177:	if t == nil {
         .          .    178:		return h
         .          .    179:	}
         .          .    180:	fn := t.alg.hash
         .          .    181:	if fn == nil {
         .          .    182:		panic(errorString("hash of unhashable type " + *t._string))
         .          .    183:	}
         .          .    184:	if isDirectIface(t) {
         .          .    185:		return c1 * fn(unsafe.Pointer(&a.data), h^c0)
         .          .    186:	} else {
         .       20ms    187:		return c1 * fn(a.data, h^c0)
         .          .    188:	}
         .          .    189:}
         .          .    190:
         .          .    191:func memequal(p, q unsafe.Pointer, size uintptr) bool {
         .          .    192:	if p == q {
ROUTINE ======================== runtime.notesleep in /home/isucon/.local/go/src/runtime/lock_futex.go
         0       90ms (flat, cum)  0.16% of Total
         .          .    140:	if gp != gp.m.g0 {
         .          .    141:		throw("notesleep not on g0")
         .          .    142:	}
         .          .    143:	for atomic.Load(key32(&n.key)) == 0 {
         .          .    144:		gp.m.blocked = true
         .       90ms    145:		futexsleep(key32(&n.key), 0, -1)
         .          .    146:		gp.m.blocked = false
         .          .    147:	}
         .          .    148:}
         .          .    149:
         .          .    150:// May run with m.p==nil if called from notetsleep, so write barriers
ROUTINE ======================== runtime.notetsleep in /home/isucon/.local/go/src/runtime/lock_futex.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    189:	gp := getg()
         .          .    190:	if gp != gp.m.g0 && gp.m.preemptoff != "" {
         .          .    191:		throw("notetsleep not on g0")
         .          .    192:	}
         .          .    193:
         .       20ms    194:	return notetsleep_internal(n, ns)
         .          .    195:}
         .          .    196:
         .          .    197:// same as runtime·notetsleep, but called on user g (not g0)
         .          .    198:// calls only nosplit functions between entersyscallblock/exitsyscall
         .          .    199:func notetsleepg(n *note, ns int64) bool {
ROUTINE ======================== runtime.notetsleep_internal in /home/isucon/.local/go/src/runtime/lock_futex.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    169:	}
         .          .    170:
         .          .    171:	deadline := nanotime() + ns
         .          .    172:	for {
         .          .    173:		gp.m.blocked = true
         .       20ms    174:		futexsleep(key32(&n.key), 0, ns)
         .          .    175:		gp.m.blocked = false
         .          .    176:		if atomic.Load(key32(&n.key)) != 0 {
         .          .    177:			break
         .          .    178:		}
         .          .    179:		now := nanotime()
ROUTINE ======================== runtime.park_m in /home/isucon/.local/go/src/runtime/proc.go
         0      100ms (flat, cum)  0.18% of Total
         .          .   2135:			}
         .          .   2136:			casgstatus(gp, _Gwaiting, _Grunnable)
         .          .   2137:			execute(gp, true) // Schedule it back, never returns.
         .          .   2138:		}
         .          .   2139:	}
         .      100ms   2140:	schedule()
         .          .   2141:}
         .          .   2142:
         .          .   2143:func goschedImpl(gp *g) {
         .          .   2144:	status := readgstatus(gp)
         .          .   2145:	if status&^_Gscan != _Grunning {
ROUTINE ======================== runtime.pcdatavalue in /home/isucon/.local/go/src/runtime/symtab.go
         0      190ms (flat, cum)  0.34% of Total
         .          .    370:func pcdatavalue(f *_func, table int32, targetpc uintptr, cache *pcvalueCache) int32 {
         .          .    371:	if table < 0 || table >= f.npcdata {
         .          .    372:		return -1
         .          .    373:	}
         .          .    374:	off := *(*int32)(add(unsafe.Pointer(&f.nfuncdata), unsafe.Sizeof(f.nfuncdata)+uintptr(table)*4))
         .      190ms    375:	return pcvalue(f, off, targetpc, cache, true)
         .          .    376:}
         .          .    377:
         .          .    378:func funcdata(f *_func, i int32) unsafe.Pointer {
         .          .    379:	if i < 0 || i >= f.nfuncdata {
         .          .    380:		return nil
ROUTINE ======================== runtime.pcvalue in /home/isucon/.local/go/src/runtime/symtab.go
     210ms      460ms (flat, cum)  0.83% of Total
         .          .    251:	// tend to have the same recursive functions over and over.
         .          .    252:	//
         .          .    253:	// This cache is small enough that full associativity is
         .          .    254:	// cheaper than doing the hashing for a less associative
         .          .    255:	// cache.
      10ms       10ms    256:	if cache != nil {
      60ms       80ms    257:		for _, ent := range cache.entries {
         .          .    258:			// We check off first because we're more
         .          .    259:			// likely to have multiple entries with
         .          .    260:			// different offsets for the same targetpc
         .          .    261:			// than the other way around, so we'll usually
         .          .    262:			// fail in the first clause.
      10ms       10ms    263:			if ent.off == off && ent.targetpc == targetpc {
         .          .    264:				return ent.val
         .          .    265:			}
         .          .    266:		}
         .          .    267:	}
         .          .    268:
      10ms       10ms    269:	datap := findmoduledatap(f.entry) // inefficient
         .          .    270:	if datap == nil {
         .          .    271:		if strict && panicking == 0 {
         .          .    272:			print("runtime: no module data for ", hex(f.entry), "\n")
         .          .    273:			throw("no module data")
         .          .    274:		}
         .          .    275:		return -1
         .          .    276:	}
      20ms       20ms    277:	p := datap.pclntable[off:]
         .          .    278:	pc := f.entry
         .          .    279:	val := int32(-1)
         .          .    280:	for {
         .          .    281:		var ok bool
      50ms      270ms    282:		p, ok = step(p, &pc, &val, pc == f.entry)
         .          .    283:		if !ok {
         .          .    284:			break
         .          .    285:		}
      10ms       10ms    286:		if targetpc < pc {
         .          .    287:			// Replace a random entry in the cache. Random
         .          .    288:			// replacement prevents a performance cliff if
         .          .    289:			// a recursive stack's cycle is slightly
         .          .    290:			// larger than the cache.
      10ms       10ms    291:			if cache != nil {
         .       10ms    292:				ci := fastrand1() % uint32(len(cache.entries))
         .          .    293:				cache.entries[ci] = pcvalueCacheEnt{
         .          .    294:					targetpc: targetpc,
         .          .    295:					off:      off,
         .          .    296:					val:      val,
      30ms       30ms    297:				}
         .          .    298:			}
         .          .    299:
         .          .    300:			return val
         .          .    301:		}
         .          .    302:	}
ROUTINE ======================== runtime.prefetchnta in /home/isucon/.local/go/src/runtime/asm_amd64.s
     200ms      200ms (flat, cum)  0.36% of Total
         .          .   2014:	MOVQ	addr+0(FP), AX
         .          .   2015:	PREFETCHT2	(AX)
         .          .   2016:	RET
         .          .   2017:
         .          .   2018:TEXT runtime·prefetchnta(SB),NOSPLIT,$0-8
      10ms       10ms   2019:	MOVQ	addr+0(FP), AX
      90ms       90ms   2020:	PREFETCHNTA	(AX)
     100ms      100ms   2021:	RET
         .          .   2022:
         .          .   2023:// This is called from .init_array and follows the platform, not Go, ABI.
         .          .   2024:TEXT runtime·addmoduledata(SB),NOSPLIT,$0-0
         .          .   2025:	PUSHQ	R15 // The access to global variables below implicitly uses R15, which is callee-save
         .          .   2026:	MOVQ	runtime·lastmoduledatap(SB), AX
ROUTINE ======================== runtime.profilealloc in /home/isucon/.local/go/src/runtime/malloc.go
         0      260ms (flat, cum)  0.47% of Total
         .          .    808:func rawmem(size uintptr) unsafe.Pointer {
         .          .    809:	return mallocgc(size, nil, flagNoScan|flagNoZero)
         .          .    810:}
         .          .    811:
         .          .    812:func profilealloc(mp *m, x unsafe.Pointer, size uintptr) {
         .       20ms    813:	mp.mcache.next_sample = nextSample()
         .      240ms    814:	mProf_Malloc(x, size)
         .          .    815:}
         .          .    816:
         .          .    817:// nextSample returns the next sampling point for heap profiling.
         .          .    818:// It produces a random variable with a geometric distribution and
         .          .    819:// mean MemProfileRate. This is done by generating a uniformly
ROUTINE ======================== runtime.publicationBarrier in /home/isucon/.local/go/src/runtime/asm_amd64.s
      20ms       20ms (flat, cum) 0.036% of Total
         .          .    506:
         .          .    507:
         .          .    508:TEXT ·publicationBarrier(SB),NOSPLIT,$0-0
         .          .    509:	// Stores are already ordered on x86, so this is just a
         .          .    510:	// compile barrier.
      20ms       20ms    511:	RET
         .          .    512:
         .          .    513:// void jmpdefer(fn, sp);
         .          .    514:// called from deferreturn.
         .          .    515:// 1. pop the caller
         .          .    516:// 2. sub 5 bytes from the callers return
ROUTINE ======================== runtime.rawbyteslice in /home/isucon/.local/go/src/runtime/string.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    297:}
         .          .    298:
         .          .    299:// rawbyteslice allocates a new byte slice. The byte slice is not zeroed.
         .          .    300:func rawbyteslice(size int) (b []byte) {
         .          .    301:	cap := roundupsize(uintptr(size))
         .       10ms    302:	p := mallocgc(cap, nil, flagNoScan|flagNoZero)
         .          .    303:	if cap != uintptr(size) {
         .          .    304:		memclr(add(p, uintptr(size)), cap-uintptr(size))
         .          .    305:	}
         .          .    306:
         .          .    307:	*(*slice)(unsafe.Pointer(&b)) = slice{p, size, int(cap)}
ROUTINE ======================== runtime.rawmem in /home/isucon/.local/go/src/runtime/malloc.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    804:}
         .          .    805:
         .          .    806:// rawmem returns a chunk of pointerless memory.  It is
         .          .    807:// not zeroed.
         .          .    808:func rawmem(size uintptr) unsafe.Pointer {
         .       10ms    809:	return mallocgc(size, nil, flagNoScan|flagNoZero)
         .          .    810:}
         .          .    811:
         .          .    812:func profilealloc(mp *m, x unsafe.Pointer, size uintptr) {
         .          .    813:	mp.mcache.next_sample = nextSample()
         .          .    814:	mProf_Malloc(x, size)
ROUTINE ======================== runtime.rawstring in /home/isucon/.local/go/src/runtime/string.go
     350ms      2.31s (flat, cum)  4.15% of Total
         .          .    278:
         .          .    279:// rawstring allocates storage for a new string. The returned
         .          .    280:// string and byte slice both refer to the same storage.
         .          .    281:// The storage is not zeroed. Callers should use
         .          .    282:// b to set the string contents and then drop b.
     130ms      130ms    283:func rawstring(size int) (s string, b []byte) {
      80ms      1.99s    284:	p := mallocgc(uintptr(size), nil, flagNoScan|flagNoZero)
         .          .    285:
      50ms       60ms    286:	stringStructOf(&s).str = p
      30ms       30ms    287:	stringStructOf(&s).len = size
         .          .    288:
      30ms       70ms    289:	*(*slice)(unsafe.Pointer(&b)) = slice{p, size, size}
         .          .    290:
         .          .    291:	for {
         .          .    292:		ms := maxstring
      10ms       10ms    293:		if uintptr(size) <= uintptr(ms) || atomic.Casuintptr((*uintptr)(unsafe.Pointer(&maxstring)), uintptr(ms), uintptr(size)) {
      20ms       20ms    294:			return
         .          .    295:		}
         .          .    296:	}
         .          .    297:}
         .          .    298:
         .          .    299:// rawbyteslice allocates a new byte slice. The byte slice is not zeroed.
ROUTINE ======================== runtime.rawstringtmp in /home/isucon/.local/go/src/runtime/string.go
     210ms      2.52s (flat, cum)  4.53% of Total
         .          .    101:	ptr := uintptr(stringStructOf(&s).str)
         .          .    102:	stk := getg().stack
         .          .    103:	return stk.lo <= ptr && ptr < stk.hi
         .          .    104:}
         .          .    105:
     100ms      100ms    106:func rawstringtmp(buf *tmpBuf, l int) (s string, b []byte) {
         .          .    107:	if buf != nil && l <= len(buf) {
         .          .    108:		b = buf[:l]
         .          .    109:		s = slicebytetostringtmp(b)
         .          .    110:	} else {
     100ms      2.41s    111:		s, b = rawstring(l)
         .          .    112:	}
      10ms       10ms    113:	return
         .          .    114:}
         .          .    115:
         .          .    116:func slicebytetostringtmp(b []byte) string {
         .          .    117:	// Return a "string" referring to the actual []byte bytes.
         .          .    118:	// This is only for use by internal compiler optimizations
ROUTINE ======================== runtime.readgstatus in /home/isucon/.local/go/src/runtime/proc.go
     420ms      530ms (flat, cum)  0.95% of Total
         .          .    625:}
         .          .    626:
         .          .    627:// All reads and writes of g's status go through readgstatus, casgstatus
         .          .    628:// castogscanstatus, casfrom_Gscanstatus.
         .          .    629://go:nosplit
      50ms       50ms    630:func readgstatus(gp *g) uint32 {
     370ms      480ms    631:	return atomic.Load(&gp.atomicstatus)
         .          .    632:}
         .          .    633:
         .          .    634:// Ownership of gscanvalid:
         .          .    635://
         .          .    636:// If gp is running (meaning status == _Grunning or _Grunning|_Gscan),
ROUTINE ======================== runtime.readvarint in /home/isucon/.local/go/src/runtime/symtab.go
      90ms       90ms (flat, cum)  0.16% of Total
         .          .    406:	*val += vdelta
         .          .    407:	return p, true
         .          .    408:}
         .          .    409:
         .          .    410:// readvarint reads a varint from p.
      20ms       20ms    411:func readvarint(p []byte) (newp []byte, val uint32) {
         .          .    412:	var v, shift uint32
         .          .    413:	for {
         .          .    414:		b := p[0]
      10ms       10ms    415:		p = p[1:]
      30ms       30ms    416:		v |= (uint32(b) & 0x7F) << shift
      10ms       10ms    417:		if b&0x80 == 0 {
         .          .    418:			break
         .          .    419:		}
         .          .    420:		shift += 7
         .          .    421:	}
      20ms       20ms    422:	return p, v
         .          .    423:}
         .          .    424:
         .          .    425:type stackmap struct {
         .          .    426:	n        int32   // number of bitmaps
         .          .    427:	nbit     int32   // number of bits in each bitmap
ROUTINE ======================== runtime.ready in /home/isucon/.local/go/src/runtime/proc.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    524:		dumpgstatus(gp)
         .          .    525:		throw("bad g->status in ready")
         .          .    526:	}
         .          .    527:
         .          .    528:	// status is Gwaiting or Gscanwaiting, make Grunnable and put on runq
         .       10ms    529:	casgstatus(gp, _Gwaiting, _Grunnable)
         .          .    530:	runqput(_g_.m.p.ptr(), gp, true)
         .          .    531:	if atomic.Load(&sched.npidle) != 0 && atomic.Load(&sched.nmspinning) == 0 { // TODO: fast atomic
         .          .    532:		wakep()
         .          .    533:	}
         .          .    534:	_g_.m.locks--
ROUTINE ======================== runtime.reentersyscall in /home/isucon/.local/go/src/runtime/proc.go
      60ms       90ms (flat, cum)  0.16% of Total
         .          .   2258:// and we wait for the increment before emitting traceGoSysExit.
         .          .   2259:// Note that the increment is done even if tracing is not enabled,
         .          .   2260:// because tracing can be enabled in the middle of syscall. We don't want the wait to hang.
         .          .   2261://
         .          .   2262://go:nosplit
      20ms       20ms   2263:func reentersyscall(pc, sp uintptr) {
         .          .   2264:	_g_ := getg()
         .          .   2265:
         .          .   2266:	// Disable preemption because during this function g is in Gsyscall status,
         .          .   2267:	// but can have inconsistent g->sched, do not let GC observe it.
         .          .   2268:	_g_.m.locks++
         .          .   2269:
         .          .   2270:	// Entersyscall must not call any function that might split/grow the stack.
         .          .   2271:	// (See details in comment above.)
         .          .   2272:	// Catch calls that might, by replacing the stack guard with something that
         .          .   2273:	// will trip any stack check and leaving a flag to tell newstack to die.
         .          .   2274:	_g_.stackguard0 = stackPreempt
         .          .   2275:	_g_.throwsplit = true
         .          .   2276:
         .          .   2277:	// Leave SP around for GC and traceback.
         .          .   2278:	save(pc, sp)
         .          .   2279:	_g_.syscallsp = sp
         .          .   2280:	_g_.syscallpc = pc
         .       30ms   2281:	casgstatus(_g_, _Grunning, _Gsyscall)
         .          .   2282:	if _g_.syscallsp < _g_.stack.lo || _g_.stack.hi < _g_.syscallsp {
         .          .   2283:		systemstack(func() {
         .          .   2284:			print("entersyscall inconsistent ", hex(_g_.syscallsp), " [", hex(_g_.stack.lo), ",", hex(_g_.stack.hi), "]\n")
         .          .   2285:			throw("entersyscall")
         .          .   2286:		})
         .          .   2287:	}
         .          .   2288:
         .          .   2289:	if trace.enabled {
         .          .   2290:		systemstack(traceGoSysCall)
         .          .   2291:		// systemstack itself clobbers g.sched.{pc,sp} and we might
         .          .   2292:		// need them later when the G is genuinely blocked in a
         .          .   2293:		// syscall
         .          .   2294:		save(pc, sp)
         .          .   2295:	}
         .          .   2296:
         .          .   2297:	if atomic.Load(&sched.sysmonwait) != 0 { // TODO: fast atomic
         .          .   2298:		systemstack(entersyscall_sysmon)
         .          .   2299:		save(pc, sp)
         .          .   2300:	}
         .          .   2301:
      30ms       30ms   2302:	if _g_.m.p.ptr().runSafePointFn != 0 {
         .          .   2303:		// runSafePointFn may stack split if run on this stack
         .          .   2304:		systemstack(runSafePointFn)
         .          .   2305:		save(pc, sp)
         .          .   2306:	}
         .          .   2307:
         .          .   2308:	_g_.m.syscalltick = _g_.m.p.ptr().syscalltick
         .          .   2309:	_g_.sysblocktraced = true
         .          .   2310:	_g_.m.mcache = nil
         .          .   2311:	_g_.m.p.ptr().m = 0
      10ms       10ms   2312:	atomic.Store(&_g_.m.p.ptr().status, _Psyscall)
         .          .   2313:	if sched.gcwaiting != 0 {
         .          .   2314:		systemstack(entersyscall_gcwait)
         .          .   2315:		save(pc, sp)
         .          .   2316:	}
         .          .   2317:
ROUTINE ======================== runtime.reimburseSweepCredit in /home/isucon/.local/go/src/runtime/mgcsweep.go
      20ms       30ms (flat, cum) 0.054% of Total
         .          .    389:}
         .          .    390:
         .          .    391:// reimburseSweepCredit records that unusableBytes bytes of a
         .          .    392:// just-allocated span are not available for object allocation. This
         .          .    393:// offsets the worst-case charge performed by deductSweepCredit.
      10ms       10ms    394:func reimburseSweepCredit(unusableBytes uintptr) {
         .          .    395:	if mheap_.sweepPagesPerByte == 0 {
         .          .    396:		// Nobody cares about the credit. Avoid the atomic.
         .          .    397:		return
         .          .    398:	}
         .       10ms    399:	if int64(atomic.Xadd64(&mheap_.spanBytesAlloc, -int64(unusableBytes))) < 0 {
         .          .    400:		throw("spanBytesAlloc underflow")
         .          .    401:	}
      10ms       10ms    402:}
         .          .    403:
         .          .    404:func dumpFreeList(s *mspan) {
         .          .    405:	printlock()
         .          .    406:	print("runtime: free list of span ", s, ":\n")
         .          .    407:	sstart := uintptr(s.start << _PageShift)
ROUTINE ======================== runtime.removefinalizer in /home/isucon/.local/go/src/runtime/mheap.go
         0       20ms (flat, cum) 0.036% of Total
         .          .   1109:	return false
         .          .   1110:}
         .          .   1111:
         .          .   1112:// Removes the finalizer (if any) from the object p.
         .          .   1113:func removefinalizer(p unsafe.Pointer) {
         .       20ms   1114:	s := (*specialfinalizer)(unsafe.Pointer(removespecial(p, _KindSpecialFinalizer)))
         .          .   1115:	if s == nil {
         .          .   1116:		return // there wasn't a finalizer to remove
         .          .   1117:	}
         .          .   1118:	lock(&mheap_.speciallock)
         .          .   1119:	mheap_.specialfinalizeralloc.free(unsafe.Pointer(s))
ROUTINE ======================== runtime.removespecial in /home/isucon/.local/go/src/runtime/mheap.go
         0       20ms (flat, cum) 0.036% of Total
         .          .   1032:
         .          .   1033:	// Ensure that the span is swept.
         .          .   1034:	// Sweeping accesses the specials list w/o locks, so we have
         .          .   1035:	// to synchronize with it. And it's just much safer.
         .          .   1036:	mp := acquirem()
         .       10ms   1037:	span.ensureSwept()
         .          .   1038:
         .          .   1039:	offset := uintptr(p) - uintptr(span.start<<_PageShift)
         .          .   1040:
         .          .   1041:	lock(&span.speciallock)
         .          .   1042:	t := &span.specials
         .          .   1043:	for {
         .          .   1044:		s := *t
         .          .   1045:		if s == nil {
         .          .   1046:			break
         .          .   1047:		}
         .          .   1048:		// This function is used for finalizers only, so we don't check for
         .          .   1049:		// "interior" specials (p must be exactly equal to s->offset).
         .          .   1050:		if offset == uintptr(s.offset) && kind == s.kind {
         .          .   1051:			*t = s.next
         .       10ms   1052:			unlock(&span.speciallock)
         .          .   1053:			releasem(mp)
         .          .   1054:			return s
         .          .   1055:		}
         .          .   1056:		t = &s.next
         .          .   1057:	}
ROUTINE ======================== runtime.restartg in /home/isucon/.local/go/src/runtime/proc.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    856:			throw("processing Gscanenqueue on wrong m")
         .          .    857:		}
         .          .    858:		dropg()
         .          .    859:		ready(gp, 0)
         .          .    860:	}
      10ms       10ms    861:}
         .          .    862:
         .          .    863:// stopTheWorld stops all P's from executing goroutines, interrupting
         .          .    864:// all goroutines at GC safe points and records reason as the reason
         .          .    865:// for the stop. On return, only the current goroutine's P is running.
         .          .    866:// stopTheWorld must not be called from a system stack and the caller
ROUTINE ======================== runtime.runqget in /home/isucon/.local/go/src/runtime/proc.go
      20ms       40ms (flat, cum) 0.072% of Total
         .          .   3964:	for {
         .          .   3965:		next := _p_.runnext
         .          .   3966:		if next == 0 {
         .          .   3967:			break
         .          .   3968:		}
         .       10ms   3969:		if _p_.runnext.cas(next, 0) {
      10ms       10ms   3970:			return next.ptr(), true
         .          .   3971:		}
         .          .   3972:	}
         .          .   3973:
         .          .   3974:	for {
         .       10ms   3975:		h := atomic.Load(&_p_.runqhead) // load-acquire, synchronize with other consumers
         .          .   3976:		t := _p_.runqtail
         .          .   3977:		if t == h {
         .          .   3978:			return nil, false
         .          .   3979:		}
      10ms       10ms   3980:		gp := _p_.runq[h%uint32(len(_p_.runq))].ptr()
         .          .   3981:		if atomic.Cas(&_p_.runqhead, h, h+1) { // cas-release, commits consume
         .          .   3982:			return gp, false
         .          .   3983:		}
         .          .   3984:	}
         .          .   3985:}
ROUTINE ======================== runtime.runqput in /home/isucon/.local/go/src/runtime/proc.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   3890:	}
         .          .   3891:
         .          .   3892:	if next {
         .          .   3893:	retryNext:
         .          .   3894:		oldnext := _p_.runnext
         .       10ms   3895:		if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) {
         .          .   3896:			goto retryNext
         .          .   3897:		}
         .          .   3898:		if oldnext == 0 {
         .          .   3899:			return
         .          .   3900:		}
ROUTINE ======================== runtime.scanblock in /home/isucon/.local/go/src/runtime/mgcmark.go
      70ms       80ms (flat, cum)  0.14% of Total
         .          .    936:		bits := uint32(*addb(ptrmask, i/(sys.PtrSize*8)))
         .          .    937:		if bits == 0 {
         .          .    938:			i += sys.PtrSize * 8
         .          .    939:			continue
         .          .    940:		}
      20ms       20ms    941:		for j := 0; j < 8 && i < n; j++ {
      10ms       10ms    942:			if bits&1 != 0 {
         .          .    943:				// Same work as in scanobject; see comments there.
         .          .    944:				obj := *(*uintptr)(unsafe.Pointer(b + i))
      20ms       20ms    945:				if obj != 0 && arena_start <= obj && obj < arena_used {
      10ms       20ms    946:					if obj, hbits, span := heapBitsForObject(obj, b, i); obj != 0 {
         .          .    947:						greyobject(obj, b, i, hbits, span, gcw)
         .          .    948:					}
         .          .    949:				}
         .          .    950:			}
      10ms       10ms    951:			bits >>= 1
         .          .    952:			i += sys.PtrSize
         .          .    953:		}
         .          .    954:	}
         .          .    955:}
         .          .    956:
ROUTINE ======================== runtime.scanframeworker in /home/isucon/.local/go/src/runtime/mgcmark.go
      30ms      100ms (flat, cum)  0.18% of Total
         .          .    704:		print("scanframe ", funcname(f), "\n")
         .          .    705:	}
         .          .    706:	if targetpc != f.entry {
         .          .    707:		targetpc--
         .          .    708:	}
         .       40ms    709:	pcdata := pcdatavalue(f, _PCDATA_StackMapIndex, targetpc, cache)
         .          .    710:	if pcdata == -1 {
         .          .    711:		// We do not have a valid pcdata value but there might be a
         .          .    712:		// stackmap for this function.  It is likely that we are looking
         .          .    713:		// at the function prologue, assume so and hope for the best.
         .          .    714:		pcdata = 0
         .          .    715:	}
         .          .    716:
         .          .    717:	// Scan local variables if stack frame has been allocated.
         .          .    718:	size := frame.varp - frame.sp
         .          .    719:	var minsize uintptr
         .          .    720:	switch sys.TheChar {
         .          .    721:	case '7':
         .          .    722:		minsize = sys.SpAlign
         .          .    723:	default:
         .          .    724:		minsize = sys.MinFrameSize
         .          .    725:	}
         .          .    726:	if size > minsize {
         .          .    727:		stkmap := (*stackmap)(funcdata(f, _FUNCDATA_LocalsPointerMaps))
         .          .    728:		if stkmap == nil || stkmap.n <= 0 {
         .          .    729:			print("runtime: frame ", funcname(f), " untyped locals ", hex(frame.varp-size), "+", hex(size), "\n")
         .          .    730:			throw("missing stackmap")
         .          .    731:		}
         .          .    732:
         .          .    733:		// Locals bitmap information, scan just the pointers in locals.
         .          .    734:		if pcdata < 0 || pcdata >= stkmap.n {
         .          .    735:			// don't know where we are
         .          .    736:			print("runtime: pcdata is ", pcdata, " and ", stkmap.n, " locals stack map entries for ", funcname(f), " (targetpc=", targetpc, ")\n")
         .          .    737:			throw("scanframe: bad symbol table")
         .          .    738:		}
         .          .    739:		bv := stackmapdata(stkmap, pcdata)
         .          .    740:		size = uintptr(bv.n) * sys.PtrSize
         .          .    741:		scanblock(frame.varp-size, size, bv.bytedata, gcw)
         .          .    742:	}
         .          .    743:
         .          .    744:	// Scan arguments.
         .          .    745:	if frame.arglen > 0 {
         .          .    746:		var bv bitvector
         .          .    747:		if frame.argmap != nil {
         .          .    748:			bv = *frame.argmap
         .          .    749:		} else {
         .          .    750:			stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))
      20ms       20ms    751:			if stkmap == nil || stkmap.n <= 0 {
         .          .    752:				print("runtime: frame ", funcname(f), " untyped args ", hex(frame.argp), "+", hex(frame.arglen), "\n")
         .          .    753:				throw("missing stackmap")
         .          .    754:			}
         .          .    755:			if pcdata < 0 || pcdata >= stkmap.n {
         .          .    756:				// don't know where we are
         .          .    757:				print("runtime: pcdata is ", pcdata, " and ", stkmap.n, " args stack map entries for ", funcname(f), " (targetpc=", targetpc, ")\n")
         .          .    758:				throw("scanframe: bad symbol table")
         .          .    759:			}
      10ms       10ms    760:			bv = stackmapdata(stkmap, pcdata)
         .          .    761:		}
         .       30ms    762:		scanblock(frame.argp, uintptr(bv.n)*sys.PtrSize, bv.bytedata, gcw)
         .          .    763:	}
         .          .    764:}
         .          .    765:
         .          .    766:type gcDrainFlags int
         .          .    767:
ROUTINE ======================== runtime.scang in /home/isucon/.local/go/src/runtime/proc.go
     360ms      1.05s (flat, cum)  1.89% of Total
         .          .    775:	// Endeavor to get gcscandone set to true,
         .          .    776:	// either by doing the stack scan ourselves or by coercing gp to scan itself.
         .          .    777:	// gp.gcscandone can transition from false to true when we're not looking
         .          .    778:	// (if we asked for preemption), so any time we lock the status using
         .          .    779:	// castogscanstatus we have to double-check that the scan is still not done.
      70ms       70ms    780:	for !gp.gcscandone {
     130ms      640ms    781:		switch s := readgstatus(gp); s {
         .          .    782:		default:
         .          .    783:			dumpgstatus(gp)
         .          .    784:			throw("stopg: invalid status")
         .          .    785:
         .          .    786:		case _Gdead:
         .          .    787:			// No stack.
         .          .    788:			gp.gcscandone = true
         .          .    789:
         .          .    790:		case _Gcopystack:
         .          .    791:		// Stack being switched. Go around again.
         .          .    792:
      10ms       10ms    793:		case _Grunnable, _Gsyscall, _Gwaiting:
         .          .    794:			// Claim goroutine by setting scan bit.
         .          .    795:			// Racing with execution or readying of gp.
         .          .    796:			// The scan bit keeps them from running
         .          .    797:			// the goroutine until we're done.
         .          .    798:			if castogscanstatus(gp, s, s|_Gscan) {
         .          .    799:				if !gp.gcscandone {
         .      170ms    800:					scanstack(gp)
         .          .    801:					gp.gcscandone = true
         .          .    802:				}
         .       10ms    803:				restartg(gp)
         .          .    804:			}
         .          .    805:
         .          .    806:		case _Gscanwaiting:
         .          .    807:		// newstack is doing a scan for us right now. Wait.
         .          .    808:
      40ms       40ms    809:		case _Grunning:
         .          .    810:			// Goroutine running. Try to preempt execution so it can scan itself.
         .          .    811:			// The preemption handler (in newstack) does the actual scan.
         .          .    812:
         .          .    813:			// Optimization: if there is already a pending preemption request
         .          .    814:			// (from the previous loop iteration), don't bother with the atomics.
     110ms      110ms    815:			if gp.preemptscan && gp.preempt && gp.stackguard0 == stackPreempt {
         .          .    816:				break
         .          .    817:			}
         .          .    818:
         .          .    819:			// Ask for preemption and self scan.
         .          .    820:			if castogscanstatus(gp, _Grunning, _Gscanrunning) {
ROUTINE ======================== runtime.scanobject in /home/isucon/.local/go/src/runtime/heapdump.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    730:			break // end of object
         .          .    731:		}
         .          .    732:		if hbits.isPointer() {
         .          .    733:			tmpbuf[i/8] |= 1 << (i % 8)
         .          .    734:		}
      10ms       10ms    735:		hbits = hbits.next()
         .          .    736:	}
         .          .    737:	return bitvector{int32(i), &tmpbuf[0]}
         .          .    738:}
ROUTINE ======================== runtime.scanobject in /home/isucon/.local/go/src/runtime/mgcmark.go
     4.60s      6.30s (flat, cum) 11.32% of Total
         .          .    957:// scanobject scans the object starting at b, adding pointers to gcw.
         .          .    958:// b must point to the beginning of a heap object; scanobject consults
         .          .    959:// the GC bitmap for the pointer mask and the spans for the size of the
         .          .    960:// object (it ignores n).
         .          .    961://go:nowritebarrier
      10ms       10ms    962:func scanobject(b uintptr, gcw *gcWork) {
         .          .    963:	// Note that arena_used may change concurrently during
         .          .    964:	// scanobject and hence scanobject may encounter a pointer to
         .          .    965:	// a newly allocated heap object that is *not* in
         .          .    966:	// [start,used). It will not mark this object; however, we
         .          .    967:	// know that it was just installed by a mutator, which means
         .          .    968:	// that mutator will execute a write barrier and take care of
         .          .    969:	// marking it. This is even more pronounced on relaxed memory
         .          .    970:	// architectures since we access arena_used without barriers
         .          .    971:	// or synchronization, but the same logic applies.
         .          .    972:	arena_start := mheap_.arena_start
         .          .    973:	arena_used := mheap_.arena_used
         .          .    974:
         .          .    975:	// Find bits of the beginning of the object.
         .          .    976:	// b must point to the beginning of a heap object, so
         .          .    977:	// we can get its bits and span directly.
      10ms       10ms    978:	hbits := heapBitsForAddr(b)
         .          .    979:	s := spanOfUnchecked(b)
         .          .    980:	n := s.elemsize
      30ms       30ms    981:	if n == 0 {
         .          .    982:		throw("scanobject n == 0")
         .          .    983:	}
         .          .    984:
         .          .    985:	var i uintptr
     260ms      260ms    986:	for i = 0; i < n; i += sys.PtrSize {
         .          .    987:		// Find bits for this word.
      20ms       20ms    988:		if i != 0 {
         .          .    989:			// Avoid needless hbits.next() on last iteration.
     1.16s      1.16s    990:			hbits = hbits.next()
         .          .    991:		}
         .          .    992:		// During checkmarking, 1-word objects store the checkmark
         .          .    993:		// in the type bit for the one word. The only one-word objects
         .          .    994:		// are pointers, or else they'd be merged with other non-pointer
         .          .    995:		// data into larger allocations.
     1.34s      1.34s    996:		bits := hbits.bits()
     250ms      250ms    997:		if i >= 2*sys.PtrSize && bits&bitMarked == 0 {
         .          .    998:			break // no more pointers in this object
         .          .    999:		}
     140ms      140ms   1000:		if bits&bitPointer == 0 {
         .          .   1001:			continue // not a pointer
         .          .   1002:		}
         .          .   1003:
         .          .   1004:		// Work here is duplicated in scanblock and above.
         .          .   1005:		// If you make changes here, make changes there too.
      50ms       50ms   1006:		obj := *(*uintptr)(unsafe.Pointer(b + i))
         .          .   1007:
         .          .   1008:		// At this point we have extracted the next potential pointer.
         .          .   1009:		// Check if it points into heap and not back at the current object.
     1.02s      1.02s   1010:		if obj != 0 && arena_start <= obj && obj < arena_used && obj-b >= n {
         .          .   1011:			// Mark the object.
     170ms      960ms   1012:			if obj, hbits, span := heapBitsForObject(obj, b, i); obj != 0 {
      90ms         1s   1013:				greyobject(obj, b, i, hbits, span, gcw)
         .          .   1014:			}
         .          .   1015:		}
         .          .   1016:	}
      20ms       20ms   1017:	gcw.bytesMarked += uint64(n)
      20ms       20ms   1018:	gcw.scanWork += int64(i)
      10ms       10ms   1019:}
         .          .   1020:
         .          .   1021:// Shade the object if it isn't already.
         .          .   1022:// The object is not nil and known to be in the heap.
         .          .   1023:// Preemption must be disabled.
         .          .   1024://go:nowritebarrier
ROUTINE ======================== runtime.scanstack in /home/isucon/.local/go/src/runtime/mgcmark.go
         0      170ms (flat, cum)  0.31% of Total
         .          .    677:		}
         .          .    678:		n++
         .          .    679:
         .          .    680:		return true
         .          .    681:	}
         .      170ms    682:	gentraceback(^uintptr(0), ^uintptr(0), 0, gp, 0, nil, 0x7fffffff, scanframe, nil, 0)
         .          .    683:	tracebackdefers(gp, scanframe, nil)
         .          .    684:	if gcphase == _GCmarktermination {
         .          .    685:		gcw.dispose()
         .          .    686:	}
         .          .    687:	if gcphase == _GCmark {
ROUTINE ======================== runtime.scanstack.func1 in /home/isucon/.local/go/src/runtime/mgcmark.go
      10ms      110ms (flat, cum)   0.2% of Total
         .          .    654:
         .          .    655:	var cache pcvalueCache
         .          .    656:	gcw := &getg().m.p.ptr().gcw
         .          .    657:	n := 0
         .          .    658:	scanframe := func(frame *stkframe, unused unsafe.Pointer) bool {
      10ms      110ms    659:		scanframeworker(frame, &cache, gcw)
         .          .    660:
         .          .    661:		if frame.fp > nextBarrier {
         .          .    662:			// We skip installing a barrier on bottom-most
         .          .    663:			// frame because on LR machines this LR is not
         .          .    664:			// on the stack.
ROUTINE ======================== runtime.schedule in /home/isucon/.local/go/src/runtime/proc.go
      10ms      180ms (flat, cum)  0.32% of Total
         .          .   2028:	if _g_.m.locks != 0 {
         .          .   2029:		throw("schedule: holding locks")
         .          .   2030:	}
         .          .   2031:
         .          .   2032:	if _g_.m.lockedg != nil {
         .       10ms   2033:		stoplockedm()
         .          .   2034:		execute(_g_.m.lockedg, false) // Never returns.
         .          .   2035:	}
         .          .   2036:
         .          .   2037:top:
         .          .   2038:	if sched.gcwaiting != 0 {
         .       30ms   2039:		gcstopm()
         .          .   2040:		goto top
         .          .   2041:	}
         .          .   2042:	if _g_.m.p.ptr().runSafePointFn != 0 {
         .          .   2043:		runSafePointFn()
         .          .   2044:	}
         .          .   2045:
         .          .   2046:	var gp *g
         .          .   2047:	var inheritTime bool
         .          .   2048:	if trace.enabled || trace.shutdown {
         .          .   2049:		gp = traceReader()
         .          .   2050:		if gp != nil {
         .          .   2051:			casgstatus(gp, _Gwaiting, _Grunnable)
         .          .   2052:			traceGoUnpark(gp, 0)
         .          .   2053:		}
         .          .   2054:	}
      10ms       10ms   2055:	if gp == nil && gcBlackenEnabled != 0 {
         .       10ms   2056:		gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())
         .          .   2057:	}
         .          .   2058:	if gp == nil {
         .          .   2059:		// Check the global runnable queue once in a while to ensure fairness.
         .          .   2060:		// Otherwise two goroutines can completely occupy the local runqueue
         .          .   2061:		// by constantly respawning each other.
         .          .   2062:		if _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {
         .          .   2063:			lock(&sched.lock)
         .          .   2064:			gp = globrunqget(_g_.m.p.ptr(), 1)
         .          .   2065:			unlock(&sched.lock)
         .          .   2066:		}
         .          .   2067:	}
         .          .   2068:	if gp == nil {
         .       40ms   2069:		gp, inheritTime = runqget(_g_.m.p.ptr())
         .          .   2070:		if gp != nil && _g_.m.spinning {
         .          .   2071:			throw("schedule: spinning with local work")
         .          .   2072:		}
         .          .   2073:	}
         .          .   2074:	if gp == nil {
         .       60ms   2075:		gp, inheritTime = findrunnable() // blocks until work is available
         .          .   2076:	}
         .          .   2077:
         .          .   2078:	// This thread is going to run a goroutine and is not spinning anymore,
         .          .   2079:	// so if it was marked as spinning we need to reset it now and potentially
         .          .   2080:	// start a new spinning M.
         .          .   2081:	if _g_.m.spinning {
         .          .   2082:		resetspinning()
         .          .   2083:	}
         .          .   2084:
         .          .   2085:	if gp.lockedm != nil {
         .          .   2086:		// Hands off own p to the locked m,
         .          .   2087:		// then blocks waiting for a new p.
         .          .   2088:		startlockedm(gp)
         .          .   2089:		goto top
         .          .   2090:	}
         .          .   2091:
         .       20ms   2092:	execute(gp, inheritTime)
         .          .   2093:}
         .          .   2094:
         .          .   2095:// dropg removes the association between m and the current goroutine m->curg (gp for short).
         .          .   2096:// Typically a caller sets gp's status away from Grunning and then
         .          .   2097:// immediately calls dropg to finish the job. The caller is also responsible
ROUTINE ======================== runtime.send in /home/isucon/.local/go/src/runtime/chan.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    257:			c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz
         .          .    258:		}
         .          .    259:	}
         .          .    260:	unlockf()
         .          .    261:	if sg.elem != nil {
         .       10ms    262:		sendDirect(c.elemtype, sg, ep)
         .          .    263:		sg.elem = nil
         .          .    264:	}
         .          .    265:	gp := sg.g
         .          .    266:	gp.param = unsafe.Pointer(sg)
         .          .    267:	if sg.releasetime != 0 {
ROUTINE ======================== runtime.sendDirect in /home/isucon/.local/go/src/runtime/chan.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    284:	// Once we read sg.elem out of sg, it will no longer
         .          .    285:	// be updated if the destination's stack gets copied (shrunk).
         .          .    286:	// So make sure that no preemption points can happen between read & use.
         .          .    287:	dst := sg.elem
         .          .    288:	memmove(dst, src, t.size)
         .       10ms    289:	typeBitsBulkBarrier(t, uintptr(dst), t.size)
         .          .    290:}
         .          .    291:
         .          .    292:func closechan(c *hchan) {
         .          .    293:	if c == nil {
         .          .    294:		panic("close of nil channel")
ROUTINE ======================== runtime.setprofilebucket in /home/isucon/.local/go/src/runtime/mheap.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   1126:	b       *bucket
         .          .   1127:}
         .          .   1128:
         .          .   1129:// Set the heap profile bucket associated with addr to b.
         .          .   1130:func setprofilebucket(p unsafe.Pointer, b *bucket) {
         .       10ms   1131:	lock(&mheap_.speciallock)
         .          .   1132:	s := (*specialprofile)(mheap_.specialprofilealloc.alloc())
         .          .   1133:	unlock(&mheap_.speciallock)
         .          .   1134:	s.special.kind = _KindSpecialProfile
         .          .   1135:	s.b = b
         .          .   1136:	if !addspecial(p, &s.special) {
ROUTINE ======================== runtime.shade in /home/isucon/.local/go/src/runtime/mgcmark.go
     120ms      400ms (flat, cum)  0.72% of Total
         .          .   1021:// Shade the object if it isn't already.
         .          .   1022:// The object is not nil and known to be in the heap.
         .          .   1023:// Preemption must be disabled.
         .          .   1024://go:nowritebarrier
         .          .   1025:func shade(b uintptr) {
      50ms      190ms   1026:	if obj, hbits, span := heapBitsForObject(b, 0, 0); obj != 0 {
      50ms       50ms   1027:		gcw := &getg().m.p.ptr().gcw
      10ms      140ms   1028:		greyobject(obj, 0, 0, hbits, span, gcw)
      10ms       10ms   1029:		if gcphase == _GCmarktermination || gcBlackenPromptly {
         .          .   1030:			// Ps aren't allowed to cache work during mark
         .          .   1031:			// termination.
         .       10ms   1032:			gcw.dispose()
         .          .   1033:		}
         .          .   1034:	}
         .          .   1035:}
         .          .   1036:
         .          .   1037:// obj is the start of an object with mark mbits.
ROUTINE ======================== runtime.slicebytetostring in /home/isucon/.local/go/src/runtime/string.go
     380ms      3.20s (flat, cum)  5.75% of Total
         .          .     71:	return concatstrings(buf, a[:])
         .          .     72:}
         .          .     73:
         .          .     74:// Buf is a fixed-size buffer for the result,
         .          .     75:// it is not nil if the result does not escape.
      60ms       60ms     76:func slicebytetostring(buf *tmpBuf, b []byte) string {
         .          .     77:	l := len(b)
      10ms       10ms     78:	if l == 0 {
         .          .     79:		// Turns out to be a relatively common case.
         .          .     80:		// Consider that you want to parse out data between parens in "foo()bar",
         .          .     81:		// you find the indices and convert the subslice to string.
         .          .     82:		return ""
         .          .     83:	}
         .          .     84:	if raceenabled && l > 0 {
         .          .     85:		racereadrangepc(unsafe.Pointer(&b[0]),
         .          .     86:			uintptr(l),
         .          .     87:			getcallerpc(unsafe.Pointer(&b)),
         .          .     88:			funcPC(slicebytetostring))
         .          .     89:	}
         .          .     90:	if msanenabled && l > 0 {
         .          .     91:		msanread(unsafe.Pointer(&b[0]), uintptr(l))
         .          .     92:	}
      90ms      2.60s     93:	s, c := rawstringtmp(buf, l)
     190ms      500ms     94:	copy(c, b)
      30ms       30ms     95:	return s
         .          .     96:}
         .          .     97:
         .          .     98:// stringDataOnStack reports whether the string's data is
         .          .     99:// stored on the current goroutine's stack.
         .          .    100:func stringDataOnStack(s string) bool {
ROUTINE ======================== runtime.stackalloc in /home/isucon/.local/go/src/runtime/stack.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .    309:		c.stackcache[order].size = 0
         .          .    310:	}
         .          .    311:	unlock(&stackpoolmu)
         .          .    312:}
         .          .    313:
      10ms       10ms    314:func stackalloc(n uint32) (stack, []stkbar) {
         .          .    315:	// Stackalloc must be called on scheduler stack, so that we
         .          .    316:	// never try to grow the stack during the code that stackalloc runs.
         .          .    317:	// Doing so would cause a deadlock (issue 1547).
         .          .    318:	thisg := getg()
         .          .    319:	if thisg != thisg.m.g0 {
         .          .    320:		throw("stackalloc not on scheduler stack")
         .          .    321:	}
         .          .    322:	if n&(n-1) != 0 {
         .          .    323:		throw("stack size not a power of 2")
         .          .    324:	}
         .          .    325:	if stackDebug >= 1 {
         .          .    326:		print("stackalloc ", n, "\n")
         .          .    327:	}
         .          .    328:
         .          .    329:	// Compute the size of stack barrier array.
         .          .    330:	maxstkbar := gcMaxStackBarriers(int(n))
         .          .    331:	nstkbar := unsafe.Sizeof(stkbar{}) * uintptr(maxstkbar)
         .          .    332:
         .          .    333:	if debug.efence != 0 || stackFromSystem != 0 {
         .          .    334:		v := sysAlloc(round(uintptr(n), _PageSize), &memstats.stacks_sys)
         .          .    335:		if v == nil {
         .          .    336:			throw("out of memory (stackalloc)")
         .          .    337:		}
         .          .    338:		top := uintptr(n) - nstkbar
         .          .    339:		stkbarSlice := slice{add(v, top), 0, maxstkbar}
         .          .    340:		return stack{uintptr(v), uintptr(v) + top}, *(*[]stkbar)(unsafe.Pointer(&stkbarSlice))
         .          .    341:	}
         .          .    342:
         .          .    343:	// Small stacks are allocated with a fixed-size free-list allocator.
         .          .    344:	// If we need a stack of a bigger size, we fall back on allocating
         .          .    345:	// a dedicated span.
         .          .    346:	var v unsafe.Pointer
         .          .    347:	if stackCache != 0 && n < _FixedStack<<_NumStackOrders && n < _StackCacheSize {
         .          .    348:		order := uint8(0)
         .          .    349:		n2 := n
         .          .    350:		for n2 > _FixedStack {
         .          .    351:			order++
         .          .    352:			n2 >>= 1
         .          .    353:		}
         .          .    354:		var x gclinkptr
         .          .    355:		c := thisg.m.mcache
         .          .    356:		if c == nil || thisg.m.preemptoff != "" || thisg.m.helpgc != 0 {
         .          .    357:			// c == nil can happen in the guts of exitsyscall or
         .          .    358:			// procresize. Just get a stack from the global pool.
         .          .    359:			// Also don't touch stackcache during gc
         .          .    360:			// as it's flushed concurrently.
         .          .    361:			lock(&stackpoolmu)
         .          .    362:			x = stackpoolalloc(order)
         .          .    363:			unlock(&stackpoolmu)
         .          .    364:		} else {
         .          .    365:			x = c.stackcache[order].list
         .          .    366:			if x.ptr() == nil {
         .       10ms    367:				stackcacherefill(c, order)
         .          .    368:				x = c.stackcache[order].list
         .          .    369:			}
         .          .    370:			c.stackcache[order].list = x.ptr().next
         .          .    371:			c.stackcache[order].size -= uintptr(n)
         .          .    372:		}
ROUTINE ======================== runtime.stackcache_clear in /home/isucon/.local/go/src/runtime/stack.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    300:	lock(&stackpoolmu)
         .          .    301:	for order := uint8(0); order < _NumStackOrders; order++ {
         .          .    302:		x := c.stackcache[order].list
         .          .    303:		for x.ptr() != nil {
         .          .    304:			y := x.ptr().next
         .       10ms    305:			stackpoolfree(x, order)
         .          .    306:			x = y
         .          .    307:		}
         .          .    308:		c.stackcache[order].list = 0
         .          .    309:		c.stackcache[order].size = 0
         .          .    310:	}
ROUTINE ======================== runtime.stackcacherefill in /home/isucon/.local/go/src/runtime/stack.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    263:	// Grab half of the allowed capacity (to prevent thrashing).
         .          .    264:	var list gclinkptr
         .          .    265:	var size uintptr
         .          .    266:	lock(&stackpoolmu)
         .          .    267:	for size < _StackCacheSize/2 {
         .       10ms    268:		x := stackpoolalloc(order)
         .          .    269:		x.ptr().next = list
         .          .    270:		list = x
         .          .    271:		size += _FixedStack << order
         .          .    272:	}
         .          .    273:	unlock(&stackpoolmu)
ROUTINE ======================== runtime.stackfree in /home/isucon/.local/go/src/runtime/stack.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    447:			unlock(&stackpoolmu)
         .          .    448:		} else {
         .          .    449:			if c.stackcache[order].size >= _StackCacheSize {
         .          .    450:				stackcacherelease(c, order)
         .          .    451:			}
      10ms       10ms    452:			x.ptr().next = c.stackcache[order].list
         .          .    453:			c.stackcache[order].list = x
         .          .    454:			c.stackcache[order].size += n
         .          .    455:		}
         .          .    456:	} else {
         .          .    457:		s := mheap_.lookup(v)
ROUTINE ======================== runtime.stackpoolalloc in /home/isucon/.local/go/src/runtime/stack.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    202:			x.ptr().next = s.freelist
         .          .    203:			s.freelist = x
         .          .    204:		}
         .          .    205:		list.insert(s)
         .          .    206:	}
      10ms       10ms    207:	x := s.freelist
         .          .    208:	if x.ptr() == nil {
         .          .    209:		throw("span has no free stacks")
         .          .    210:	}
         .          .    211:	s.freelist = x.ptr().next
         .          .    212:	s.ref++
ROUTINE ======================== runtime.stackpoolfree in /home/isucon/.local/go/src/runtime/stack.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    225:	}
         .          .    226:	if s.freelist.ptr() == nil {
         .          .    227:		// s will now have a free stack
         .          .    228:		stackpool[order].insert(s)
         .          .    229:	}
      10ms       10ms    230:	x.ptr().next = s.freelist
         .          .    231:	s.freelist = x
         .          .    232:	s.ref--
         .          .    233:	if gcphase == _GCoff && s.ref == 0 {
         .          .    234:		// Span is completely free. Return it to the heap
         .          .    235:		// immediately if we're sweeping.
ROUTINE ======================== runtime.startTheWorldWithSema in /home/isucon/.local/go/src/runtime/proc.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    981:func mhelpgc() {
         .          .    982:	_g_ := getg()
         .          .    983:	_g_.m.helpgc = -1
         .          .    984:}
         .          .    985:
         .       20ms    986:func startTheWorldWithSema() {
         .          .    987:	_g_ := getg()
         .          .    988:
         .          .    989:	_g_.m.locks++        // disable preemption because it can be holding p in a local var
         .          .    990:	gp := netpoll(false) // non-blocking
         .          .    991:	injectglist(gp)
ROUTINE ======================== runtime.step in /home/isucon/.local/go/src/runtime/symtab.go
     130ms      220ms (flat, cum)   0.4% of Total
         .          .    388:	}
         .          .    389:	return *(*unsafe.Pointer)(add(p, uintptr(i)*sys.PtrSize))
         .          .    390:}
         .          .    391:
         .          .    392:// step advances to the next pc, value pair in the encoded table.
      10ms       10ms    393:func step(p []byte, pc *uintptr, val *int32, first bool) (newp []byte, ok bool) {
      20ms       70ms    394:	p, uvdelta := readvarint(p)
         .          .    395:	if uvdelta == 0 && !first {
         .          .    396:		return nil, false
         .          .    397:	}
         .          .    398:	if uvdelta&1 != 0 {
      10ms       10ms    399:		uvdelta = ^(uvdelta >> 1)
         .          .    400:	} else {
         .          .    401:		uvdelta >>= 1
         .          .    402:	}
      10ms       10ms    403:	vdelta := int32(uvdelta)
      40ms       80ms    404:	p, pcdelta := readvarint(p)
      10ms       10ms    405:	*pc += uintptr(pcdelta * sys.PCQuantum)
      10ms       10ms    406:	*val += vdelta
      20ms       20ms    407:	return p, true
         .          .    408:}
         .          .    409:
         .          .    410:// readvarint reads a varint from p.
         .          .    411:func readvarint(p []byte) (newp []byte, val uint32) {
         .          .    412:	var v, shift uint32
ROUTINE ======================== runtime.stoplockedm in /home/isucon/.local/go/src/runtime/proc.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   1680:		_p_ := releasep()
         .          .   1681:		handoffp(_p_)
         .          .   1682:	}
         .          .   1683:	incidlelocked(1)
         .          .   1684:	// Wait until another thread schedules lockedg again.
         .       10ms   1685:	notesleep(&_g_.m.park)
         .          .   1686:	noteclear(&_g_.m.park)
         .          .   1687:	status := readgstatus(_g_.m.lockedg)
         .          .   1688:	if status&^_Gscan != _Grunnable {
         .          .   1689:		print("runtime:stoplockedm: g is not Grunnable or Gscanrunnable\n")
         .          .   1690:		dumpgstatus(_g_)
ROUTINE ======================== runtime.stopm in /home/isucon/.local/go/src/runtime/proc.go
         0      100ms (flat, cum)  0.18% of Total
         .          .   1533:
         .          .   1534:retry:
         .          .   1535:	lock(&sched.lock)
         .          .   1536:	mput(_g_.m)
         .          .   1537:	unlock(&sched.lock)
         .       70ms   1538:	notesleep(&_g_.m.park)
         .          .   1539:	noteclear(&_g_.m.park)
         .          .   1540:	if _g_.m.helpgc != 0 {
         .       30ms   1541:		gchelper()
         .          .   1542:		_g_.m.helpgc = 0
         .          .   1543:		_g_.m.mcache = nil
         .          .   1544:		_g_.m.p = 0
         .          .   1545:		goto retry
         .          .   1546:	}
ROUTINE ======================== runtime.stringtoslicebyte in /home/isucon/.local/go/src/runtime/string.go
      10ms       30ms (flat, cum) 0.054% of Total
         .          .    139:func stringtoslicebyte(buf *tmpBuf, s string) []byte {
         .          .    140:	var b []byte
         .          .    141:	if buf != nil && len(s) <= len(buf) {
         .          .    142:		b = buf[:len(s):len(s)]
         .          .    143:	} else {
         .       10ms    144:		b = rawbyteslice(len(s))
         .          .    145:	}
      10ms       20ms    146:	copy(b, s)
         .          .    147:	return b
         .          .    148:}
         .          .    149:
         .          .    150:func stringtoslicebytetmp(s string) []byte {
         .          .    151:	// Return a slice referring to the actual string bytes.
ROUTINE ======================== runtime.sweepone in /home/isucon/.local/go/src/runtime/mgcsweep.go
      80ms      3.35s (flat, cum)  6.02% of Total
         .          .     89:	// increment locks to ensure that the goroutine is not preempted
         .          .     90:	// in the middle of sweep thus leaving the span in an inconsistent state for next GC
         .          .     91:	_g_.m.locks++
         .          .     92:	sg := mheap_.sweepgen
         .          .     93:	for {
      20ms       20ms     94:		idx := atomic.Xadd(&sweep.spanidx, 1) - 1
         .          .     95:		if idx >= uint32(len(work.spans)) {
         .          .     96:			mheap_.sweepdone = 1
         .          .     97:			_g_.m.locks--
         .          .     98:			if debug.gcpacertrace > 0 && idx == uint32(len(work.spans)) {
         .          .     99:				print("pacer: sweep done at heap size ", memstats.heap_live>>20, "MB; allocated ", mheap_.spanBytesAlloc>>20, "MB of spans; swept ", mheap_.pagesSwept, " pages\n")
         .          .    100:			}
         .          .    101:			return ^uintptr(0)
         .          .    102:		}
      10ms       10ms    103:		s := work.spans[idx]
      50ms       50ms    104:		if s.state != mSpanInUse {
         .          .    105:			s.sweepgen = sg
         .          .    106:			continue
         .          .    107:		}
         .       10ms    108:		if s.sweepgen != sg-2 || !atomic.Cas(&s.sweepgen, sg-2, sg-1) {
         .          .    109:			continue
         .          .    110:		}
         .          .    111:		npages := s.npages
         .      3.26s    112:		if !s.sweep(false) {
         .          .    113:			npages = 0
         .          .    114:		}
         .          .    115:		_g_.m.locks--
         .          .    116:		return npages
         .          .    117:	}
ROUTINE ======================== runtime.sysmon in /home/isucon/.local/go/src/runtime/proc.go
         0       30ms (flat, cum) 0.054% of Total
         .          .   3463:			delay *= 2
         .          .   3464:		}
         .          .   3465:		if delay > 10*1000 { // up to 10ms
         .          .   3466:			delay = 10 * 1000
         .          .   3467:		}
         .       10ms   3468:		usleep(delay)
         .          .   3469:		if debug.schedtrace <= 0 && (sched.gcwaiting != 0 || atomic.Load(&sched.npidle) == uint32(gomaxprocs)) { // TODO: fast atomic
         .          .   3470:			lock(&sched.lock)
         .          .   3471:			if atomic.Load(&sched.gcwaiting) != 0 || atomic.Load(&sched.npidle) == uint32(gomaxprocs) {
         .          .   3472:				atomic.Store(&sched.sysmonwait, 1)
         .          .   3473:				unlock(&sched.lock)
         .          .   3474:				// Make wake-up period small enough
         .          .   3475:				// for the sampling to be correct.
         .          .   3476:				maxsleep := forcegcperiod / 2
         .          .   3477:				if scavengelimit < forcegcperiod {
         .          .   3478:					maxsleep = scavengelimit / 2
         .          .   3479:				}
         .       10ms   3480:				notetsleep(&sched.sysmonnote, maxsleep)
         .          .   3481:				lock(&sched.lock)
         .          .   3482:				atomic.Store(&sched.sysmonwait, 0)
         .          .   3483:				noteclear(&sched.sysmonnote)
         .          .   3484:				idle = 0
         .          .   3485:				delay = 20
         .          .   3486:			}
         .          .   3487:			unlock(&sched.lock)
         .          .   3488:		}
         .          .   3489:		// poll network if not polled for more than 10ms
         .          .   3490:		lastpoll := int64(atomic.Load64(&sched.lastpoll))
         .          .   3491:		now := nanotime()
         .          .   3492:		unixnow := unixnanotime()
         .          .   3493:		if lastpoll != 0 && lastpoll+10*1000*1000 < now {
         .          .   3494:			atomic.Cas64(&sched.lastpoll, uint64(lastpoll), uint64(now))
         .          .   3495:			gp := netpoll(false) // non-blocking - returns list of goroutines
         .          .   3496:			if gp != nil {
         .          .   3497:				// Need to decrement number of idle locked M's
         .          .   3498:				// (pretending that one more is running) before injectglist.
         .          .   3499:				// Otherwise it can lead to the following situation:
         .          .   3500:				// injectglist grabs all P's but before it starts M's to run the P's,
         .          .   3501:				// another M returns from syscall, finishes running its G,
         .          .   3502:				// observes that there is no work to do and no other running M's
         .          .   3503:				// and reports deadlock.
         .          .   3504:				incidlelocked(-1)
         .       10ms   3505:				injectglist(gp)
         .          .   3506:				incidlelocked(1)
         .          .   3507:			}
         .          .   3508:		}
         .          .   3509:		// retake P's blocked in syscalls
         .          .   3510:		// and preempt long running G's
ROUTINE ======================== runtime.systemstack in /home/isucon/.local/go/src/runtime/asm_amd64.s
     260ms     13.97s (flat, cum) 25.10% of Total
         .          .    244:TEXT runtime·systemstack_switch(SB), NOSPLIT, $0-0
         .          .    245:	RET
         .          .    246:
         .          .    247:// func systemstack(fn func())
         .          .    248:TEXT runtime·systemstack(SB), NOSPLIT, $0-8
      30ms       30ms    249:	MOVQ	fn+0(FP), DI	// DI = fn
         .          .    250:	get_tls(CX)
         .          .    251:	MOVQ	g(CX), AX	// AX = g
      10ms       10ms    252:	MOVQ	g_m(AX), BX	// BX = m
         .          .    253:
      20ms       20ms    254:	MOVQ	m_gsignal(BX), DX	// DX = gsignal
      30ms       30ms    255:	CMPQ	AX, DX
         .          .    256:	JEQ	noswitch
         .          .    257:
      10ms       10ms    258:	MOVQ	m_g0(BX), DX	// DX = g0
         .          .    259:	CMPQ	AX, DX
         .          .    260:	JEQ	noswitch
         .          .    261:
      10ms       10ms    262:	MOVQ	m_curg(BX), R8
         .          .    263:	CMPQ	AX, R8
         .          .    264:	JEQ	switch
         .          .    265:	
         .          .    266:	// Bad: g is not gsignal, not g0, not curg. What is it?
         .          .    267:	MOVQ	$runtime·badsystemstack(SB), AX
         .          .    268:	CALL	AX
         .          .    269:
         .          .    270:switch:
         .          .    271:	// save our state in g->sched.  Pretend to
         .          .    272:	// be systemstack_switch if the G stack is scanned.
         .          .    273:	MOVQ	$runtime·systemstack_switch(SB), SI
         .          .    274:	MOVQ	SI, (g_sched+gobuf_pc)(AX)
         .          .    275:	MOVQ	SP, (g_sched+gobuf_sp)(AX)
         .          .    276:	MOVQ	AX, (g_sched+gobuf_g)(AX)
         .          .    277:	MOVQ	BP, (g_sched+gobuf_bp)(AX)
         .          .    278:
         .          .    279:	// switch to g0
         .          .    280:	MOVQ	DX, g(CX)
         .          .    281:	MOVQ	(g_sched+gobuf_sp)(DX), BX
         .          .    282:	// make it look like mstart called systemstack on g0, to stop traceback
      40ms       40ms    283:	SUBQ	$8, BX
         .          .    284:	MOVQ	$runtime·mstart(SB), DX
      10ms       10ms    285:	MOVQ	DX, 0(BX)
      40ms       40ms    286:	MOVQ	BX, SP
         .          .    287:
         .          .    288:	// call target function
         .          .    289:	MOVQ	DI, DX
         .          .    290:	MOVQ	0(DI), DI
         .     11.64s    291:	CALL	DI
         .          .    292:
         .          .    293:	// switch back to g
         .          .    294:	get_tls(CX)
      10ms       10ms    295:	MOVQ	g(CX), AX
         .          .    296:	MOVQ	g_m(AX), BX
      20ms       20ms    297:	MOVQ	m_curg(BX), AX
         .          .    298:	MOVQ	AX, g(CX)
      10ms       10ms    299:	MOVQ	(g_sched+gobuf_sp)(AX), SP
      20ms       20ms    300:	MOVQ	$0, (g_sched+gobuf_sp)(AX)
         .          .    301:	RET
         .          .    302:
         .          .    303:noswitch:
         .          .    304:	// already on m stack, just call directly
         .          .    305:	MOVQ	DI, DX
         .          .    306:	MOVQ	0(DI), DI
         .      2.07s    307:	CALL	DI
         .          .    308:	RET
         .          .    309:
         .          .    310:/*
         .          .    311: * support for morestack
         .          .    312: */
ROUTINE ======================== runtime.tracebackdefers in /home/isucon/.local/go/src/runtime/traceback.go
      20ms       30ms (flat, cum) 0.054% of Total
         .          .     96:			frame.fn = nil
         .          .     97:			frame.argp = 0
         .          .     98:			frame.arglen = 0
         .          .     99:			frame.argmap = nil
         .          .    100:		} else {
      20ms       20ms    101:			frame.pc = uintptr(fn.fn)
         .          .    102:			f := findfunc(frame.pc)
         .          .    103:			if f == nil {
         .          .    104:				print("runtime: unknown pc in defer ", hex(frame.pc), "\n")
         .          .    105:				throw("unknown pc")
         .          .    106:			}
         .          .    107:			frame.fn = f
         .          .    108:			frame.argp = uintptr(deferArgs(d))
         .          .    109:			frame.arglen, frame.argmap = getArgInfo(&frame, f, true)
         .          .    110:		}
         .          .    111:		frame.continpc = frame.pc
         .       10ms    112:		if !callback((*stkframe)(noescape(unsafe.Pointer(&frame))), v) {
         .          .    113:			return
         .          .    114:		}
         .          .    115:	}
         .          .    116:}
         .          .    117:
ROUTINE ======================== runtime.typeBitsBulkBarrier in /home/isucon/.local/go/src/runtime/mbitmap.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    478:		} else {
         .          .    479:			bits = bits >> 1
         .          .    480:		}
         .          .    481:		if bits&1 != 0 {
         .          .    482:			x := (*uintptr)(unsafe.Pointer(p + i))
         .       10ms    483:			writebarrierptr_nostore(x, *x)
         .          .    484:		}
         .          .    485:	}
         .          .    486:}
         .          .    487:
         .          .    488:// The methods operating on spans all require that h has been returned
ROUTINE ======================== runtime.typedmemmove in /home/isucon/.local/go/src/runtime/mbarrier.go
     740ms      2.71s (flat, cum)  4.87% of Total
         .          .    184:// all the combinations of ptr+scalar up to four words.
         .          .    185:// The implementations are written to wbfat.go.
         .          .    186:
         .          .    187:// typedmemmove copies a value of type t to dst from src.
         .          .    188://go:nosplit
      40ms       40ms    189:func typedmemmove(typ *_type, dst, src unsafe.Pointer) {
     370ms      1.38s    190:	memmove(dst, src, typ.size)
     100ms      100ms    191:	if writeBarrier.cgo {
         .          .    192:		cgoCheckMemmove(typ, dst, src, 0, typ.size)
         .          .    193:	}
      90ms       90ms    194:	if typ.kind&kindNoPointers != 0 {
         .          .    195:		return
         .          .    196:	}
      90ms      1.05s    197:	heapBitsBulkBarrier(uintptr(dst), typ.size)
      50ms       50ms    198:}
         .          .    199:
         .          .    200://go:linkname reflect_typedmemmove reflect.typedmemmove
         .          .    201:func reflect_typedmemmove(typ *_type, dst, src unsafe.Pointer) {
         .          .    202:	typedmemmove(typ, dst, src)
         .          .    203:}
ROUTINE ======================== runtime.typedslicecopy in /home/isucon/.local/go/src/runtime/mbarrier.go
      20ms      1.61s (flat, cum)  2.89% of Total
         .          .    235:	}
         .          .    236:	heapBitsBulkBarrier(uintptr(add(frame, retoffset)), framesize-retoffset)
         .          .    237:}
         .          .    238:
         .          .    239://go:nosplit
      10ms       10ms    240:func typedslicecopy(typ *_type, dst, src slice) int {
         .          .    241:	// TODO(rsc): If typedslicecopy becomes faster than calling
         .          .    242:	// typedmemmove repeatedly, consider using during func growslice.
         .          .    243:	n := dst.len
         .          .    244:	if n > src.len {
         .          .    245:		n = src.len
         .          .    246:	}
         .          .    247:	if n == 0 {
         .          .    248:		return 0
         .          .    249:	}
         .          .    250:	dstp := unsafe.Pointer(dst.array)
         .          .    251:	srcp := unsafe.Pointer(src.array)
         .          .    252:
         .          .    253:	if raceenabled {
         .          .    254:		callerpc := getcallerpc(unsafe.Pointer(&typ))
         .          .    255:		pc := funcPC(slicecopy)
         .          .    256:		racewriterangepc(dstp, uintptr(n)*typ.size, callerpc, pc)
         .          .    257:		racereadrangepc(srcp, uintptr(n)*typ.size, callerpc, pc)
         .          .    258:	}
         .          .    259:	if msanenabled {
         .          .    260:		msanwrite(dstp, uintptr(n)*typ.size)
         .          .    261:		msanread(srcp, uintptr(n)*typ.size)
         .          .    262:	}
         .          .    263:
         .          .    264:	if writeBarrier.cgo {
         .          .    265:		cgoCheckSliceCopy(typ, dst, src, n)
         .          .    266:	}
         .          .    267:
         .          .    268:	// Note: No point in checking typ.kind&kindNoPointers here:
         .          .    269:	// compiler only emits calls to typedslicecopy for types with pointers,
         .          .    270:	// and growslice and reflect_typedslicecopy check for pointers
         .          .    271:	// before calling typedslicecopy.
         .          .    272:	if !writeBarrier.needed {
      10ms      660ms    273:		memmove(dstp, srcp, uintptr(n)*typ.size)
         .          .    274:		return n
         .          .    275:	}
         .          .    276:
         .          .    277:	systemstack(func() {
         .          .    278:		if uintptr(srcp) < uintptr(dstp) && uintptr(srcp)+uintptr(n)*typ.size > uintptr(dstp) {
         .          .    279:			// Overlap with src before dst.
         .          .    280:			// Copy backward, being careful not to move dstp/srcp
         .          .    281:			// out of the array they point into.
         .          .    282:			dstp = add(dstp, uintptr(n-1)*typ.size)
         .          .    283:			srcp = add(srcp, uintptr(n-1)*typ.size)
         .          .    284:			i := 0
         .          .    285:			for {
         .          .    286:				typedmemmove(typ, dstp, srcp)
         .          .    287:				if i++; i >= n {
         .          .    288:					break
         .          .    289:				}
         .          .    290:				dstp = add(dstp, -typ.size)
         .          .    291:				srcp = add(srcp, -typ.size)
         .          .    292:			}
         .          .    293:		} else {
         .          .    294:			// Copy forward, being careful not to move dstp/srcp
         .          .    295:			// out of the array they point into.
         .          .    296:			i := 0
         .          .    297:			for {
         .          .    298:				typedmemmove(typ, dstp, srcp)
         .          .    299:				if i++; i >= n {
         .          .    300:					break
         .          .    301:				}
         .          .    302:				dstp = add(dstp, typ.size)
         .          .    303:				srcp = add(srcp, typ.size)
         .          .    304:			}
         .          .    305:		}
         .      940ms    306:	})
         .          .    307:	return int(n)
         .          .    308:}
         .          .    309:
         .          .    310://go:linkname reflect_typedslicecopy reflect.typedslicecopy
         .          .    311:func reflect_typedslicecopy(elemType *_type, dst, src slice) int {
ROUTINE ======================== runtime.typedslicecopy.func1 in /home/isucon/.local/go/src/runtime/mbarrier.go
      10ms      520ms (flat, cum)  0.93% of Total
         .          .    293:		} else {
         .          .    294:			// Copy forward, being careful not to move dstp/srcp
         .          .    295:			// out of the array they point into.
         .          .    296:			i := 0
         .          .    297:			for {
         .      480ms    298:				typedmemmove(typ, dstp, srcp)
      10ms       10ms    299:				if i++; i >= n {
         .          .    300:					break
         .          .    301:				}
         .       10ms    302:				dstp = add(dstp, typ.size)
         .       20ms    303:				srcp = add(srcp, typ.size)
         .          .    304:			}
         .          .    305:		}
         .          .    306:	})
         .          .    307:	return int(n)
         .          .    308:}
ROUTINE ======================== runtime.unlock in /home/isucon/.local/go/src/runtime/lock_futex.go
      10ms       60ms (flat, cum)  0.11% of Total
         .          .    101:		futexsleep(key32(&l.key), mutex_sleeping, -1)
         .          .    102:	}
         .          .    103:}
         .          .    104:
         .          .    105:func unlock(l *mutex) {
         .       50ms    106:	v := atomic.Xchg(key32(&l.key), mutex_unlocked)
         .          .    107:	if v == mutex_unlocked {
         .          .    108:		throw("unlock of unlocked lock")
         .          .    109:	}
         .          .    110:	if v == mutex_sleeping {
         .          .    111:		futexwakeup(key32(&l.key), 1)
         .          .    112:	}
         .          .    113:
         .          .    114:	gp := getg()
         .          .    115:	gp.m.locks--
         .          .    116:	if gp.m.locks < 0 {
         .          .    117:		throw("runtime·unlock: lock count")
         .          .    118:	}
      10ms       10ms    119:	if gp.m.locks == 0 && gp.preempt { // restore the preemption request in case we've cleared it in newstack
         .          .    120:		gp.stackguard0 = stackPreempt
         .          .    121:	}
         .          .    122:}
         .          .    123:
         .          .    124:// One-time notifications.
ROUTINE ======================== runtime.usleep in /home/isucon/.local/go/src/runtime/sys_linux_amd64.s
      10ms       10ms (flat, cum) 0.018% of Total
         .          .     90:	MOVL	$0, DX
         .          .     91:	MOVL	$0, R10
         .          .     92:	MOVQ	SP, R8
         .          .     93:	MOVL	$23, AX
         .          .     94:	SYSCALL
      10ms       10ms     95:	RET
         .          .     96:
         .          .     97:TEXT runtime·gettid(SB),NOSPLIT,$0-4
         .          .     98:	MOVL	$186, AX	// syscall - gettid
         .          .     99:	SYSCALL
         .          .    100:	MOVL	AX, ret+0(FP)
ROUTINE ======================== runtime.writebarrierptr in /home/isucon/.local/go/src/runtime/mbarrier.go
      10ms      220ms (flat, cum)   0.4% of Total
         .          .    125:
         .          .    126:// NOTE: Really dst *unsafe.Pointer, src unsafe.Pointer,
         .          .    127:// but if we do that, Go inserts a write barrier on *dst = src.
         .          .    128://go:nosplit
         .          .    129:func writebarrierptr(dst *uintptr, src uintptr) {
      10ms       10ms    130:	*dst = src
         .          .    131:	if writeBarrier.cgo {
         .          .    132:		cgoCheckWriteBarrier(dst, src)
         .          .    133:	}
         .          .    134:	if !writeBarrier.needed {
         .          .    135:		return
         .          .    136:	}
         .          .    137:	if src != 0 && (src < sys.PhysPageSize || src == poisonStack) {
         .          .    138:		systemstack(func() {
         .          .    139:			print("runtime: writebarrierptr *", dst, " = ", hex(src), "\n")
         .          .    140:			throw("bad pointer in write barrier")
         .          .    141:		})
         .          .    142:	}
         .      210ms    143:	writebarrierptr_nostore1(dst, src)
         .          .    144:}
         .          .    145:
         .          .    146:// Like writebarrierptr, but the store has already been applied.
         .          .    147:// Do not reapply.
         .          .    148://go:nosplit
ROUTINE ======================== runtime.writebarrierptr_nostore in /home/isucon/.local/go/src/runtime/mbarrier.go
      70ms      260ms (flat, cum)  0.47% of Total
         .          .    145:
         .          .    146:// Like writebarrierptr, but the store has already been applied.
         .          .    147:// Do not reapply.
         .          .    148://go:nosplit
         .          .    149:func writebarrierptr_nostore(dst *uintptr, src uintptr) {
      10ms       10ms    150:	if writeBarrier.cgo {
         .          .    151:		cgoCheckWriteBarrier(dst, src)
         .          .    152:	}
      10ms       10ms    153:	if !writeBarrier.needed {
         .          .    154:		return
         .          .    155:	}
      10ms       10ms    156:	if src != 0 && (src < sys.PhysPageSize || src == poisonStack) {
         .          .    157:		systemstack(func() { throw("bad pointer in write barrier") })
         .          .    158:	}
      40ms      230ms    159:	writebarrierptr_nostore1(dst, src)
         .          .    160:}
         .          .    161:
         .          .    162://go:nosplit
         .          .    163:func writebarrierstring(dst *[2]uintptr, src [2]uintptr) {
         .          .    164:	writebarrierptr(&dst[0], src[0])
ROUTINE ======================== runtime.writebarrierptr_nostore1 in /home/isucon/.local/go/src/runtime/mbarrier.go
     170ms      400ms (flat, cum)  0.72% of Total
         .          .    105:// the p associated with an m. We use the fact that m.p == nil to indicate
         .          .    106:// that we are in one these critical section and throw if the write is of
         .          .    107:// a pointer to a heap object.
         .          .    108://go:nosplit
         .          .    109:func writebarrierptr_nostore1(dst *uintptr, src uintptr) {
      60ms       60ms    110:	mp := acquirem()
      10ms       10ms    111:	if mp.inwb || mp.dying > 0 {
         .          .    112:		releasem(mp)
         .          .    113:		return
         .          .    114:	}
      30ms       30ms    115:	systemstack(func() {
         .          .    116:		if mp.p == 0 && memstats.enablegc && !mp.inwb && inheap(src) {
         .          .    117:			throw("writebarrierptr_nostore1 called with mp.p == nil")
         .          .    118:		}
         .          .    119:		mp.inwb = true
         .          .    120:		gcmarkwb_m(dst, src)
      10ms      240ms    121:	})
         .          .    122:	mp.inwb = false
      50ms       50ms    123:	releasem(mp)
      10ms       10ms    124:}
         .          .    125:
         .          .    126:// NOTE: Really dst *unsafe.Pointer, src unsafe.Pointer,
         .          .    127:// but if we do that, Go inserts a write barrier on *dst = src.
         .          .    128://go:nosplit
         .          .    129:func writebarrierptr(dst *uintptr, src uintptr) {
ROUTINE ======================== runtime.writebarrierptr_nostore1.func1 in /home/isucon/.local/go/src/runtime/mbarrier.go
      70ms      660ms (flat, cum)  1.19% of Total
         .          .    110:	mp := acquirem()
         .          .    111:	if mp.inwb || mp.dying > 0 {
         .          .    112:		releasem(mp)
         .          .    113:		return
         .          .    114:	}
      30ms       30ms    115:	systemstack(func() {
         .          .    116:		if mp.p == 0 && memstats.enablegc && !mp.inwb && inheap(src) {
         .          .    117:			throw("writebarrierptr_nostore1 called with mp.p == nil")
         .          .    118:		}
         .          .    119:		mp.inwb = true
      30ms      620ms    120:		gcmarkwb_m(dst, src)
      10ms       10ms    121:	})
         .          .    122:	mp.inwb = false
         .          .    123:	releasem(mp)
         .          .    124:}
         .          .    125:
         .          .    126:// NOTE: Really dst *unsafe.Pointer, src unsafe.Pointer,
ROUTINE ======================== runtime/internal/atomic.Cas in /home/isucon/.local/go/src/runtime/internal/atomic/asm_amd64.s
      70ms       70ms (flat, cum)  0.13% of Total
         .          .     13://		return 0;
         .          .     14:TEXT runtime∕internal∕atomic·Cas(SB),NOSPLIT,$0-17
         .          .     15:	MOVQ	ptr+0(FP), BX
         .          .     16:	MOVL	old+8(FP), AX
         .          .     17:	MOVL	new+12(FP), CX
      10ms       10ms     18:	LOCK
         .          .     19:	CMPXCHGL	CX, 0(BX)
      60ms       60ms     20:	SETEQ	ret+16(FP)
         .          .     21:	RET
         .          .     22:
         .          .     23:// bool	runtime∕internal∕atomic·Cas64(uint64 *val, uint64 old, uint64 new)
         .          .     24:// Atomically:
         .          .     25://	if(*val == *old){
ROUTINE ======================== runtime/internal/atomic.Casuintptr in /home/isucon/.local/go/src/runtime/internal/atomic/asm_amd64.s
      10ms       10ms (flat, cum) 0.018% of Total
         .          .     36:	CMPXCHGQ	CX, 0(BX)
         .          .     37:	SETEQ	ret+24(FP)
         .          .     38:	RET
         .          .     39:
         .          .     40:TEXT runtime∕internal∕atomic·Casuintptr(SB), NOSPLIT, $0-25
      10ms       10ms     41:	JMP	runtime∕internal∕atomic·Cas64(SB)
         .          .     42:
         .          .     43:TEXT runtime∕internal∕atomic·Loaduintptr(SB), NOSPLIT, $0-16
         .          .     44:	JMP	runtime∕internal∕atomic·Load64(SB)
         .          .     45:
         .          .     46:TEXT runtime∕internal∕atomic·Loaduint(SB), NOSPLIT, $0-16
ROUTINE ======================== runtime/internal/atomic.Load in /home/isucon/.local/go/src/runtime/internal/atomic/atomic_amd64x.go
     120ms      120ms (flat, cum)  0.22% of Total
         .          .      9:import "unsafe"
         .          .     10:
         .          .     11://go:nosplit
         .          .     12://go:noinline
         .          .     13:func Load(ptr *uint32) uint32 {
     120ms      120ms     14:	return *ptr
         .          .     15:}
         .          .     16:
         .          .     17://go:nosplit
         .          .     18://go:noinline
         .          .     19:func Loadp(ptr unsafe.Pointer) unsafe.Pointer {
ROUTINE ======================== runtime/internal/atomic.Load64 in /home/isucon/.local/go/src/runtime/internal/atomic/atomic_amd64x.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .     21:}
         .          .     22:
         .          .     23://go:nosplit
         .          .     24://go:noinline
         .          .     25:func Load64(ptr *uint64) uint64 {
      10ms       10ms     26:	return *ptr
         .          .     27:}
         .          .     28:
         .          .     29://go:noescape
         .          .     30:func Xadd(ptr *uint32, delta int32) uint32
         .          .     31:
ROUTINE ======================== runtime/internal/atomic.Loadp in /home/isucon/.local/go/src/runtime/internal/atomic/atomic_amd64x.go
      60ms       60ms (flat, cum)  0.11% of Total
         .          .     15:}
         .          .     16:
         .          .     17://go:nosplit
         .          .     18://go:noinline
         .          .     19:func Loadp(ptr unsafe.Pointer) unsafe.Pointer {
      60ms       60ms     20:	return *(*unsafe.Pointer)(ptr)
         .          .     21:}
         .          .     22:
         .          .     23://go:nosplit
         .          .     24://go:noinline
         .          .     25:func Load64(ptr *uint64) uint64 {
ROUTINE ======================== runtime/internal/atomic.Or8 in /home/isucon/.local/go/src/runtime/internal/atomic/asm_amd64.s
     330ms      330ms (flat, cum)  0.59% of Total
         .          .    135:
         .          .    136:// void	runtime∕internal∕atomic·Or8(byte volatile*, byte);
         .          .    137:TEXT runtime∕internal∕atomic·Or8(SB), NOSPLIT, $0-9
         .          .    138:	MOVQ	ptr+0(FP), AX
         .          .    139:	MOVB	val+8(FP), BX
      80ms       80ms    140:	LOCK
         .          .    141:	ORB	BX, (AX)
     250ms      250ms    142:	RET
         .          .    143:
         .          .    144:// void	runtime∕internal∕atomic·And8(byte volatile*, byte);
         .          .    145:TEXT runtime∕internal∕atomic·And8(SB), NOSPLIT, $0-9
         .          .    146:	MOVQ	ptr+0(FP), AX
         .          .    147:	MOVB	val+8(FP), BX
ROUTINE ======================== runtime/internal/atomic.Store in /home/isucon/.local/go/src/runtime/internal/atomic/asm_amd64.s
      70ms       70ms (flat, cum)  0.13% of Total
         .          .    120:	MOVQ	val+8(FP), AX
         .          .    121:	XCHGQ	AX, 0(BX)
         .          .    122:	RET
         .          .    123:
         .          .    124:TEXT runtime∕internal∕atomic·Store(SB), NOSPLIT, $0-12
      10ms       10ms    125:	MOVQ	ptr+0(FP), BX
      10ms       10ms    126:	MOVL	val+8(FP), AX
         .          .    127:	XCHGL	AX, 0(BX)
      50ms       50ms    128:	RET
         .          .    129:
         .          .    130:TEXT runtime∕internal∕atomic·Store64(SB), NOSPLIT, $0-16
         .          .    131:	MOVQ	ptr+0(FP), BX
         .          .    132:	MOVQ	val+8(FP), AX
         .          .    133:	XCHGQ	AX, 0(BX)
ROUTINE ======================== runtime/internal/atomic.Storep1 in /home/isucon/.local/go/src/runtime/internal/atomic/asm_amd64.s
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    117:
         .          .    118:TEXT runtime∕internal∕atomic·Storep1(SB), NOSPLIT, $0-16
         .          .    119:	MOVQ	ptr+0(FP), BX
         .          .    120:	MOVQ	val+8(FP), AX
         .          .    121:	XCHGQ	AX, 0(BX)
      10ms       10ms    122:	RET
         .          .    123:
         .          .    124:TEXT runtime∕internal∕atomic·Store(SB), NOSPLIT, $0-12
         .          .    125:	MOVQ	ptr+0(FP), BX
         .          .    126:	MOVL	val+8(FP), AX
         .          .    127:	XCHGL	AX, 0(BX)
ROUTINE ======================== runtime/internal/atomic.Xadd64 in /home/isucon/.local/go/src/runtime/internal/atomic/asm_amd64.s
      70ms       70ms (flat, cum)  0.13% of Total
         .          .     89:	MOVQ	ptr+0(FP), BX
         .          .     90:	MOVQ	delta+8(FP), AX
         .          .     91:	MOVQ	AX, CX
         .          .     92:	LOCK
         .          .     93:	XADDQ	AX, 0(BX)
      70ms       70ms     94:	ADDQ	CX, AX
         .          .     95:	MOVQ	AX, ret+16(FP)
         .          .     96:	RET
         .          .     97:
         .          .     98:TEXT runtime∕internal∕atomic·Xadduintptr(SB), NOSPLIT, $0-24
         .          .     99:	JMP	runtime∕internal∕atomic·Xadd64(SB)
ROUTINE ======================== runtime/internal/atomic.Xchg in /home/isucon/.local/go/src/runtime/internal/atomic/asm_amd64.s
     110ms      110ms (flat, cum)   0.2% of Total
         .          .     98:TEXT runtime∕internal∕atomic·Xadduintptr(SB), NOSPLIT, $0-24
         .          .     99:	JMP	runtime∕internal∕atomic·Xadd64(SB)
         .          .    100:
         .          .    101:TEXT runtime∕internal∕atomic·Xchg(SB), NOSPLIT, $0-20
         .          .    102:	MOVQ	ptr+0(FP), BX
      10ms       10ms    103:	MOVL	new+8(FP), AX
         .          .    104:	XCHGL	AX, 0(BX)
     100ms      100ms    105:	MOVL	AX, ret+16(FP)
         .          .    106:	RET
         .          .    107:
         .          .    108:TEXT runtime∕internal∕atomic·Xchg64(SB), NOSPLIT, $0-24
         .          .    109:	MOVQ	ptr+0(FP), BX
         .          .    110:	MOVQ	new+8(FP), AX
ROUTINE ======================== strconv.FormatInt in /home/isucon/.local/go/src/strconv/itoa.go
         0      110ms (flat, cum)   0.2% of Total
         .          .     14:
         .          .     15:// FormatInt returns the string representation of i in the given base,
         .          .     16:// for 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'
         .          .     17:// for digit values >= 10.
         .          .     18:func FormatInt(i int64, base int) string {
         .      110ms     19:	_, s := formatBits(nil, uint64(i), base, i < 0, false)
         .          .     20:	return s
         .          .     21:}
         .          .     22:
         .          .     23:// Itoa is shorthand for FormatInt(int64(i), 10).
         .          .     24:func Itoa(i int) string {
ROUTINE ======================== strconv.Itoa in /home/isucon/.local/go/src/strconv/itoa.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     20:	return s
         .          .     21:}
         .          .     22:
         .          .     23:// Itoa is shorthand for FormatInt(int64(i), 10).
         .          .     24:func Itoa(i int) string {
         .       10ms     25:	return FormatInt(int64(i), 10)
         .          .     26:}
         .          .     27:
         .          .     28:// AppendInt appends the string form of the integer i,
         .          .     29:// as generated by FormatInt, to dst and returns the extended buffer.
         .          .     30:func AppendInt(dst []byte, i int64, base int) []byte {
ROUTINE ======================== strconv.ParseInt in /home/isucon/.local/go/src/strconv/atoi.go
     230ms      520ms (flat, cum)  0.93% of Total
         .          .    149:// digits, err.Err = ErrSyntax and the returned value is 0;
         .          .    150:// if the value corresponding to s cannot be represented by a
         .          .    151:// signed integer of the given size, err.Err = ErrRange and the
         .          .    152:// returned value is the maximum magnitude integer of the
         .          .    153:// appropriate bitSize and sign.
      50ms       50ms    154:func ParseInt(s string, base int, bitSize int) (i int64, err error) {
         .          .    155:	const fnParseInt = "ParseInt"
         .          .    156:
         .          .    157:	if bitSize == 0 {
         .          .    158:		bitSize = int(IntSize)
         .          .    159:	}
         .          .    160:
         .          .    161:	// Empty string bad.
         .          .    162:	if len(s) == 0 {
         .          .    163:		return 0, syntaxError(fnParseInt, s)
         .          .    164:	}
         .          .    165:
         .          .    166:	// Pick off leading sign.
      10ms       10ms    167:	s0 := s
      20ms       20ms    168:	neg := false
      20ms       20ms    169:	if s[0] == '+' {
         .          .    170:		s = s[1:]
         .          .    171:	} else if s[0] == '-' {
         .          .    172:		neg = true
         .          .    173:		s = s[1:]
         .          .    174:	}
         .          .    175:
         .          .    176:	// Convert unsigned and check range.
         .          .    177:	var un uint64
      60ms      350ms    178:	un, err = ParseUint(s, base, bitSize)
      20ms       20ms    179:	if err != nil && err.(*NumError).Err != ErrRange {
         .          .    180:		err.(*NumError).Func = fnParseInt
         .          .    181:		err.(*NumError).Num = s0
         .          .    182:		return 0, err
         .          .    183:	}
         .          .    184:	cutoff := uint64(1 << uint(bitSize-1))
      10ms       10ms    185:	if !neg && un >= cutoff {
         .          .    186:		return int64(cutoff - 1), rangeError(fnParseInt, s0)
         .          .    187:	}
         .          .    188:	if neg && un > cutoff {
         .          .    189:		return -int64(cutoff), rangeError(fnParseInt, s0)
         .          .    190:	}
      10ms       10ms    191:	n := int64(un)
         .          .    192:	if neg {
         .          .    193:		n = -n
         .          .    194:	}
      30ms       30ms    195:	return n, nil
         .          .    196:}
         .          .    197:
         .          .    198:// Atoi is shorthand for ParseInt(s, 10, 0).
         .          .    199:func Atoi(s string) (i int, err error) {
         .          .    200:	i64, err := ParseInt(s, 10, 0)
ROUTINE ======================== strconv.ParseUint in /home/isucon/.local/go/src/strconv/atoi.go
     290ms      290ms (flat, cum)  0.52% of Total
         .          .     37:const IntSize = intSize
         .          .     38:
         .          .     39:const maxUint64 = (1<<64 - 1)
         .          .     40:
         .          .     41:// ParseUint is like ParseInt but for unsigned numbers.
      30ms       30ms     42:func ParseUint(s string, base int, bitSize int) (n uint64, err error) {
         .          .     43:	var cutoff, maxVal uint64
         .          .     44:
         .          .     45:	if bitSize == 0 {
         .          .     46:		bitSize = int(IntSize)
         .          .     47:	}
         .          .     48:
         .          .     49:	i := 0
         .          .     50:	switch {
         .          .     51:	case len(s) < 1:
         .          .     52:		err = ErrSyntax
         .          .     53:		goto Error
         .          .     54:
      20ms       20ms     55:	case 2 <= base && base <= 36:
         .          .     56:		// valid base; nothing to do
         .          .     57:
         .          .     58:	case base == 0:
         .          .     59:		// Look for octal, hex prefix.
         .          .     60:		switch {
         .          .     61:		case s[0] == '0' && len(s) > 1 && (s[1] == 'x' || s[1] == 'X'):
         .          .     62:			if len(s) < 3 {
         .          .     63:				err = ErrSyntax
         .          .     64:				goto Error
         .          .     65:			}
         .          .     66:			base = 16
         .          .     67:			i = 2
         .          .     68:		case s[0] == '0':
         .          .     69:			base = 8
         .          .     70:			i = 1
         .          .     71:		default:
         .          .     72:			base = 10
         .          .     73:		}
         .          .     74:
         .          .     75:	default:
         .          .     76:		err = errors.New("invalid base " + Itoa(base))
         .          .     77:		goto Error
         .          .     78:	}
         .          .     79:
         .          .     80:	// Cutoff is the smallest number such that cutoff*base > maxUint64.
         .          .     81:	// Use compile-time constants for common cases.
         .          .     82:	switch base {
         .          .     83:	case 10:
      10ms       10ms     84:		cutoff = maxUint64/10 + 1
         .          .     85:	case 16:
         .          .     86:		cutoff = maxUint64/16 + 1
         .          .     87:	default:
         .          .     88:		cutoff = maxUint64/uint64(base) + 1
         .          .     89:	}
         .          .     90:
         .          .     91:	maxVal = 1<<uint(bitSize) - 1
         .          .     92:
      20ms       20ms     93:	for ; i < len(s); i++ {
         .          .     94:		var v byte
      50ms       50ms     95:		d := s[i]
         .          .     96:		switch {
         .          .     97:		case '0' <= d && d <= '9':
      30ms       30ms     98:			v = d - '0'
         .          .     99:		case 'a' <= d && d <= 'z':
         .          .    100:			v = d - 'a' + 10
         .          .    101:		case 'A' <= d && d <= 'Z':
         .          .    102:			v = d - 'A' + 10
         .          .    103:		default:
         .          .    104:			n = 0
         .          .    105:			err = ErrSyntax
         .          .    106:			goto Error
         .          .    107:		}
         .          .    108:		if v >= byte(base) {
         .          .    109:			n = 0
         .          .    110:			err = ErrSyntax
         .          .    111:			goto Error
         .          .    112:		}
         .          .    113:
      30ms       30ms    114:		if n >= cutoff {
         .          .    115:			// n*base overflows
         .          .    116:			n = maxUint64
         .          .    117:			err = ErrRange
         .          .    118:			goto Error
         .          .    119:		}
      20ms       20ms    120:		n *= uint64(base)
         .          .    121:
      10ms       10ms    122:		n1 := n + uint64(v)
      40ms       40ms    123:		if n1 < n || n1 > maxVal {
         .          .    124:			// n+v overflows
         .          .    125:			n = maxUint64
         .          .    126:			err = ErrRange
         .          .    127:			goto Error
         .          .    128:		}
      20ms       20ms    129:		n = n1
         .          .    130:	}
         .          .    131:
      10ms       10ms    132:	return n, nil
         .          .    133:
         .          .    134:Error:
         .          .    135:	return n, &NumError{"ParseUint", s, err}
         .          .    136:}
         .          .    137:
ROUTINE ======================== strconv.Quote in /home/isucon/.local/go/src/strconv/quote.go
      20ms       40ms (flat, cum) 0.072% of Total
         .          .     87:
         .          .     88:// Quote returns a double-quoted Go string literal representing s.  The
         .          .     89:// returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for
         .          .     90:// control characters and non-printable characters as defined by
         .          .     91:// IsPrint.
      10ms       10ms     92:func Quote(s string) string {
      10ms       30ms     93:	return quoteWith(s, '"', false, false)
         .          .     94:}
         .          .     95:
         .          .     96:// AppendQuote appends a double-quoted Go string literal representing s,
         .          .     97:// as generated by Quote, to dst and returns the extended buffer.
         .          .     98:func AppendQuote(dst []byte, s string) []byte {
ROUTINE ======================== strconv.formatBits in /home/isucon/.local/go/src/strconv/itoa.go
      20ms      110ms (flat, cum)   0.2% of Total
         .          .     55:// If neg is set, u is treated as negative int64 value. If append_ is
         .          .     56:// set, the string is appended to dst and the resulting byte slice is
         .          .     57:// returned as the first result value; otherwise the string is returned
         .          .     58:// as the second result value.
         .          .     59://
      10ms       10ms     60:func formatBits(dst []byte, u uint64, base int, neg, append_ bool) (d []byte, s string) {
         .          .     61:	if base < 2 || base > len(digits) {
         .          .     62:		panic("strconv: illegal AppendInt/FormatInt base")
         .          .     63:	}
         .          .     64:	// 2 <= base && base <= len(digits)
         .          .     65:
         .          .     66:	var a [64 + 1]byte // +1 for sign of 64bit value in base 2
         .          .     67:	i := len(a)
         .          .     68:
         .          .     69:	if neg {
         .          .     70:		u = -u
         .          .     71:	}
         .          .     72:
         .          .     73:	// convert bits
         .          .     74:	if base == 10 {
         .          .     75:		// common case: use constants for / because
         .          .     76:		// the compiler can optimize it into a multiply+shift
         .          .     77:
         .          .     78:		if ^uintptr(0)>>32 == 0 {
         .          .     79:			for u > uint64(^uintptr(0)) {
         .          .     80:				q := u / 1e9
         .          .     81:				us := uintptr(u - q*1e9) // us % 1e9 fits into a uintptr
         .          .     82:				for j := 9; j > 0; j-- {
         .          .     83:					i--
         .          .     84:					qs := us / 10
         .          .     85:					a[i] = byte(us - qs*10 + '0')
         .          .     86:					us = qs
         .          .     87:				}
         .          .     88:				u = q
         .          .     89:			}
         .          .     90:		}
         .          .     91:
         .          .     92:		// u guaranteed to fit into a uintptr
         .          .     93:		us := uintptr(u)
         .          .     94:		for us >= 10 {
         .          .     95:			i--
         .          .     96:			q := us / 10
         .          .     97:			a[i] = byte(us - q*10 + '0')
         .          .     98:			us = q
         .          .     99:		}
         .          .    100:		// u < 10
         .          .    101:		i--
         .          .    102:		a[i] = byte(us + '0')
         .          .    103:
         .          .    104:	} else if s := shifts[base]; s > 0 {
         .          .    105:		// base is power of 2: use shifts and masks instead of / and %
         .          .    106:		b := uint64(base)
         .          .    107:		m := uintptr(b) - 1 // == 1<<s - 1
         .          .    108:		for u >= b {
         .          .    109:			i--
         .          .    110:			a[i] = digits[uintptr(u)&m]
         .          .    111:			u >>= s
         .          .    112:		}
         .          .    113:		// u < base
         .          .    114:		i--
         .          .    115:		a[i] = digits[uintptr(u)]
         .          .    116:
         .          .    117:	} else {
         .          .    118:		// general case
         .          .    119:		b := uint64(base)
         .          .    120:		for u >= b {
         .          .    121:			i--
         .          .    122:			q := u / b
         .          .    123:			a[i] = digits[uintptr(u-q*b)]
         .          .    124:			u = q
         .          .    125:		}
         .          .    126:		// u < base
         .          .    127:		i--
         .          .    128:		a[i] = digits[uintptr(u)]
         .          .    129:	}
         .          .    130:
         .          .    131:	// add sign, if any
      10ms       10ms    132:	if neg {
         .          .    133:		i--
         .          .    134:		a[i] = '-'
         .          .    135:	}
         .          .    136:
         .          .    137:	if append_ {
         .          .    138:		d = append(dst, a[i:]...)
         .          .    139:		return
         .          .    140:	}
         .       90ms    141:	s = string(a[i:])
         .          .    142:	return
         .          .    143:}
ROUTINE ======================== strconv.quoteWith in /home/isucon/.local/go/src/strconv/quote.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .     38:				buf = append(buf, byte(r))
         .          .     39:				continue
         .          .     40:			}
         .          .     41:		} else if IsPrint(r) || graphicOnly && isInGraphicList(r) {
         .          .     42:			n := utf8.EncodeRune(runeTmp[:], r)
      10ms       10ms     43:			buf = append(buf, runeTmp[:n]...)
         .          .     44:			continue
         .          .     45:		}
         .          .     46:		switch r {
         .          .     47:		case '\a':
         .          .     48:			buf = append(buf, `\a`...)
         .          .     49:		case '\b':
         .          .     50:			buf = append(buf, `\b`...)
         .          .     51:		case '\f':
         .          .     52:			buf = append(buf, `\f`...)
         .          .     53:		case '\n':
         .          .     54:			buf = append(buf, `\n`...)
         .          .     55:		case '\r':
         .          .     56:			buf = append(buf, `\r`...)
         .          .     57:		case '\t':
         .          .     58:			buf = append(buf, `\t`...)
         .          .     59:		case '\v':
         .          .     60:			buf = append(buf, `\v`...)
         .          .     61:		default:
         .          .     62:			switch {
         .          .     63:			case r < ' ':
         .          .     64:				buf = append(buf, `\x`...)
         .          .     65:				buf = append(buf, lowerhex[s[0]>>4])
         .          .     66:				buf = append(buf, lowerhex[s[0]&0xF])
         .          .     67:			case r > utf8.MaxRune:
         .          .     68:				r = 0xFFFD
         .          .     69:				fallthrough
         .          .     70:			case r < 0x10000:
         .          .     71:				buf = append(buf, `\u`...)
         .          .     72:				for s := 12; s >= 0; s -= 4 {
         .          .     73:					buf = append(buf, lowerhex[r>>uint(s)&0xF])
         .          .     74:				}
         .          .     75:			default:
         .          .     76:				buf = append(buf, `\U`...)
         .          .     77:				for s := 28; s >= 0; s -= 4 {
         .          .     78:					buf = append(buf, lowerhex[r>>uint(s)&0xF])
         .          .     79:				}
         .          .     80:			}
         .          .     81:		}
         .          .     82:	}
         .          .     83:	buf = append(buf, quote)
         .       10ms     84:	return string(buf)
         .          .     85:
         .          .     86:}
         .          .     87:
         .          .     88:// Quote returns a double-quoted Go string literal representing s.  The
         .          .     89:// returned string uses Go escape sequences (\t, \n, \xFF, \u0100) for
ROUTINE ======================== strings.(*Replacer).Replace in /home/isucon/.local/go/src/strings/replace.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     65:	return &Replacer{r: &r}
         .          .     66:}
         .          .     67:
         .          .     68:// Replace returns a copy of s with all replacements performed.
         .          .     69:func (r *Replacer) Replace(s string) string {
         .       10ms     70:	return r.r.Replace(s)
         .          .     71:}
         .          .     72:
         .          .     73:// WriteString writes s to w with all replacements performed.
         .          .     74:func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error) {
         .          .     75:	return r.r.WriteString(w, s)
ROUTINE ======================== strings.(*byteReplacer).Replace in /home/isucon/.local/go/src/strings/replace.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    414:
         .          .    415:func (r *byteReplacer) Replace(s string) string {
         .          .    416:	var buf []byte // lazily allocated
         .          .    417:	for i := 0; i < len(s); i++ {
         .          .    418:		b := s[i]
      10ms       10ms    419:		if r[b] != b {
         .          .    420:			if buf == nil {
         .          .    421:				buf = []byte(s)
         .          .    422:			}
         .          .    423:			buf[i] = r[b]
         .          .    424:		}
ROUTINE ======================== strings.Contains in /home/isucon/.local/go/src/strings/strings.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    128:	return n
         .          .    129:}
         .          .    130:
         .          .    131:// Contains reports whether substr is within s.
         .          .    132:func Contains(s, substr string) bool {
         .       10ms    133:	return Index(s, substr) >= 0
         .          .    134:}
         .          .    135:
         .          .    136:// ContainsAny reports whether any Unicode code points in chars are within s.
         .          .    137:func ContainsAny(s, chars string) bool {
         .          .    138:	return IndexAny(s, chars) >= 0
ROUTINE ======================== strings.Count in /home/isucon/.local/go/src/strings/strings.go
      40ms       40ms (flat, cum) 0.072% of Total
         .          .     88:	case len(sep) == 0:
         .          .     89:		return utf8.RuneCountInString(s) + 1
         .          .     90:	case len(sep) == 1:
         .          .     91:		// special case worth making fast
         .          .     92:		c := sep[0]
      20ms       20ms     93:		for i := 0; i < len(s); i++ {
      10ms       10ms     94:			if s[i] == c {
      10ms       10ms     95:				n++
         .          .     96:			}
         .          .     97:		}
         .          .     98:		return n
         .          .     99:	case len(sep) > len(s):
         .          .    100:		return 0
ROUTINE ======================== strings.Index in /home/isucon/.local/go/src/strings/strings_amd64.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     16:	case n == 0:
         .          .     17:		return 0
         .          .     18:	case n == 1:
         .          .     19:		return IndexByte(s, sep[0])
         .          .     20:	case n <= shortStringLen:
         .       10ms     21:		return indexShortStr(s, sep)
         .          .     22:	case n == len(s):
         .          .     23:		if sep == s {
         .          .     24:			return 0
         .          .     25:		}
         .          .     26:		return -1
ROUTINE ======================== strings.IndexFunc in /home/isucon/.local/go/src/strings/strings.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    536:}
         .          .    537:
         .          .    538:// IndexFunc returns the index into s of the first Unicode
         .          .    539:// code point satisfying f(c), or -1 if none do.
         .          .    540:func IndexFunc(s string, f func(rune) bool) int {
         .       20ms    541:	return indexFunc(s, f, true)
         .          .    542:}
         .          .    543:
         .          .    544:// LastIndexFunc returns the index into s of the last
         .          .    545:// Unicode code point satisfying f(c), or -1 if none do.
         .          .    546:func LastIndexFunc(s string, f func(rune) bool) int {
ROUTINE ======================== strings.IndexRune in /home/isucon/.local/go/src/strings/strings.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    183:// IndexRune returns the index of the first instance of the Unicode code point
         .          .    184:// r, or -1 if rune is not present in s.
         .          .    185:func IndexRune(s string, r rune) int {
         .          .    186:	switch {
         .          .    187:	case r < utf8.RuneSelf:
         .       10ms    188:		return IndexByte(s, byte(r))
         .          .    189:	default:
         .          .    190:		for i, c := range s {
         .          .    191:			if c == r {
         .          .    192:				return i
         .          .    193:			}
ROUTINE ======================== strings.Split in /home/isucon/.local/go/src/strings/strings.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    289:
         .          .    290:// Split slices s into all substrings separated by sep and returns a slice of
         .          .    291:// the substrings between those separators.
         .          .    292:// If sep is empty, Split splits after each UTF-8 sequence.
         .          .    293:// It is equivalent to SplitN with a count of -1.
         .       20ms    294:func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) }
         .          .    295:
         .          .    296:// SplitAfter slices s into all substrings after each instance of sep and
         .          .    297:// returns a slice of those substrings.
         .          .    298:// If sep is empty, SplitAfter splits after each UTF-8 sequence.
         .          .    299:// It is equivalent to SplitAfterN with a count of -1.
ROUTINE ======================== strings.SplitN in /home/isucon/.local/go/src/strings/strings.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    272:// If sep is empty, SplitN splits after each UTF-8 sequence.
         .          .    273:// The count determines the number of substrings to return:
         .          .    274://   n > 0: at most n substrings; the last substring will be the unsplit remainder.
         .          .    275://   n == 0: the result is nil (zero substrings)
         .          .    276://   n < 0: all substrings
         .       10ms    277:func SplitN(s, sep string, n int) []string { return genSplit(s, sep, 0, n) }
         .          .    278:
         .          .    279:// SplitAfterN slices s into substrings after each instance of sep and
         .          .    280:// returns a slice of those substrings.
         .          .    281:// If sep is empty, SplitAfterN splits after each UTF-8 sequence.
         .          .    282:// The count determines the number of substrings to return:
ROUTINE ======================== strings.genSplit in /home/isucon/.local/go/src/strings/strings.go
         0       30ms (flat, cum) 0.054% of Total
         .          .    251:	if n < 0 {
         .          .    252:		n = Count(s, sep) + 1
         .          .    253:	}
         .          .    254:	c := sep[0]
         .          .    255:	start := 0
         .       30ms    256:	a := make([]string, n)
         .          .    257:	na := 0
         .          .    258:	for i := 0; i+len(sep) <= len(s) && na+1 < n; i++ {
         .          .    259:		if s[i] == c && (len(sep) == 1 || s[i:i+len(sep)] == sep) {
         .          .    260:			a[na] = s[start : i+sepSave]
         .          .    261:			na++
ROUTINE ======================== strings.indexFunc in /home/isucon/.local/go/src/strings/strings.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    556:		wid := 1
         .          .    557:		r := rune(s[start])
         .          .    558:		if r >= utf8.RuneSelf {
         .          .    559:			r, wid = utf8.DecodeRuneInString(s[start:])
         .          .    560:		}
         .       20ms    561:		if f(r) == truth {
         .          .    562:			return start
         .          .    563:		}
         .          .    564:		start += wid
         .          .    565:	}
         .          .    566:	return -1
ROUTINE ======================== strings.indexShortStr in /home/isucon/.local/go/src/runtime/asm_amd64.s
      10ms       10ms (flat, cum) 0.018% of Total
         .          .   1672:	JMP fail
         .          .   1673:_3_or_more:
         .          .   1674:	CMPQ BX, $3
         .          .   1675:	JA   _4_or_more
         .          .   1676:	MOVW 1(AX), DX
      10ms       10ms   1677:	MOVW (AX), AX
         .          .   1678:	LEAQ -2(DI)(CX*1), CX
         .          .   1679:loop3:
         .          .   1680:	MOVW (DI), SI
         .          .   1681:	CMPW SI,AX
         .          .   1682:	JZ   partial_success3
ROUTINE ======================== sync.(*Mutex).Lock in /home/isucon/.local/go/src/sync/mutex.go
      20ms       40ms (flat, cum) 0.072% of Total
         .          .     39:// Lock locks m.
         .          .     40:// If the lock is already in use, the calling goroutine
         .          .     41:// blocks until the mutex is available.
         .          .     42:func (m *Mutex) Lock() {
         .          .     43:	// Fast path: grab unlocked mutex.
      20ms       40ms     44:	if atomic.CompareAndSwapInt32(&m.state, 0, mutexLocked) {
         .          .     45:		if race.Enabled {
         .          .     46:			race.Acquire(unsafe.Pointer(m))
         .          .     47:		}
         .          .     48:		return
         .          .     49:	}
ROUTINE ======================== sync.(*Mutex).Unlock in /home/isucon/.local/go/src/sync/mutex.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    102:		_ = m.state
         .          .    103:		race.Release(unsafe.Pointer(m))
         .          .    104:	}
         .          .    105:
         .          .    106:	// Fast path: drop lock bit.
         .       20ms    107:	new := atomic.AddInt32(&m.state, -mutexLocked)
         .          .    108:	if (new+mutexLocked)&mutexLocked == 0 {
         .          .    109:		panic("sync: unlock of unlocked mutex")
         .          .    110:	}
         .          .    111:
         .          .    112:	old := new
ROUTINE ======================== sync.(*Once).Do in /home/isucon/.local/go/src/sync/once.go
      40ms      130ms (flat, cum)  0.23% of Total
         .          .     30:// Do to be called, it will deadlock.
         .          .     31://
         .          .     32:// If f panics, Do considers it to have returned; future calls of Do return
         .          .     33:// without calling f.
         .          .     34://
      20ms       20ms     35:func (o *Once) Do(f func()) {
      20ms       40ms     36:	if atomic.LoadUint32(&o.done) == 1 {
         .       70ms     37:		return
         .          .     38:	}
         .          .     39:	// Slow-path.
         .          .     40:	o.m.Lock()
         .          .     41:	defer o.m.Unlock()
         .          .     42:	if o.done == 0 {
ROUTINE ======================== sync.(*Pool).Get in /home/isucon/.local/go/src/sync/pool.go
      10ms       40ms (flat, cum) 0.072% of Total
         .          .     89:// Callers should not assume any relation between values passed to Put and
         .          .     90:// the values returned by Get.
         .          .     91://
         .          .     92:// If Get would otherwise return nil and p.New is non-nil, Get returns
         .          .     93:// the result of calling p.New.
      10ms       10ms     94:func (p *Pool) Get() interface{} {
         .          .     95:	if race.Enabled {
         .          .     96:		if p.New != nil {
         .          .     97:			return p.New()
         .          .     98:		}
         .          .     99:		return nil
         .          .    100:	}
         .       10ms    101:	l := p.pin()
         .          .    102:	x := l.private
         .          .    103:	l.private = nil
         .          .    104:	runtime_procUnpin()
         .          .    105:	if x != nil {
         .          .    106:		return x
         .          .    107:	}
         .          .    108:	l.Lock()
         .          .    109:	last := len(l.shared) - 1
         .          .    110:	if last >= 0 {
         .          .    111:		x = l.shared[last]
         .          .    112:		l.shared = l.shared[:last]
         .          .    113:	}
         .          .    114:	l.Unlock()
         .          .    115:	if x != nil {
         .          .    116:		return x
         .          .    117:	}
         .       20ms    118:	return p.getSlow()
         .          .    119:}
         .          .    120:
         .          .    121:func (p *Pool) getSlow() (x interface{}) {
         .          .    122:	// See the comment in pin regarding ordering of the loads.
         .          .    123:	size := atomic.LoadUintptr(&p.localSize) // load-acquire
ROUTINE ======================== sync.(*Pool).Put in /home/isucon/.local/go/src/sync/pool.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .     67:		return
         .          .     68:	}
         .          .     69:	if x == nil {
         .          .     70:		return
         .          .     71:	}
      10ms       20ms     72:	l := p.pin()
         .          .     73:	if l.private == nil {
         .          .     74:		l.private = x
         .          .     75:		x = nil
         .          .     76:	}
         .          .     77:	runtime_procUnpin()
ROUTINE ======================== sync.(*Pool).getSlow in /home/isucon/.local/go/src/sync/pool.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    137:		}
         .          .    138:		l.Unlock()
         .          .    139:	}
         .          .    140:
         .          .    141:	if x == nil && p.New != nil {
         .       20ms    142:		x = p.New()
         .          .    143:	}
         .          .    144:	return x
         .          .    145:}
         .          .    146:
         .          .    147:// pin pins the current goroutine to P, disables preemption and returns poolLocal pool for the P.
ROUTINE ======================== sync.(*Pool).pin in /home/isucon/.local/go/src/sync/pool.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    155:	s := atomic.LoadUintptr(&p.localSize) // load-acquire
         .          .    156:	l := p.local                          // load-consume
         .          .    157:	if uintptr(pid) < s {
         .          .    158:		return indexLocal(l, pid)
         .          .    159:	}
         .       20ms    160:	return p.pinSlow()
         .          .    161:}
         .          .    162:
         .          .    163:func (p *Pool) pinSlow() *poolLocal {
         .          .    164:	// Retry under the mutex.
         .          .    165:	// Can not lock the mutex while pinned.
ROUTINE ======================== sync.(*Pool).pinSlow in /home/isucon/.local/go/src/sync/pool.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    176:	if p.local == nil {
         .          .    177:		allPools = append(allPools, p)
         .          .    178:	}
         .          .    179:	// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.
         .          .    180:	size := runtime.GOMAXPROCS(0)
         .       20ms    181:	local := make([]poolLocal, size)
         .          .    182:	atomic.StorePointer((*unsafe.Pointer)(&p.local), unsafe.Pointer(&local[0])) // store-release
         .          .    183:	atomic.StoreUintptr(&p.localSize, uintptr(size))                            // store-release
         .          .    184:	return &local[pid]
         .          .    185:}
         .          .    186:
ROUTINE ======================== sync.(*RWMutex).RLock in /home/isucon/.local/go/src/sync/rwmutex.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     30:func (rw *RWMutex) RLock() {
         .          .     31:	if race.Enabled {
         .          .     32:		_ = rw.w.state
         .          .     33:		race.Disable()
         .          .     34:	}
         .       20ms     35:	if atomic.AddInt32(&rw.readerCount, 1) < 0 {
         .          .     36:		// A writer is pending, wait for it.
         .          .     37:		runtime_Semacquire(&rw.readerSem)
         .          .     38:	}
         .          .     39:	if race.Enabled {
         .          .     40:		race.Enable()
ROUTINE ======================== sync.(*WaitGroup).Add in /home/isucon/.local/go/src/sync/waitgroup.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     72:	}
         .          .     73:	if w != 0 && delta > 0 && v == int32(delta) {
         .          .     74:		panic("sync: WaitGroup misuse: Add called concurrently with Wait")
         .          .     75:	}
         .          .     76:	if v > 0 || w == 0 {
         .       10ms     77:		return
         .          .     78:	}
         .          .     79:	// This goroutine has set counter to 0 when waiters > 0.
         .          .     80:	// Now there can't be concurrent mutations of state:
         .          .     81:	// - Adds must not happen concurrently with Wait,
         .          .     82:	// - Wait does not increment waiters if it sees counter == 0.
ROUTINE ======================== sync.(*WaitGroup).Done in /home/isucon/.local/go/src/sync/waitgroup.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     91:	}
         .          .     92:}
         .          .     93:
         .          .     94:// Done decrements the WaitGroup counter.
         .          .     95:func (wg *WaitGroup) Done() {
         .       10ms     96:	wg.Add(-1)
         .          .     97:}
         .          .     98:
         .          .     99:// Wait blocks until the WaitGroup counter is zero.
         .          .    100:func (wg *WaitGroup) Wait() {
         .          .    101:	statep := wg.state()
ROUTINE ======================== sync/atomic.AddUint32 in /home/isucon/.local/go/src/sync/atomic/asm_amd64.s
      40ms       40ms (flat, cum) 0.072% of Total
         .          .     63:	MOVQ	addr+0(FP), BP
         .          .     64:	MOVL	delta+8(FP), AX
         .          .     65:	MOVL	AX, CX
         .          .     66:	LOCK
         .          .     67:	XADDL	AX, 0(BP)
      40ms       40ms     68:	ADDL	AX, CX
         .          .     69:	MOVL	CX, new+16(FP)
         .          .     70:	RET
         .          .     71:
         .          .     72:TEXT ·AddUintptr(SB),NOSPLIT,$0-24
         .          .     73:	JMP	·AddUint64(SB)
ROUTINE ======================== sync/atomic.CompareAndSwapUint32 in /home/isucon/.local/go/src/sync/atomic/asm_amd64.s
      20ms       20ms (flat, cum) 0.036% of Total
         .          .     36:	MOVQ	addr+0(FP), BP
         .          .     37:	MOVL	old+8(FP), AX
         .          .     38:	MOVL	new+12(FP), CX
         .          .     39:	LOCK
         .          .     40:	CMPXCHGL	CX, 0(BP)
      20ms       20ms     41:	SETEQ	swapped+16(FP)
         .          .     42:	RET
         .          .     43:
         .          .     44:TEXT ·CompareAndSwapUintptr(SB),NOSPLIT,$0-25
         .          .     45:	JMP	·CompareAndSwapUint64(SB)
         .          .     46:
ROUTINE ======================== sync/atomic.CompareAndSwapUint64 in /home/isucon/.local/go/src/sync/atomic/asm_amd64.s
      10ms       10ms (flat, cum) 0.018% of Total
         .          .     51:	MOVQ	addr+0(FP), BP
         .          .     52:	MOVQ	old+8(FP), AX
         .          .     53:	MOVQ	new+16(FP), CX
         .          .     54:	LOCK
         .          .     55:	CMPXCHGQ	CX, 0(BP)
      10ms       10ms     56:	SETEQ	swapped+24(FP)
         .          .     57:	RET
         .          .     58:
         .          .     59:TEXT ·AddInt32(SB),NOSPLIT,$0-20
         .          .     60:	JMP	·AddUint32(SB)
         .          .     61:
ROUTINE ======================== sync/atomic.LoadUint32 in /home/isucon/.local/go/src/sync/atomic/asm_amd64.s
      20ms       20ms (flat, cum) 0.036% of Total
         .          .     88:TEXT ·LoadInt32(SB),NOSPLIT,$0-12
         .          .     89:	JMP	·LoadUint32(SB)
         .          .     90:
         .          .     91:TEXT ·LoadUint32(SB),NOSPLIT,$0-12
         .          .     92:	MOVQ	addr+0(FP), AX
      10ms       10ms     93:	MOVL	0(AX), AX
      10ms       10ms     94:	MOVL	AX, val+8(FP)
         .          .     95:	RET
         .          .     96:
         .          .     97:TEXT ·LoadInt64(SB),NOSPLIT,$0-16
         .          .     98:	JMP	·LoadUint64(SB)
         .          .     99:
ROUTINE ======================== sync/atomic.LoadUint64 in /home/isucon/.local/go/src/sync/atomic/asm_amd64.s
      50ms       50ms (flat, cum)  0.09% of Total
         .          .     96:
         .          .     97:TEXT ·LoadInt64(SB),NOSPLIT,$0-16
         .          .     98:	JMP	·LoadUint64(SB)
         .          .     99:
         .          .    100:TEXT ·LoadUint64(SB),NOSPLIT,$0-16
      30ms       30ms    101:	MOVQ	addr+0(FP), AX
         .          .    102:	MOVQ	0(AX), AX
      20ms       20ms    103:	MOVQ	AX, val+8(FP)
         .          .    104:	RET
         .          .    105:
         .          .    106:TEXT ·LoadUintptr(SB),NOSPLIT,$0-16
         .          .    107:	JMP	·LoadPointer(SB)
         .          .    108:
ROUTINE ======================== syscall.Accept4 in /home/isucon/.local/go/src/syscall/syscall_linux.go
         0      190ms (flat, cum)  0.34% of Total
         .          .    448:}
         .          .    449:
         .          .    450:func Accept4(fd int, flags int) (nfd int, sa Sockaddr, err error) {
         .          .    451:	var rsa RawSockaddrAny
         .          .    452:	var len _Socklen = SizeofSockaddrAny
         .       50ms    453:	nfd, err = accept4(fd, &rsa, &len, flags)
         .          .    454:	if err != nil {
         .          .    455:		return
         .          .    456:	}
         .          .    457:	if len > SizeofSockaddrAny {
         .          .    458:		panic("RawSockaddrAny too small")
         .          .    459:	}
         .      140ms    460:	sa, err = anyToSockaddr(&rsa)
         .          .    461:	if err != nil {
         .          .    462:		Close(nfd)
         .          .    463:		nfd = 0
         .          .    464:	}
         .          .    465:	return
ROUTINE ======================== syscall.Close in /home/isucon/.local/go/src/syscall/zsyscall_linux_amd64.go
         0      120ms (flat, cum)  0.22% of Total
         .          .    291:}
         .          .    292:
         .          .    293:// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
         .          .    294:
         .          .    295:func Close(fd int) (err error) {
         .      120ms    296:	_, _, e1 := Syscall(SYS_CLOSE, uintptr(fd), 0, 0)
         .          .    297:	if e1 != 0 {
         .          .    298:		err = errnoErr(e1)
         .          .    299:	}
         .          .    300:	return
         .          .    301:}
ROUTINE ======================== syscall.Connect in /home/isucon/.local/go/src/syscall/syscall_unix.go
         0      170ms (flat, cum)  0.31% of Total
         .          .    224:func Connect(fd int, sa Sockaddr) (err error) {
         .          .    225:	ptr, n, err := sa.sockaddr()
         .          .    226:	if err != nil {
         .          .    227:		return err
         .          .    228:	}
         .      170ms    229:	return connect(fd, ptr, n)
         .          .    230:}
         .          .    231:
         .          .    232:func Getpeername(fd int) (sa Sockaddr, err error) {
         .          .    233:	var rsa RawSockaddrAny
         .          .    234:	var len _Socklen = SizeofSockaddrAny
ROUTINE ======================== syscall.Getpeername in /home/isucon/.local/go/src/syscall/syscall_unix.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    230:}
         .          .    231:
         .          .    232:func Getpeername(fd int) (sa Sockaddr, err error) {
         .          .    233:	var rsa RawSockaddrAny
         .          .    234:	var len _Socklen = SizeofSockaddrAny
         .       10ms    235:	if err = getpeername(fd, &rsa, &len); err != nil {
         .          .    236:		return
         .          .    237:	}
         .       10ms    238:	return anyToSockaddr(&rsa)
         .          .    239:}
         .          .    240:
         .          .    241:func GetsockoptInt(fd, level, opt int) (value int, err error) {
         .          .    242:	var n int32
         .          .    243:	vallen := _Socklen(4)
ROUTINE ======================== syscall.Getsockname in /home/isucon/.local/go/src/syscall/syscall_linux.go
         0       60ms (flat, cum)  0.11% of Total
         .          .    469:	var rsa RawSockaddrAny
         .          .    470:	var len _Socklen = SizeofSockaddrAny
         .          .    471:	if err = getsockname(fd, &rsa, &len); err != nil {
         .          .    472:		return
         .          .    473:	}
         .       60ms    474:	return anyToSockaddr(&rsa)
         .          .    475:}
         .          .    476:
         .          .    477:func GetsockoptInet4Addr(fd, level, opt int) (value [4]byte, err error) {
         .          .    478:	vallen := _Socklen(4)
         .          .    479:	err = getsockopt(fd, level, opt, unsafe.Pointer(&value[0]), &vallen)
ROUTINE ======================== syscall.GetsockoptInt in /home/isucon/.local/go/src/syscall/syscall_unix.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    239:}
         .          .    240:
         .          .    241:func GetsockoptInt(fd, level, opt int) (value int, err error) {
         .          .    242:	var n int32
         .          .    243:	vallen := _Socklen(4)
         .       10ms    244:	err = getsockopt(fd, level, opt, unsafe.Pointer(&n), &vallen)
         .          .    245:	return int(n), err
         .          .    246:}
         .          .    247:
         .          .    248:func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, err error) {
         .          .    249:	var rsa RawSockaddrAny
ROUTINE ======================== syscall.RawSyscall in /home/isucon/.local/go/src/syscall/asm_linux_amd64.s
      60ms       60ms (flat, cum)  0.11% of Total
         .          .     73:	MOVQ	$0, R10
         .          .     74:	MOVQ	$0, R8
         .          .     75:	MOVQ	$0, R9
         .          .     76:	MOVQ	trap+0(FP), AX	// syscall entry
         .          .     77:	SYSCALL
      60ms       60ms     78:	CMPQ	AX, $0xfffffffffffff001
         .          .     79:	JLS	ok1
         .          .     80:	MOVQ	$-1, r1+32(FP)
         .          .     81:	MOVQ	$0, r2+40(FP)
         .          .     82:	NEGQ	AX
         .          .     83:	MOVQ	AX, err+48(FP)
ROUTINE ======================== syscall.RawSyscall6 in /home/isucon/.local/go/src/syscall/asm_linux_amd64.s
      20ms       20ms (flat, cum) 0.036% of Total
         .          .     95:	MOVQ	a3+24(FP), DX
         .          .     96:	MOVQ	a4+32(FP), R10
         .          .     97:	MOVQ	a5+40(FP), R8
         .          .     98:	MOVQ	a6+48(FP), R9
         .          .     99:	MOVQ	trap+0(FP), AX	// syscall entry
      20ms       20ms    100:	SYSCALL
         .          .    101:	CMPQ	AX, $0xfffffffffffff001
         .          .    102:	JLS	ok2
         .          .    103:	MOVQ	$-1, r1+56(FP)
         .          .    104:	MOVQ	$0, r2+64(FP)
         .          .    105:	NEGQ	AX
ROUTINE ======================== syscall.Read in /home/isucon/.local/go/src/syscall/syscall_unix.go
      10ms      850ms (flat, cum)  1.53% of Total
         .          .    156:	}
         .          .    157:	return "signal " + itoa(int(s))
         .          .    158:}
         .          .    159:
         .          .    160:func Read(fd int, p []byte) (n int, err error) {
      10ms      850ms    161:	n, err = read(fd, p)
         .          .    162:	if race.Enabled {
         .          .    163:		if n > 0 {
         .          .    164:			race.WriteRange(unsafe.Pointer(&p[0]), n)
         .          .    165:		}
         .          .    166:		if err == nil {
ROUTINE ======================== syscall.Sendfile in /home/isucon/.local/go/src/syscall/syscall_unix.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    322:
         .          .    323:func Sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
         .          .    324:	if race.Enabled {
         .          .    325:		race.ReleaseMerge(unsafe.Pointer(&ioSync))
         .          .    326:	}
         .       20ms    327:	return sendfile(outfd, infd, offset, count)
         .          .    328:}
         .          .    329:
         .          .    330:var ioSync int64
ROUTINE ======================== syscall.SetsockoptInt in /home/isucon/.local/go/src/syscall/syscall_unix.go
         0       50ms (flat, cum)  0.09% of Total
         .          .    269:	return setsockopt(fd, level, opt, unsafe.Pointer(&value), 1)
         .          .    270:}
         .          .    271:
         .          .    272:func SetsockoptInt(fd, level, opt int, value int) (err error) {
         .          .    273:	var n = int32(value)
         .       50ms    274:	return setsockopt(fd, level, opt, unsafe.Pointer(&n), 4)
         .          .    275:}
         .          .    276:
         .          .    277:func SetsockoptInet4Addr(fd, level, opt int, value [4]byte) (err error) {
         .          .    278:	return setsockopt(fd, level, opt, unsafe.Pointer(&value[0]), 4)
         .          .    279:}
ROUTINE ======================== syscall.Socket in /home/isucon/.local/go/src/syscall/syscall_unix.go
         0       60ms (flat, cum)  0.11% of Total
         .          .    304:
         .          .    305:func Socket(domain, typ, proto int) (fd int, err error) {
         .          .    306:	if domain == AF_INET6 && SocketDisableIPv6 {
         .          .    307:		return -1, EAFNOSUPPORT
         .          .    308:	}
         .       60ms    309:	fd, err = socket(domain, typ, proto)
         .          .    310:	return
         .          .    311:}
         .          .    312:
         .          .    313:func Socketpair(domain, typ, proto int) (fd [2]int, err error) {
         .          .    314:	var fdx [2]int32
ROUTINE ======================== syscall.StartProcess in /home/isucon/.local/go/src/syscall/exec_unix.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    235:	return forkExec(argv0, argv, attr)
         .          .    236:}
         .          .    237:
         .          .    238:// StartProcess wraps ForkExec for package os.
         .          .    239:func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid int, handle uintptr, err error) {
         .       20ms    240:	pid, err = forkExec(argv0, argv, attr)
         .          .    241:	return pid, 0, err
         .          .    242:}
         .          .    243:
         .          .    244:// Ordinary exec.
         .          .    245:func Exec(argv0 string, argv []string, envv []string) (err error) {
ROUTINE ======================== syscall.Syscall in /home/isucon/.local/go/src/syscall/asm_linux_amd64.s
     3.40s      3.59s (flat, cum)  6.45% of Total
         .          .     13:// Trap # in AX, args in DI SI DX R10 R8 R9, return in AX DX
         .          .     14:// Note that this differs from "standard" ABI convention, which
         .          .     15:// would pass 4th arg in CX, not R10.
         .          .     16:
         .          .     17:TEXT	·Syscall(SB),NOSPLIT,$0-56
      20ms      130ms     18:	CALL	runtime·entersyscall(SB)
         .          .     19:	MOVQ	a1+8(FP), DI
         .          .     20:	MOVQ	a2+16(FP), SI
         .          .     21:	MOVQ	a3+24(FP), DX
         .          .     22:	MOVQ	$0, R10
         .          .     23:	MOVQ	$0, R8
         .          .     24:	MOVQ	$0, R9
         .          .     25:	MOVQ	trap+0(FP), AX	// syscall entry
      10ms       10ms     26:	SYSCALL
     3.33s      3.33s     27:	CMPQ	AX, $0xfffffffffffff001
      10ms       10ms     28:	JLS	ok
         .          .     29:	MOVQ	$-1, r1+32(FP)
         .          .     30:	MOVQ	$0, r2+40(FP)
         .          .     31:	NEGQ	AX
         .          .     32:	MOVQ	AX, err+48(FP)
         .       10ms     33:	CALL	runtime·exitsyscall(SB)
         .          .     34:	RET
         .          .     35:ok:
      10ms       10ms     36:	MOVQ	AX, r1+32(FP)
      20ms       20ms     37:	MOVQ	DX, r2+40(FP)
         .          .     38:	MOVQ	$0, err+48(FP)
         .       70ms     39:	CALL	runtime·exitsyscall(SB)
         .          .     40:	RET
         .          .     41:
         .          .     42:// func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)
         .          .     43:TEXT ·Syscall6(SB),NOSPLIT,$0-80
         .          .     44:	CALL	runtime·entersyscall(SB)
ROUTINE ======================== syscall.Syscall6 in /home/isucon/.local/go/src/syscall/asm_linux_amd64.s
     230ms      250ms (flat, cum)  0.45% of Total
         .          .     39:	CALL	runtime·exitsyscall(SB)
         .          .     40:	RET
         .          .     41:
         .          .     42:// func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)
         .          .     43:TEXT ·Syscall6(SB),NOSPLIT,$0-80
         .       10ms     44:	CALL	runtime·entersyscall(SB)
         .          .     45:	MOVQ	a1+8(FP), DI
         .          .     46:	MOVQ	a2+16(FP), SI
         .          .     47:	MOVQ	a3+24(FP), DX
         .          .     48:	MOVQ	a4+32(FP), R10
         .          .     49:	MOVQ	a5+40(FP), R8
         .          .     50:	MOVQ	a6+48(FP), R9
         .          .     51:	MOVQ	trap+0(FP), AX	// syscall entry
         .          .     52:	SYSCALL
     230ms      230ms     53:	CMPQ	AX, $0xfffffffffffff001
         .          .     54:	JLS	ok6
         .          .     55:	MOVQ	$-1, r1+56(FP)
         .          .     56:	MOVQ	$0, r2+64(FP)
         .          .     57:	NEGQ	AX
         .          .     58:	MOVQ	AX, err+72(FP)
         .          .     59:	CALL	runtime·exitsyscall(SB)
         .          .     60:	RET
         .          .     61:ok6:
         .          .     62:	MOVQ	AX, r1+56(FP)
         .          .     63:	MOVQ	DX, r2+64(FP)
         .          .     64:	MOVQ	$0, err+72(FP)
         .       10ms     65:	CALL	runtime·exitsyscall(SB)
         .          .     66:	RET
         .          .     67:
         .          .     68:// func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr)
         .          .     69:TEXT ·RawSyscall(SB),NOSPLIT,$0-56
         .          .     70:	MOVQ	a1+8(FP), DI
ROUTINE ======================== syscall.Wait4 in /home/isucon/.local/go/src/syscall/syscall_linux.go
         0      120ms (flat, cum)  0.22% of Total
         .          .    251:
         .          .    252://sys	wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error)
         .          .    253:
         .          .    254:func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error) {
         .          .    255:	var status _C_int
         .      120ms    256:	wpid, err = wait4(pid, &status, options, rusage)
         .          .    257:	if wstatus != nil {
         .          .    258:		*wstatus = WaitStatus(status)
         .          .    259:	}
         .          .    260:	return
         .          .    261:}
ROUTINE ======================== syscall.Write in /home/isucon/.local/go/src/syscall/syscall_unix.go
         0      2.49s (flat, cum)  4.47% of Total
         .          .    175:
         .          .    176:func Write(fd int, p []byte) (n int, err error) {
         .          .    177:	if race.Enabled {
         .          .    178:		race.ReleaseMerge(unsafe.Pointer(&ioSync))
         .          .    179:	}
         .      2.49s    180:	n, err = write(fd, p)
         .          .    181:	if race.Enabled && n > 0 {
         .          .    182:		race.ReadRange(unsafe.Pointer(&p[0]), n)
         .          .    183:	}
         .          .    184:	if msanenabled && n > 0 {
         .          .    185:		msanRead(unsafe.Pointer(&p[0]), n)
ROUTINE ======================== syscall.accept4 in /home/isucon/.local/go/src/syscall/zsyscall_linux_amd64.go
         0       50ms (flat, cum)  0.09% of Total
         .          .   1588:}
         .          .   1589:
         .          .   1590:// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
         .          .   1591:
         .          .   1592:func accept4(s int, rsa *RawSockaddrAny, addrlen *_Socklen, flags int) (fd int, err error) {
         .       50ms   1593:	r0, _, e1 := Syscall6(SYS_ACCEPT4, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)), uintptr(flags), 0, 0)
         .          .   1594:	fd = int(r0)
         .          .   1595:	if e1 != 0 {
         .          .   1596:		err = errnoErr(e1)
         .          .   1597:	}
         .          .   1598:	return
ROUTINE ======================== syscall.anyToSockaddr in /home/isucon/.local/go/src/syscall/syscall_linux.go
      10ms      210ms (flat, cum)  0.38% of Total
         .          .    408:		sa.Name = string(bytes)
         .          .    409:		return sa, nil
         .          .    410:
         .          .    411:	case AF_INET:
         .          .    412:		pp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))
         .      200ms    413:		sa := new(SockaddrInet4)
         .          .    414:		p := (*[2]byte)(unsafe.Pointer(&pp.Port))
         .          .    415:		sa.Port = int(p[0])<<8 + int(p[1])
         .          .    416:		for i := 0; i < len(sa.Addr); i++ {
      10ms       10ms    417:			sa.Addr[i] = pp.Addr[i]
         .          .    418:		}
         .          .    419:		return sa, nil
         .          .    420:
         .          .    421:	case AF_INET6:
         .          .    422:		pp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))
ROUTINE ======================== syscall.connect in /home/isucon/.local/go/src/syscall/zsyscall_linux_amd64.go
         0      170ms (flat, cum)  0.31% of Total
         .          .   1609:}
         .          .   1610:
         .          .   1611:// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
         .          .   1612:
         .          .   1613:func connect(s int, addr unsafe.Pointer, addrlen _Socklen) (err error) {
         .      160ms   1614:	_, _, e1 := Syscall(SYS_CONNECT, uintptr(s), uintptr(addr), uintptr(addrlen))
         .          .   1615:	if e1 != 0 {
         .       10ms   1616:		err = errnoErr(e1)
         .          .   1617:	}
         .          .   1618:	return
         .          .   1619:}
         .          .   1620:
         .          .   1621:// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
ROUTINE ======================== syscall.errnoErr in /home/isucon/.local/go/src/syscall/syscall_unix.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    136:	case EINVAL:
         .          .    137:		return errEINVAL
         .          .    138:	case ENOENT:
         .          .    139:		return errENOENT
         .          .    140:	}
         .       10ms    141:	return e
         .          .    142:}
         .          .    143:
         .          .    144:// A Signal is a number describing a process signal.
         .          .    145:// It implements the os.Signal interface.
         .          .    146:type Signal int
ROUTINE ======================== syscall.forkAndExecInChild in /home/isucon/.local/go/src/syscall/exec_linux.go
         0       20ms (flat, cum) 0.036% of Total
         .          .     91:	}
         .          .     92:
         .          .     93:	// About to call fork.
         .          .     94:	// No more allocation or calls of non-assembly functions.
         .          .     95:	runtime_BeforeFork()
         .       20ms     96:	r1, _, err1 = RawSyscall6(SYS_CLONE, uintptr(SIGCHLD)|sys.Cloneflags, 0, 0, 0, 0, 0)
         .          .     97:	if err1 != 0 {
         .          .     98:		runtime_AfterFork()
         .          .     99:		return 0, err1
         .          .    100:	}
         .          .    101:
ROUTINE ======================== syscall.forkExec in /home/isucon/.local/go/src/syscall/exec_unix.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    188:	if err = forkExecPipe(p[:]); err != nil {
         .          .    189:		goto error
         .          .    190:	}
         .          .    191:
         .          .    192:	// Kick off child.
         .       20ms    193:	pid, err1 = forkAndExecInChild(argv0p, argvp, envvp, chroot, dir, attr, sys, p[1])
         .          .    194:	if err1 != 0 {
         .          .    195:		err = Errno(err1)
         .          .    196:		goto error
         .          .    197:	}
         .          .    198:	ForkLock.Unlock()
ROUTINE ======================== syscall.getpeername in /home/isucon/.local/go/src/syscall/zsyscall_linux_amd64.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   1681:}
         .          .   1682:
         .          .   1683:// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
         .          .   1684:
         .          .   1685:func getpeername(fd int, rsa *RawSockaddrAny, addrlen *_Socklen) (err error) {
         .       10ms   1686:	_, _, e1 := RawSyscall(SYS_GETPEERNAME, uintptr(fd), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
         .          .   1687:	if e1 != 0 {
         .          .   1688:		err = errnoErr(e1)
         .          .   1689:	}
         .          .   1690:	return
         .          .   1691:}
ROUTINE ======================== syscall.getsockopt in /home/isucon/.local/go/src/syscall/zsyscall_linux_amd64.go
         0       10ms (flat, cum) 0.018% of Total
         .          .   1640:}
         .          .   1641:
         .          .   1642:// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
         .          .   1643:
         .          .   1644:func getsockopt(s int, level int, name int, val unsafe.Pointer, vallen *_Socklen) (err error) {
         .       10ms   1645:	_, _, e1 := Syscall6(SYS_GETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(unsafe.Pointer(vallen)), 0)
         .          .   1646:	if e1 != 0 {
         .          .   1647:		err = errnoErr(e1)
         .          .   1648:	}
         .          .   1649:	return
         .          .   1650:}
ROUTINE ======================== syscall.read in /home/isucon/.local/go/src/syscall/zsyscall_linux_amd64.go
         0      840ms (flat, cum)  1.51% of Total
         .          .    778:	if len(p) > 0 {
         .          .    779:		_p0 = unsafe.Pointer(&p[0])
         .          .    780:	} else {
         .          .    781:		_p0 = unsafe.Pointer(&_zero)
         .          .    782:	}
         .      840ms    783:	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(_p0), uintptr(len(p)))
         .          .    784:	n = int(r0)
         .          .    785:	if e1 != 0 {
         .          .    786:		err = errnoErr(e1)
         .          .    787:	}
         .          .    788:	return
ROUTINE ======================== syscall.sendfile in /home/isucon/.local/go/src/syscall/zsyscall_linux_amd64.go
         0       20ms (flat, cum) 0.036% of Total
         .          .   1417:}
         .          .   1418:
         .          .   1419:// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
         .          .   1420:
         .          .   1421:func sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {
         .       20ms   1422:	r0, _, e1 := Syscall6(SYS_SENDFILE, uintptr(outfd), uintptr(infd), uintptr(unsafe.Pointer(offset)), uintptr(count), 0, 0)
         .          .   1423:	written = int(r0)
         .          .   1424:	if e1 != 0 {
         .          .   1425:		err = errnoErr(e1)
         .          .   1426:	}
         .          .   1427:	return
ROUTINE ======================== syscall.setsockopt in /home/isucon/.local/go/src/syscall/zsyscall_linux_amd64.go
         0       50ms (flat, cum)  0.09% of Total
         .          .   1650:}
         .          .   1651:
         .          .   1652:// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
         .          .   1653:
         .          .   1654:func setsockopt(s int, level int, name int, val unsafe.Pointer, vallen uintptr) (err error) {
         .       50ms   1655:	_, _, e1 := Syscall6(SYS_SETSOCKOPT, uintptr(s), uintptr(level), uintptr(name), uintptr(val), uintptr(vallen), 0)
         .          .   1656:	if e1 != 0 {
         .          .   1657:		err = errnoErr(e1)
         .          .   1658:	}
         .          .   1659:	return
         .          .   1660:}
ROUTINE ======================== syscall.socket in /home/isucon/.local/go/src/syscall/zsyscall_linux_amd64.go
      10ms       60ms (flat, cum)  0.11% of Total
         .          .   1659:	return
         .          .   1660:}
         .          .   1661:
         .          .   1662:// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
         .          .   1663:
      10ms       10ms   1664:func socket(domain int, typ int, proto int) (fd int, err error) {
         .       50ms   1665:	r0, _, e1 := RawSyscall(SYS_SOCKET, uintptr(domain), uintptr(typ), uintptr(proto))
         .          .   1666:	fd = int(r0)
         .          .   1667:	if e1 != 0 {
         .          .   1668:		err = errnoErr(e1)
         .          .   1669:	}
         .          .   1670:	return
ROUTINE ======================== syscall.wait4 in /home/isucon/.local/go/src/syscall/zsyscall_linux_amd64.go
         0      120ms (flat, cum)  0.22% of Total
         .          .    167:}
         .          .    168:
         .          .    169:// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT
         .          .    170:
         .          .    171:func wait4(pid int, wstatus *_C_int, options int, rusage *Rusage) (wpid int, err error) {
         .      120ms    172:	r0, _, e1 := Syscall6(SYS_WAIT4, uintptr(pid), uintptr(unsafe.Pointer(wstatus)), uintptr(options), uintptr(unsafe.Pointer(rusage)), 0, 0)
         .          .    173:	wpid = int(r0)
         .          .    174:	if e1 != 0 {
         .          .    175:		err = errnoErr(e1)
         .          .    176:	}
         .          .    177:	return
ROUTINE ======================== syscall.write in /home/isucon/.local/go/src/syscall/zsyscall_linux_amd64.go
      20ms      2.49s (flat, cum)  4.47% of Total
         .          .   1059:	if len(p) > 0 {
         .          .   1060:		_p0 = unsafe.Pointer(&p[0])
         .          .   1061:	} else {
         .          .   1062:		_p0 = unsafe.Pointer(&_zero)
         .          .   1063:	}
      20ms      2.49s   1064:	r0, _, e1 := Syscall(SYS_WRITE, uintptr(fd), uintptr(_p0), uintptr(len(p)))
         .          .   1065:	n = int(r0)
         .          .   1066:	if e1 != 0 {
         .          .   1067:		err = errnoErr(e1)
         .          .   1068:	}
         .          .   1069:	return
ROUTINE ======================== text/template.(*Template).Execute in /home/isucon/.local/go/src/text/template/exec.go
         0      1.64s (flat, cum)  2.95% of Total
         .          .    173:		vars: []variable{{"$", value}},
         .          .    174:	}
         .          .    175:	if t.Tree == nil || t.Root == nil {
         .          .    176:		state.errorf("%q is an incomplete or empty template%s", t.Name(), t.DefinedTemplates())
         .          .    177:	}
         .      1.64s    178:	state.walk(value, t.Root)
         .          .    179:	return
         .          .    180:}
         .          .    181:
         .          .    182:// DefinedTemplates returns a string listing the defined templates,
         .          .    183:// prefixed by the string "; defined templates are: ". If there are none,
ROUTINE ======================== text/template.(*Template).Funcs in /home/isucon/.local/go/src/text/template/template.go
         0      140ms (flat, cum)  0.25% of Total
         .          .    165:// so calls can be chained.
         .          .    166:func (t *Template) Funcs(funcMap FuncMap) *Template {
         .          .    167:	t.init()
         .          .    168:	t.muFuncs.Lock()
         .          .    169:	defer t.muFuncs.Unlock()
         .      100ms    170:	addValueFuncs(t.execFuncs, funcMap)
         .       30ms    171:	addFuncs(t.parseFuncs, funcMap)
         .       10ms    172:	return t
         .          .    173:}
         .          .    174:
         .          .    175:// Lookup returns the template with the given name that is associated with t.
         .          .    176:// It returns nil if there is no such template or the template has no definition.
         .          .    177:func (t *Template) Lookup(name string) *Template {
ROUTINE ======================== text/template.(*Template).Parse in /home/isucon/.local/go/src/text/template/template.go
      10ms      300ms (flat, cum)  0.54% of Total
         .          .    185:// associated with the top-level template t. Parse may be called multiple times
         .          .    186:// to parse definitions of templates to associate with t.
         .          .    187:func (t *Template) Parse(text string) (*Template, error) {
         .          .    188:	t.init()
         .          .    189:	t.muFuncs.RLock()
      10ms      300ms    190:	trees, err := parse.Parse(t.name, text, t.leftDelim, t.rightDelim, t.parseFuncs, builtins)
         .          .    191:	t.muFuncs.RUnlock()
         .          .    192:	if err != nil {
         .          .    193:		return nil, err
         .          .    194:	}
         .          .    195:	// Add the newly parsed trees, including the one for t, into our common structure.
ROUTINE ======================== text/template.(*Template).Templates in /home/isucon/.local/go/src/text/template/template.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    137:func (t *Template) Templates() []*Template {
         .          .    138:	if t.common == nil {
         .          .    139:		return nil
         .          .    140:	}
         .          .    141:	// Return a slice so we don't expose the map.
      10ms       10ms    142:	m := make([]*Template, 0, len(t.tmpl))
         .          .    143:	for _, v := range t.tmpl {
         .          .    144:		m = append(m, v)
         .          .    145:	}
         .          .    146:	return m
         .          .    147:}
ROUTINE ======================== text/template.(*state).evalCall in /home/isucon/.local/go/src/text/template/exec.go
      20ms      940ms (flat, cum)  1.69% of Total
         .          .    584:)
         .          .    585:
         .          .    586:// evalCall executes a function or method call. If it's a method, fun already has the receiver bound, so
         .          .    587:// it looks just like a function call.  The arg list, if non-nil, includes (in the manner of the shell), arg[0]
         .          .    588:// as the function itself.
         .       10ms    589:func (s *state) evalCall(dot, fun reflect.Value, node parse.Node, name string, args []parse.Node, final reflect.Value) reflect.Value {
         .          .    590:	if args != nil {
         .          .    591:		args = args[1:] // Zeroth arg is function name/node; not passed to function.
         .          .    592:	}
         .       10ms    593:	typ := fun.Type()
         .          .    594:	numIn := len(args)
         .          .    595:	if final.IsValid() {
         .          .    596:		numIn++
         .          .    597:	}
         .          .    598:	numFixed := len(args)
         .          .    599:	if typ.IsVariadic() {
         .          .    600:		numFixed = typ.NumIn() - 1 // last arg is the variadic one.
         .          .    601:		if numIn < numFixed {
         .          .    602:			s.errorf("wrong number of args for %s: want at least %d got %d", name, typ.NumIn()-1, len(args))
         .          .    603:		}
         .          .    604:	} else if numIn < typ.NumIn()-1 || !typ.IsVariadic() && numIn != typ.NumIn() {
         .          .    605:		s.errorf("wrong number of args for %s: want %d got %d", name, typ.NumIn(), len(args))
         .          .    606:	}
         .          .    607:	if !goodFunc(typ) {
         .          .    608:		// TODO: This could still be a confusing error; maybe goodFunc should provide info.
         .          .    609:		s.errorf("can't call method/function %q with %d results", name, typ.NumOut())
         .          .    610:	}
         .          .    611:	// Build the arg list.
         .       40ms    612:	argv := make([]reflect.Value, numIn)
         .          .    613:	// Args must be evaluated. Fixed args first.
      10ms       10ms    614:	i := 0
         .          .    615:	for ; i < numFixed && i < len(args); i++ {
         .          .    616:		argv[i] = s.evalArg(dot, typ.In(i), args[i])
         .          .    617:	}
         .          .    618:	// Now the ... args.
         .          .    619:	if typ.IsVariadic() {
         .       10ms    620:		argType := typ.In(typ.NumIn() - 1).Elem() // Argument is a slice.
         .          .    621:		for ; i < len(args); i++ {
         .          .    622:			argv[i] = s.evalArg(dot, argType, args[i])
         .          .    623:		}
         .          .    624:	}
         .          .    625:	// Add final value if necessary.
      10ms       10ms    626:	if final.IsValid() {
         .          .    627:		t := typ.In(typ.NumIn() - 1)
         .          .    628:		if typ.IsVariadic() {
         .          .    629:			if numIn-1 < numFixed {
         .          .    630:				// The added final argument corresponds to a fixed parameter of the function.
         .          .    631:				// Validate against the type of the actual parameter.
         .          .    632:				t = typ.In(numIn - 1)
         .          .    633:			} else {
         .          .    634:				// The added final argument corresponds to the variadic part.
         .          .    635:				// Validate against the type of the elements of the variadic slice.
         .          .    636:				t = t.Elem()
         .          .    637:			}
         .          .    638:		}
         .          .    639:		argv[i] = s.validateType(final, t)
         .          .    640:	}
         .      850ms    641:	result := fun.Call(argv)
         .          .    642:	// If we have an error that is not nil, stop execution and return that error to the caller.
         .          .    643:	if len(result) == 2 && !result[1].IsNil() {
         .          .    644:		s.at(node)
         .          .    645:		s.errorf("error calling %s: %s", name, result[1].Interface().(error))
         .          .    646:	}
ROUTINE ======================== text/template.(*state).evalCommand in /home/isucon/.local/go/src/text/template/exec.go
      20ms      1.23s (flat, cum)  2.21% of Total
         .          .    399:		s.errorf("can't give argument to non-function %s", args[0])
         .          .    400:	}
         .          .    401:}
         .          .    402:
         .          .    403:func (s *state) evalCommand(dot reflect.Value, cmd *parse.CommandNode, final reflect.Value) reflect.Value {
      10ms       10ms    404:	firstWord := cmd.Args[0]
         .          .    405:	switch n := firstWord.(type) {
         .          .    406:	case *parse.FieldNode:
         .      230ms    407:		return s.evalFieldNode(dot, n, cmd.Args, final)
         .          .    408:	case *parse.ChainNode:
         .          .    409:		return s.evalChainNode(dot, n, cmd.Args, final)
         .          .    410:	case *parse.IdentifierNode:
         .          .    411:		// Must be a function.
      10ms      990ms    412:		return s.evalFunction(dot, n, cmd, cmd.Args, final)
         .          .    413:	case *parse.PipeNode:
         .          .    414:		// Parenthesized pipeline. The arguments are all inside the pipeline; final is ignored.
         .          .    415:		return s.evalPipeline(dot, n)
         .          .    416:	case *parse.VariableNode:
         .          .    417:		return s.evalVariableNode(dot, n, cmd.Args, final)
ROUTINE ======================== text/template.(*state).evalField in /home/isucon/.local/go/src/text/template/exec.go
      30ms      190ms (flat, cum)  0.34% of Total
         .          .    521:func (s *state) evalField(dot reflect.Value, fieldName string, node parse.Node, args []parse.Node, final, receiver reflect.Value) reflect.Value {
         .          .    522:	if !receiver.IsValid() {
         .          .    523:		return zero
         .          .    524:	}
         .          .    525:	typ := receiver.Type()
      10ms       10ms    526:	receiver, isNil := indirect(receiver)
         .          .    527:	// Unless it's an interface, need to get to a value of type *T to guarantee
         .          .    528:	// we see all methods of T and *T.
         .          .    529:	ptr := receiver
         .          .    530:	if ptr.Kind() != reflect.Interface && ptr.CanAddr() {
         .          .    531:		ptr = ptr.Addr()
         .          .    532:	}
         .       30ms    533:	if method := ptr.MethodByName(fieldName); method.IsValid() {
         .       60ms    534:		return s.evalCall(dot, method, node, fieldName, args, final)
         .          .    535:	}
         .          .    536:	hasArgs := len(args) > 1 || final.IsValid()
         .          .    537:	// It's not a method; must be a field of a struct or an element of a map. The receiver must not be nil.
         .          .    538:	if isNil {
         .          .    539:		s.errorf("nil pointer evaluating %s.%s", typ, fieldName)
         .          .    540:	}
         .          .    541:	switch receiver.Kind() {
         .          .    542:	case reflect.Struct:
      10ms       60ms    543:		tField, ok := receiver.Type().FieldByName(fieldName)
         .          .    544:		if ok {
      10ms       30ms    545:			field := receiver.FieldByIndex(tField.Index)
         .          .    546:			if tField.PkgPath != "" { // field is unexported
         .          .    547:				s.errorf("%s is an unexported field of struct type %s", fieldName, typ)
         .          .    548:			}
         .          .    549:			// If it's a function, we must call it.
         .          .    550:			if hasArgs {
ROUTINE ======================== text/template.(*state).evalFieldChain in /home/isucon/.local/go/src/text/template/exec.go
      30ms      220ms (flat, cum)   0.4% of Total
         .          .    497:// dot is the environment in which to evaluate arguments, while
         .          .    498:// receiver is the value being walked along the chain.
         .          .    499:func (s *state) evalFieldChain(dot, receiver reflect.Value, node parse.Node, ident []string, args []parse.Node, final reflect.Value) reflect.Value {
         .          .    500:	n := len(ident)
         .          .    501:	for i := 0; i < n-1; i++ {
      10ms       50ms    502:		receiver = s.evalField(dot, ident[i], node, nil, zero, receiver)
         .          .    503:	}
         .          .    504:	// Now if it's a method, it gets the arguments.
      20ms      170ms    505:	return s.evalField(dot, ident[n-1], node, args, final, receiver)
         .          .    506:}
         .          .    507:
         .          .    508:func (s *state) evalFunction(dot reflect.Value, node *parse.IdentifierNode, cmd parse.Node, args []parse.Node, final reflect.Value) reflect.Value {
         .          .    509:	s.at(node)
         .          .    510:	name := node.Ident
ROUTINE ======================== text/template.(*state).evalFieldNode in /home/isucon/.local/go/src/text/template/exec.go
      10ms      230ms (flat, cum)  0.41% of Total
         .          .    464:	return len(s) > 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X')
         .          .    465:}
         .          .    466:
         .          .    467:func (s *state) evalFieldNode(dot reflect.Value, field *parse.FieldNode, args []parse.Node, final reflect.Value) reflect.Value {
         .          .    468:	s.at(field)
      10ms      230ms    469:	return s.evalFieldChain(dot, dot, field, field.Ident, args, final)
         .          .    470:}
         .          .    471:
         .          .    472:func (s *state) evalChainNode(dot reflect.Value, chain *parse.ChainNode, args []parse.Node, final reflect.Value) reflect.Value {
         .          .    473:	s.at(chain)
         .          .    474:	if len(chain.Field) == 0 {
ROUTINE ======================== text/template.(*state).evalFunction in /home/isucon/.local/go/src/text/template/exec.go
      30ms      980ms (flat, cum)  1.76% of Total
         .          .    505:	return s.evalField(dot, ident[n-1], node, args, final, receiver)
         .          .    506:}
         .          .    507:
         .          .    508:func (s *state) evalFunction(dot reflect.Value, node *parse.IdentifierNode, cmd parse.Node, args []parse.Node, final reflect.Value) reflect.Value {
         .          .    509:	s.at(node)
      10ms       10ms    510:	name := node.Ident
      10ms       80ms    511:	function, ok := findFunction(name, s.tmpl)
         .          .    512:	if !ok {
         .          .    513:		s.errorf("%q is not a defined function", name)
         .          .    514:	}
      10ms      890ms    515:	return s.evalCall(dot, function, cmd, name, args, final)
         .          .    516:}
         .          .    517:
         .          .    518:// evalField evaluates an expression like (.Field) or (.Field arg1 arg2).
         .          .    519:// The 'final' argument represents the return value from the preceding
         .          .    520:// value of the pipeline, if any.
ROUTINE ======================== text/template.(*state).evalPipeline in /home/isucon/.local/go/src/text/template/exec.go
      10ms      1.24s (flat, cum)  2.23% of Total
         .          .    380:	if pipe == nil {
         .          .    381:		return
         .          .    382:	}
         .          .    383:	s.at(pipe)
         .          .    384:	for _, cmd := range pipe.Cmds {
         .      1.23s    385:		value = s.evalCommand(dot, cmd, value) // previous value is this one's final arg.
         .          .    386:		// If the object has type interface{}, dig down one level to the thing inside.
         .          .    387:		if value.Kind() == reflect.Interface && value.Type().NumMethod() == 0 {
         .          .    388:			value = reflect.ValueOf(value.Interface()) // lovely!
         .          .    389:		}
         .          .    390:	}
      10ms       10ms    391:	for _, variable := range pipe.Decl {
         .          .    392:		s.push(variable.Ident[0], value)
         .          .    393:	}
         .          .    394:	return value
         .          .    395:}
         .          .    396:
ROUTINE ======================== text/template.(*state).printValue in /home/isucon/.local/go/src/text/template/exec.go
         0      130ms (flat, cum)  0.23% of Total
         .          .    839:
         .          .    840:// printValue writes the textual representation of the value to the output of
         .          .    841:// the template.
         .          .    842:func (s *state) printValue(n parse.Node, v reflect.Value) {
         .          .    843:	s.at(n)
         .       30ms    844:	iface, ok := printableValue(v)
         .          .    845:	if !ok {
         .          .    846:		s.errorf("can't print %s of type %s", n, v.Type())
         .          .    847:	}
         .      100ms    848:	_, err := fmt.Fprint(s.wr, iface)
         .          .    849:	if err != nil {
         .          .    850:		s.writeError(err)
         .          .    851:	}
         .          .    852:}
         .          .    853:
ROUTINE ======================== text/template.(*state).walk in /home/isucon/.local/go/src/text/template/exec.go
      30ms      6.38s (flat, cum) 11.46% of Total
         .          .    206:
         .          .    207:// Walk functions step through the major pieces of the template structure,
         .          .    208:// generating output as they go.
         .          .    209:func (s *state) walk(dot reflect.Value, node parse.Node) {
         .          .    210:	s.at(node)
         .       30ms    211:	switch node := node.(type) {
         .          .    212:	case *parse.ActionNode:
         .          .    213:		// Do not pop variables so they persist until next end.
         .          .    214:		// Also, if the action declares variables, don't print the result.
         .      1.19s    215:		val := s.evalPipeline(dot, node.Pipe)
         .          .    216:		if len(node.Pipe.Decl) == 0 {
         .      130ms    217:			s.printValue(node, val)
         .          .    218:		}
         .          .    219:	case *parse.IfNode:
         .       40ms    220:		s.walkIfOrWith(parse.NodeIf, dot, node.Pipe, node.List, node.ElseList)
         .          .    221:	case *parse.ListNode:
      20ms       20ms    222:		for _, node := range node.Nodes {
      10ms      1.64s    223:			s.walk(dot, node)
         .          .    224:		}
         .          .    225:	case *parse.RangeNode:
         .      1.55s    226:		s.walkRange(dot, node)
         .          .    227:	case *parse.TemplateNode:
         .      1.60s    228:		s.walkTemplate(dot, node)
         .          .    229:	case *parse.TextNode:
         .      180ms    230:		if _, err := s.wr.Write(node.Text); err != nil {
         .          .    231:			s.writeError(err)
         .          .    232:		}
         .          .    233:	case *parse.WithNode:
         .          .    234:		s.walkIfOrWith(parse.NodeWith, dot, node.Pipe, node.List, node.ElseList)
         .          .    235:	default:
ROUTINE ======================== text/template.(*state).walkIfOrWith in /home/isucon/.local/go/src/text/template/exec.go
         0       40ms (flat, cum) 0.072% of Total
         .          .    239:
         .          .    240:// walkIfOrWith walks an 'if' or 'with' node. The two control structures
         .          .    241:// are identical in behavior except that 'with' sets dot.
         .          .    242:func (s *state) walkIfOrWith(typ parse.NodeType, dot reflect.Value, pipe *parse.PipeNode, list, elseList *parse.ListNode) {
         .          .    243:	defer s.pop(s.mark())
         .       30ms    244:	val := s.evalPipeline(dot, pipe)
         .          .    245:	truth, ok := isTrue(val)
         .          .    246:	if !ok {
         .          .    247:		s.errorf("if/with can't use %v", val)
         .          .    248:	}
         .          .    249:	if truth {
         .          .    250:		if typ == parse.NodeWith {
         .          .    251:			s.walk(val, list)
         .          .    252:		} else {
         .          .    253:			s.walk(dot, list)
         .          .    254:		}
         .          .    255:	} else if elseList != nil {
         .       10ms    256:		s.walk(dot, elseList)
         .          .    257:	}
         .          .    258:}
         .          .    259:
         .          .    260:// IsTrue reports whether the value is 'true', in the sense of not the zero of its type,
         .          .    261:// and whether the value has a meaningful truth value. This is the definition of
ROUTINE ======================== text/template.(*state).walkRange in /home/isucon/.local/go/src/text/template/exec.go
         0      1.57s (flat, cum)  2.82% of Total
         .          .    293:}
         .          .    294:
         .          .    295:func (s *state) walkRange(dot reflect.Value, r *parse.RangeNode) {
         .          .    296:	s.at(r)
         .          .    297:	defer s.pop(s.mark())
         .       20ms    298:	val, _ := indirect(s.evalPipeline(dot, r.Pipe))
         .          .    299:	// mark top of stack before any variables in the body are pushed.
         .          .    300:	mark := s.mark()
         .          .    301:	oneIteration := func(index, elem reflect.Value) {
         .          .    302:		// Set top var (lexically the second if there are two) to the element.
         .          .    303:		if len(r.Pipe.Decl) > 0 {
         .          .    304:			s.setVar(1, elem)
         .          .    305:		}
         .          .    306:		// Set next var (lexically the first if there are two) to the index.
         .          .    307:		if len(r.Pipe.Decl) > 1 {
         .          .    308:			s.setVar(2, index)
         .          .    309:		}
         .          .    310:		s.walk(elem, r.List)
         .          .    311:		s.pop(mark)
         .          .    312:	}
         .          .    313:	switch val.Kind() {
         .          .    314:	case reflect.Array, reflect.Slice:
         .          .    315:		if val.Len() == 0 {
         .          .    316:			break
         .          .    317:		}
         .          .    318:		for i := 0; i < val.Len(); i++ {
         .      1.55s    319:			oneIteration(reflect.ValueOf(i), val.Index(i))
         .          .    320:		}
         .          .    321:		return
         .          .    322:	case reflect.Map:
         .          .    323:		if val.Len() == 0 {
         .          .    324:			break
ROUTINE ======================== text/template.(*state).walkRange.func1 in /home/isucon/.local/go/src/text/template/exec.go
         0      1.54s (flat, cum)  2.77% of Total
         .          .    305:		}
         .          .    306:		// Set next var (lexically the first if there are two) to the index.
         .          .    307:		if len(r.Pipe.Decl) > 1 {
         .          .    308:			s.setVar(2, index)
         .          .    309:		}
         .      1.54s    310:		s.walk(elem, r.List)
         .          .    311:		s.pop(mark)
         .          .    312:	}
         .          .    313:	switch val.Kind() {
         .          .    314:	case reflect.Array, reflect.Slice:
         .          .    315:		if val.Len() == 0 {
ROUTINE ======================== text/template.(*state).walkTemplate in /home/isucon/.local/go/src/text/template/exec.go
      10ms      1.62s (flat, cum)  2.91% of Total
         .          .    353:	}
         .          .    354:}
         .          .    355:
         .          .    356:func (s *state) walkTemplate(dot reflect.Value, t *parse.TemplateNode) {
         .          .    357:	s.at(t)
      10ms       10ms    358:	tmpl := s.tmpl.tmpl[t.Name]
         .          .    359:	if tmpl == nil {
         .          .    360:		s.errorf("template %q not defined", t.Name)
         .          .    361:	}
         .          .    362:	// Variables declared by the pipeline persist.
         .          .    363:	dot = s.evalPipeline(dot, t.Pipe)
         .          .    364:	newState := *s
         .          .    365:	newState.tmpl = tmpl
         .          .    366:	// No dynamic scoping: template invocations inherit no variables.
         .       10ms    367:	newState.vars = []variable{{"$", dot}}
         .      1.60s    368:	newState.walk(dot, tmpl.Root)
         .          .    369:}
         .          .    370:
         .          .    371:// Eval functions evaluate pipelines, commands, and their elements and extract
         .          .    372:// values from the data structure by examining fields, calling methods, and so on.
         .          .    373:// The printing of those values happens only through walk functions.
ROUTINE ======================== text/template.addFuncs in /home/isucon/.local/go/src/text/template/funcs.go
         0       30ms (flat, cum) 0.054% of Total
         .          .     74:
         .          .     75:// addFuncs adds to values the functions in funcs. It does no checking of the input -
         .          .     76:// call addValueFuncs first.
         .          .     77:func addFuncs(out, in FuncMap) {
         .          .     78:	for name, fn := range in {
         .       30ms     79:		out[name] = fn
         .          .     80:	}
         .          .     81:}
         .          .     82:
         .          .     83:// goodFunc reports whether the function or method has the right result signature.
         .          .     84:func goodFunc(typ reflect.Type) bool {
ROUTINE ======================== text/template.addValueFuncs in /home/isucon/.local/go/src/text/template/funcs.go
      10ms      100ms (flat, cum)  0.18% of Total
         .          .     55:	return m
         .          .     56:}
         .          .     57:
         .          .     58:// addValueFuncs adds to values the functions in funcs, converting them to reflect.Values.
         .          .     59:func addValueFuncs(out map[string]reflect.Value, in FuncMap) {
         .       30ms     60:	for name, fn := range in {
         .       30ms     61:		if !goodName(name) {
         .          .     62:			panic(fmt.Errorf("function name %s is not a valid identifier", name))
         .          .     63:		}
         .       10ms     64:		v := reflect.ValueOf(fn)
         .          .     65:		if v.Kind() != reflect.Func {
         .          .     66:			panic("value for " + name + " not a function")
         .          .     67:		}
         .          .     68:		if !goodFunc(v.Type()) {
         .          .     69:			panic(fmt.Errorf("can't install method/function %q with %d results", name, v.Type().NumOut()))
         .          .     70:		}
      10ms       30ms     71:		out[name] = v
         .          .     72:	}
         .          .     73:}
         .          .     74:
         .          .     75:// addFuncs adds to values the functions in funcs. It does no checking of the input -
         .          .     76:// call addValueFuncs first.
ROUTINE ======================== text/template.findFunction in /home/isucon/.local/go/src/text/template/funcs.go
      10ms       70ms (flat, cum)  0.13% of Total
         .          .    110:}
         .          .    111:
         .          .    112:// findFunction looks for a function in the template, and global map.
         .          .    113:func findFunction(name string, tmpl *Template) (reflect.Value, bool) {
         .          .    114:	if tmpl != nil && tmpl.common != nil {
      10ms       30ms    115:		tmpl.muFuncs.RLock()
         .          .    116:		defer tmpl.muFuncs.RUnlock()
         .       20ms    117:		if fn := tmpl.execFuncs[name]; fn.IsValid() {
         .       20ms    118:			return fn, true
         .          .    119:		}
         .          .    120:	}
         .          .    121:	if fn := builtinFuncs[name]; fn.IsValid() {
         .          .    122:		return fn, true
         .          .    123:	}
ROUTINE ======================== text/template.goodName in /home/isucon/.local/go/src/text/template/funcs.go
      30ms       30ms (flat, cum) 0.054% of Total
         .          .     95:// goodName reports whether the function name is a valid identifier.
         .          .     96:func goodName(name string) bool {
         .          .     97:	if name == "" {
         .          .     98:		return false
         .          .     99:	}
      30ms       30ms    100:	for i, r := range name {
         .          .    101:		switch {
         .          .    102:		case r == '_':
         .          .    103:		case i == 0 && !unicode.IsLetter(r):
         .          .    104:			return false
         .          .    105:		case !unicode.IsLetter(r) && !unicode.IsDigit(r):
ROUTINE ======================== text/template.printableValue in /home/isucon/.local/go/src/text/template/exec.go
      20ms       30ms (flat, cum) 0.054% of Total
         .          .    859:	}
         .          .    860:	if !v.IsValid() {
         .          .    861:		return "<no value>", true
         .          .    862:	}
         .          .    863:
      10ms       20ms    864:	if !v.Type().Implements(errorType) && !v.Type().Implements(fmtStringerType) {
         .          .    865:		if v.CanAddr() && (reflect.PtrTo(v.Type()).Implements(errorType) || reflect.PtrTo(v.Type()).Implements(fmtStringerType)) {
         .          .    866:			v = v.Addr()
         .          .    867:		} else {
         .          .    868:			switch v.Kind() {
         .          .    869:			case reflect.Chan, reflect.Func:
         .          .    870:				return nil, false
         .          .    871:			}
         .          .    872:		}
         .          .    873:	}
      10ms       10ms    874:	return v.Interface(), true
         .          .    875:}
         .          .    876:
         .          .    877:// Types to help sort the keys in a map for reproducible output.
         .          .    878:
         .          .    879:type rvs []reflect.Value
ROUTINE ======================== text/template/parse.(*ChainNode).String in /home/isucon/.local/go/src/text/template/parse/node.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    465:	}
         .          .    466:	c.Field = append(c.Field, field)
         .          .    467:}
         .          .    468:
         .          .    469:func (c *ChainNode) String() string {
         .       20ms    470:	s := c.Node.String()
         .          .    471:	if _, ok := c.Node.(*PipeNode); ok {
         .          .    472:		s = "(" + s + ")"
         .          .    473:	}
         .          .    474:	for _, field := range c.Field {
         .          .    475:		s += "." + field
ROUTINE ======================== text/template/parse.(*FieldNode).String in /home/isucon/.local/go/src/text/template/parse/node.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    424:}
         .          .    425:
         .          .    426:func (f *FieldNode) String() string {
         .          .    427:	s := ""
         .          .    428:	for _, id := range f.Ident {
         .       20ms    429:		s += "." + id
         .          .    430:	}
         .          .    431:	return s
         .          .    432:}
         .          .    433:
         .          .    434:func (f *FieldNode) tree() *Tree {
ROUTINE ======================== text/template/parse.(*Tree).Parse in /home/isucon/.local/go/src/text/template/parse/parse.go
      10ms      260ms (flat, cum)  0.47% of Total
         .          .    225:// Parse parses the template definition string to construct a representation of
         .          .    226:// the template for execution. If either action delimiter string is empty, the
         .          .    227:// default ("{{" or "}}") is used. Embedded template definitions are added to
         .          .    228:// the treeSet map.
         .          .    229:func (t *Tree) Parse(text, leftDelim, rightDelim string, treeSet map[string]*Tree, funcs ...map[string]interface{}) (tree *Tree, err error) {
         .       10ms    230:	defer t.recover(&err)
         .          .    231:	t.ParseName = t.Name
         .          .    232:	t.startParse(funcs, lex(t.Name, text, leftDelim, rightDelim), treeSet)
         .          .    233:	t.text = text
         .      240ms    234:	t.parse()
      10ms       10ms    235:	t.add()
         .          .    236:	t.stopParse()
         .          .    237:	return t, nil
         .          .    238:}
         .          .    239:
         .          .    240:// add adds tree to t.treeSet.
ROUTINE ======================== text/template/parse.(*Tree).action in /home/isucon/.local/go/src/text/template/parse/parse.go
         0      210ms (flat, cum)  0.38% of Total
         .          .    366:	case itemElse:
         .          .    367:		return t.elseControl()
         .          .    368:	case itemEnd:
         .          .    369:		return t.endControl()
         .          .    370:	case itemIf:
         .       70ms    371:		return t.ifControl()
         .          .    372:	case itemRange:
         .       50ms    373:		return t.rangeControl()
         .          .    374:	case itemTemplate:
         .       40ms    375:		return t.templateControl()
         .          .    376:	case itemWith:
         .          .    377:		return t.withControl()
         .          .    378:	}
         .          .    379:	t.backup()
         .          .    380:	// Do not pop variables; they persist until "end".
         .       50ms    381:	return t.newAction(t.peek().pos, t.lex.lineNumber(), t.pipeline("command"))
         .          .    382:}
         .          .    383:
         .          .    384:// Pipeline:
         .          .    385://	declarations? command ('|' command)*
         .          .    386:func (t *Tree) pipeline(context string) (pipe *PipeNode) {
ROUTINE ======================== text/template/parse.(*Tree).command in /home/isucon/.local/go/src/text/template/parse/parse.go
         0       70ms (flat, cum)  0.13% of Total
         .          .    591:// we consume the pipe character but leave the right delim to terminate the action.
         .          .    592:func (t *Tree) command() *CommandNode {
         .          .    593:	cmd := t.newCommand(t.peekNonSpace().pos)
         .          .    594:	for {
         .          .    595:		t.peekNonSpace() // skip leading spaces.
         .       60ms    596:		operand := t.operand()
         .          .    597:		if operand != nil {
         .       10ms    598:			cmd.append(operand)
         .          .    599:		}
         .          .    600:		switch token := t.next(); token.typ {
         .          .    601:		case itemSpace:
         .          .    602:			continue
         .          .    603:		case itemError:
ROUTINE ======================== text/template/parse.(*Tree).ifControl in /home/isucon/.local/go/src/text/template/parse/parse.go
         0       70ms (flat, cum)  0.13% of Total
         .          .    486:// If:
         .          .    487://	{{if pipeline}} itemList {{end}}
         .          .    488://	{{if pipeline}} itemList {{else}} itemList {{end}}
         .          .    489:// If keyword is past.
         .          .    490:func (t *Tree) ifControl() Node {
         .       70ms    491:	return t.newIf(t.parseControl(true, "if"))
         .          .    492:}
         .          .    493:
         .          .    494:// Range:
         .          .    495://	{{range pipeline}} itemList {{end}}
         .          .    496://	{{range pipeline}} itemList {{else}} itemList {{end}}
ROUTINE ======================== text/template/parse.(*Tree).itemList in /home/isucon/.local/go/src/text/template/parse/parse.go
         0      100ms (flat, cum)  0.18% of Total
         .          .    325:
         .          .    326:// itemList:
         .          .    327://	textOrAction*
         .          .    328:// Terminates at {{end}} or {{else}}, returned separately.
         .          .    329:func (t *Tree) itemList() (list *ListNode, next Node) {
         .       10ms    330:	list = t.newList(t.peekNonSpace().pos)
         .       10ms    331:	for t.peekNonSpace().typ != itemEOF {
         .       80ms    332:		n := t.textOrAction()
         .          .    333:		switch n.Type() {
         .          .    334:		case nodeEnd, nodeElse:
         .          .    335:			return list, n
         .          .    336:		}
         .          .    337:		list.append(n)
ROUTINE ======================== text/template/parse.(*Tree).newField in /home/isucon/.local/go/src/text/template/parse/node.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    418:	tr    *Tree
         .          .    419:	Ident []string // The identifiers in lexical order.
         .          .    420:}
         .          .    421:
         .          .    422:func (t *Tree) newField(pos Pos, ident string) *FieldNode {
         .       10ms    423:	return &FieldNode{tr: t, NodeType: NodeField, Pos: pos, Ident: strings.Split(ident[1:], ".")} // [1:] to drop leading period
         .          .    424:}
         .          .    425:
         .          .    426:func (f *FieldNode) String() string {
         .          .    427:	s := ""
         .          .    428:	for _, id := range f.Ident {
ROUTINE ======================== text/template/parse.(*Tree).nextNonSpace in /home/isucon/.local/go/src/text/template/parse/parse.go
         0       10ms (flat, cum) 0.018% of Total
         .          .     97:}
         .          .     98:
         .          .     99:// nextNonSpace returns the next non-space token.
         .          .    100:func (t *Tree) nextNonSpace() (token item) {
         .          .    101:	for {
         .       10ms    102:		token = t.next()
         .          .    103:		if token.typ != itemSpace {
         .          .    104:			break
         .          .    105:		}
         .          .    106:	}
         .          .    107:	return token
ROUTINE ======================== text/template/parse.(*Tree).operand in /home/isucon/.local/go/src/text/template/parse/parse.go
         0       60ms (flat, cum)  0.11% of Total
         .          .    620://	term .Field*
         .          .    621:// An operand is a space-separated component of a command,
         .          .    622:// a term possibly followed by field accesses.
         .          .    623:// A nil return means the next item is not an operand.
         .          .    624:func (t *Tree) operand() Node {
         .       30ms    625:	node := t.term()
         .          .    626:	if node == nil {
         .          .    627:		return nil
         .          .    628:	}
         .       10ms    629:	if t.peek().typ == itemField {
         .          .    630:		chain := t.newChain(t.peek().pos, node)
         .          .    631:		for t.peek().typ == itemField {
         .          .    632:			chain.Add(t.next().val)
         .          .    633:		}
         .          .    634:		// Compatibility with original API: If the term is of type NodeField
         .          .    635:		// or NodeVariable, just put more fields on the original.
         .          .    636:		// Otherwise, keep the Chain node.
         .          .    637:		// Obvious parsing errors involving literal values are detected here.
         .          .    638:		// More complex error cases will have to be handled at execution time.
         .          .    639:		switch node.Type() {
         .          .    640:		case NodeField:
         .       20ms    641:			node = t.newField(chain.Position(), chain.String())
         .          .    642:		case NodeVariable:
         .          .    643:			node = t.newVariable(chain.Position(), chain.String())
         .          .    644:		case NodeBool, NodeString, NodeNumber, NodeNil, NodeDot:
         .          .    645:			t.errorf("unexpected . after term %q", node.String())
         .          .    646:		default:
ROUTINE ======================== text/template/parse.(*Tree).parse in /home/isucon/.local/go/src/text/template/parse/parse.go
         0      240ms (flat, cum)  0.43% of Total
         .          .    276:
         .          .    277:// parse is the top-level parser for a template, essentially the same
         .          .    278:// as itemList except it also parses {{define}} actions.
         .          .    279:// It runs to EOF.
         .          .    280:func (t *Tree) parse() (next Node) {
         .       10ms    281:	t.Root = t.newList(t.peek().pos)
         .          .    282:	for t.peek().typ != itemEOF {
         .          .    283:		if t.peek().typ == itemLeftDelim {
         .          .    284:			delim := t.next()
         .          .    285:			if t.nextNonSpace().typ == itemDefine {
         .          .    286:				newT := New("definition") // name will be updated once we know it.
         .          .    287:				newT.text = t.text
         .          .    288:				newT.ParseName = t.ParseName
         .          .    289:				newT.startParse(t.funcs, t.lex, t.treeSet)
         .       20ms    290:				newT.parseDefinition()
         .          .    291:				continue
         .          .    292:			}
         .          .    293:			t.backup2(delim)
         .          .    294:		}
         .      190ms    295:		switch n := t.textOrAction(); n.Type() {
         .          .    296:		case nodeEnd, nodeElse:
         .          .    297:			t.errorf("unexpected %s", n)
         .          .    298:		default:
         .       20ms    299:			t.Root.append(n)
         .          .    300:		}
         .          .    301:	}
         .          .    302:	return nil
         .          .    303:}
         .          .    304:
ROUTINE ======================== text/template/parse.(*Tree).parseControl in /home/isucon/.local/go/src/text/template/parse/parse.go
         0      130ms (flat, cum)  0.23% of Total
         .          .    450:}
         .          .    451:
         .          .    452:func (t *Tree) parseControl(allowElseIf bool, context string) (pos Pos, line int, pipe *PipeNode, list, elseList *ListNode) {
         .          .    453:	defer t.popVars(len(t.vars))
         .          .    454:	line = t.lex.lineNumber()
         .       50ms    455:	pipe = t.pipeline(context)
         .          .    456:	var next Node
         .       50ms    457:	list, next = t.itemList()
         .          .    458:	switch next.Type() {
         .          .    459:	case nodeEnd: //done
         .          .    460:	case nodeElse:
         .          .    461:		if allowElseIf {
         .          .    462:			// Special case for "else if". If the "else" is followed immediately by an "if",
         .          .    463:			// the elseControl will have left the "if" token pending. Treat
         .          .    464:			//	{{if a}}_{{else if b}}_{{end}}
         .          .    465:			// as
         .          .    466:			//	{{if a}}_{{else}}{{if b}}_{{end}}{{end}}.
         .          .    467:			// To do this, parse the if as usual and stop at it {{end}}; the subsequent{{end}}
         .          .    468:			// is assumed. This technique works even for long if-else-if chains.
         .          .    469:			// TODO: Should we allow else-if in with and range?
         .          .    470:			if t.peek().typ == itemIf {
         .          .    471:				t.next() // Consume the "if" token.
         .          .    472:				elseList = t.newList(next.Position())
         .          .    473:				elseList.append(t.ifControl())
         .          .    474:				// Do not consume the next item - only one {{end}} required.
         .          .    475:				break
         .          .    476:			}
         .          .    477:		}
         .       30ms    478:		elseList, next = t.itemList()
         .          .    479:		if next.Type() != nodeEnd {
         .          .    480:			t.errorf("expected end; found %s", next)
         .          .    481:		}
         .          .    482:	}
         .          .    483:	return pipe.Position(), line, pipe, list, elseList
ROUTINE ======================== text/template/parse.(*Tree).parseDefinition in /home/isucon/.local/go/src/text/template/parse/parse.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    313:	if err != nil {
         .          .    314:		t.error(err)
         .          .    315:	}
         .          .    316:	t.expect(itemRightDelim, context)
         .          .    317:	var end Node
         .       20ms    318:	t.Root, end = t.itemList()
         .          .    319:	if end.Type() != nodeEnd {
         .          .    320:		t.errorf("unexpected %s in %s", end, context)
         .          .    321:	}
         .          .    322:	t.add()
         .          .    323:	t.stopParse()
ROUTINE ======================== text/template/parse.(*Tree).peekNonSpace in /home/isucon/.local/go/src/text/template/parse/parse.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    108:}
         .          .    109:
         .          .    110:// peekNonSpace returns but does not consume the next non-space token.
         .          .    111:func (t *Tree) peekNonSpace() (token item) {
         .          .    112:	for {
         .       10ms    113:		token = t.next()
         .          .    114:		if token.typ != itemSpace {
         .          .    115:			break
         .          .    116:		}
         .          .    117:	}
         .          .    118:	t.backup()
ROUTINE ======================== text/template/parse.(*Tree).pipeline in /home/isucon/.local/go/src/text/template/parse/parse.go
         0      100ms (flat, cum)  0.18% of Total
         .          .    412:				t.backup2(v)
         .          .    413:			}
         .          .    414:		}
         .          .    415:		break
         .          .    416:	}
         .       30ms    417:	pipe = t.newPipeline(pos, t.lex.lineNumber(), decl)
         .          .    418:	for {
         .          .    419:		switch token := t.nextNonSpace(); token.typ {
         .          .    420:		case itemRightDelim, itemRightParen:
         .          .    421:			// At this point, the pipeline is complete
         .          .    422:			t.checkPipeline(pipe, context)
         .          .    423:			if token.typ == itemRightParen {
         .          .    424:				t.backup()
         .          .    425:			}
         .          .    426:			return
         .          .    427:		case itemBool, itemCharConstant, itemComplex, itemDot, itemField, itemIdentifier,
         .          .    428:			itemNumber, itemNil, itemRawString, itemString, itemVariable, itemLeftParen:
         .          .    429:			t.backup()
         .       70ms    430:			pipe.append(t.command())
         .          .    431:		default:
         .          .    432:			t.unexpected(token, context)
         .          .    433:		}
         .          .    434:	}
         .          .    435:}
ROUTINE ======================== text/template/parse.(*Tree).rangeControl in /home/isucon/.local/go/src/text/template/parse/parse.go
         0       50ms (flat, cum)  0.09% of Total
         .          .    494:// Range:
         .          .    495://	{{range pipeline}} itemList {{end}}
         .          .    496://	{{range pipeline}} itemList {{else}} itemList {{end}}
         .          .    497:// Range keyword is past.
         .          .    498:func (t *Tree) rangeControl() Node {
         .       50ms    499:	return t.newRange(t.parseControl(false, "range"))
         .          .    500:}
         .          .    501:
         .          .    502:// With:
         .          .    503://	{{with pipeline}} itemList {{end}}
         .          .    504://	{{with pipeline}} itemList {{else}} itemList {{end}}
ROUTINE ======================== text/template/parse.(*Tree).templateControl in /home/isucon/.local/go/src/text/template/parse/parse.go
         0       40ms (flat, cum) 0.072% of Total
         .          .    558://	{{template stringValue pipeline}}
         .          .    559:// Template keyword is past.  The name must be something that can evaluate
         .          .    560:// to a string.
         .          .    561:func (t *Tree) templateControl() Node {
         .          .    562:	const context = "template clause"
         .       10ms    563:	token := t.nextNonSpace()
         .          .    564:	name := t.parseTemplateName(token, context)
         .          .    565:	var pipe *PipeNode
         .          .    566:	if t.nextNonSpace().typ != itemRightDelim {
         .          .    567:		t.backup()
         .          .    568:		// Do not pop variables; they persist until "end".
         .       30ms    569:		pipe = t.pipeline(context)
         .          .    570:	}
         .          .    571:	return t.newTemplate(token.pos, t.lex.lineNumber(), name, pipe)
         .          .    572:}
         .          .    573:
         .          .    574:func (t *Tree) parseTemplateName(token item, context string) (name string) {
ROUTINE ======================== text/template/parse.(*Tree).term in /home/isucon/.local/go/src/text/template/parse/parse.go
      20ms       30ms (flat, cum) 0.054% of Total
         .          .    657://	.Field
         .          .    658://	$
         .          .    659://	'(' pipeline ')'
         .          .    660:// A term is a simple "expression".
         .          .    661:// A nil return means the next item is not a term.
      10ms       10ms    662:func (t *Tree) term() Node {
      10ms       10ms    663:	switch token := t.nextNonSpace(); token.typ {
         .          .    664:	case itemError:
         .          .    665:		t.errorf("%s", token.val)
         .          .    666:	case itemIdentifier:
         .          .    667:		if !t.hasFunction(token.val) {
         .          .    668:			t.errorf("function %q not defined", token.val)
         .          .    669:		}
         .          .    670:		return NewIdentifier(token.val).SetTree(t).SetPos(token.pos)
         .          .    671:	case itemDot:
         .          .    672:		return t.newDot(token.pos)
         .          .    673:	case itemNil:
         .          .    674:		return t.newNil(token.pos)
         .          .    675:	case itemVariable:
         .          .    676:		return t.useVar(token.pos, token.val)
         .          .    677:	case itemField:
         .       10ms    678:		return t.newField(token.pos, token.val)
         .          .    679:	case itemBool:
         .          .    680:		return t.newBool(token.pos, token.val == "true")
         .          .    681:	case itemCharConstant, itemComplex, itemNumber:
         .          .    682:		number, err := t.newNumber(token.pos, token.val, token.typ)
         .          .    683:		if err != nil {
ROUTINE ======================== text/template/parse.(*Tree).textOrAction in /home/isucon/.local/go/src/text/template/parse/parse.go
      10ms      230ms (flat, cum)  0.41% of Total
         .          .    340:	return
         .          .    341:}
         .          .    342:
         .          .    343:// textOrAction:
         .          .    344://	text | action
      10ms       10ms    345:func (t *Tree) textOrAction() Node {
         .          .    346:	switch token := t.nextNonSpace(); token.typ {
         .          .    347:	case itemText:
         .       40ms    348:		return t.newText(token.pos, token.val)
         .          .    349:	case itemLeftDelim:
         .      180ms    350:		return t.action()
         .          .    351:	default:
         .          .    352:		t.unexpected(token, "input")
         .          .    353:	}
         .          .    354:	return nil
         .          .    355:}
ROUTINE ======================== text/template/parse.(*lexer).lineNumber in /home/isucon/.local/go/src/text/template/parse/lex.go
      10ms       50ms (flat, cum)  0.09% of Total
         .          .    170:}
         .          .    171:
         .          .    172:// lineNumber reports which line we're on, based on the position of
         .          .    173:// the previous item returned by nextItem. Doing it this way
         .          .    174:// means we don't have to worry about peek double counting.
      10ms       10ms    175:func (l *lexer) lineNumber() int {
         .       40ms    176:	return 1 + strings.Count(l.input[:l.lastPos], "\n")
         .          .    177:}
         .          .    178:
         .          .    179:// errorf returns an error token and terminates the scan by passing
         .          .    180:// back a nil pointer that will be the next state, terminating l.nextItem.
         .          .    181:func (l *lexer) errorf(format string, args ...interface{}) stateFn {
ROUTINE ======================== text/template/parse.(*lexer).next in /home/isucon/.local/go/src/text/template/parse/lex.go
      20ms       70ms (flat, cum)  0.13% of Total
         .          .    117:	items      chan item // channel of scanned items
         .          .    118:	parenDepth int       // nesting depth of ( ) exprs
         .          .    119:}
         .          .    120:
         .          .    121:// next returns the next rune in the input.
      20ms       20ms    122:func (l *lexer) next() rune {
         .          .    123:	if int(l.pos) >= len(l.input) {
         .          .    124:		l.width = 0
         .          .    125:		return eof
         .          .    126:	}
         .       50ms    127:	r, w := utf8.DecodeRuneInString(l.input[l.pos:])
         .          .    128:	l.width = Pos(w)
         .          .    129:	l.pos += l.width
         .          .    130:	return r
         .          .    131:}
         .          .    132:
ROUTINE ======================== text/template/parse.(*lexer).run in /home/isucon/.local/go/src/text/template/parse/lex.go
         0      190ms (flat, cum)  0.34% of Total
         .          .    218:}
         .          .    219:
         .          .    220:// run runs the state machine for the lexer.
         .          .    221:func (l *lexer) run() {
         .          .    222:	for l.state = lexText; l.state != nil; {
         .      190ms    223:		l.state = l.state(l)
         .          .    224:	}
         .          .    225:	close(l.items)
         .          .    226:}
         .          .    227:
         .          .    228:// state functions
ROUTINE ======================== text/template/parse.Parse in /home/isucon/.local/go/src/text/template/parse/parse.go
         0      270ms (flat, cum)  0.49% of Total
         .          .     47:// Parse returns a map from template name to parse.Tree, created by parsing the
         .          .     48:// templates described in the argument string. The top-level template will be
         .          .     49:// given the specified name. If an error is encountered, parsing stops and an
         .          .     50:// empty map is returned with the error.
         .          .     51:func Parse(name, text, leftDelim, rightDelim string, funcs ...map[string]interface{}) (treeSet map[string]*Tree, err error) {
         .       10ms     52:	treeSet = make(map[string]*Tree)
         .          .     53:	t := New(name)
         .          .     54:	t.text = text
         .      260ms     55:	_, err = t.Parse(text, leftDelim, rightDelim, treeSet, funcs...)
         .          .     56:	return
         .          .     57:}
         .          .     58:
         .          .     59:// next returns the next token.
         .          .     60:func (t *Tree) next() item {
ROUTINE ======================== text/template/parse.lexField in /home/isucon/.local/go/src/text/template/parse/lex.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    461:}
         .          .    462:
         .          .    463:// lexField scans a field: .Alphanumeric.
         .          .    464:// The . has been scanned.
         .          .    465:func lexField(l *lexer) stateFn {
         .       20ms    466:	return lexFieldOrVariable(l, itemField)
         .          .    467:}
         .          .    468:
         .          .    469:// lexVariable scans a Variable: $Alphanumeric.
         .          .    470:// The $ has been scanned.
         .          .    471:func lexVariable(l *lexer) stateFn {
ROUTINE ======================== text/template/parse.lexFieldOrVariable in /home/isucon/.local/go/src/text/template/parse/lex.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    487:		}
         .          .    488:		return lexInsideAction
         .          .    489:	}
         .          .    490:	var r rune
         .          .    491:	for {
         .       20ms    492:		r = l.next()
         .          .    493:		if !isAlphaNumeric(r) {
         .          .    494:			l.backup()
         .          .    495:			break
         .          .    496:		}
         .          .    497:	}
ROUTINE ======================== text/template/parse.lexIdentifier in /home/isucon/.local/go/src/text/template/parse/lex.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    444:			if !l.atTerminator() {
         .          .    445:				return l.errorf("bad character %#U", r)
         .          .    446:			}
         .          .    447:			switch {
         .          .    448:			case key[word] > itemKeyword:
         .       10ms    449:				l.emit(key[word])
         .          .    450:			case word[0] == '.':
         .          .    451:				l.emit(itemField)
         .          .    452:			case word == "true", word == "false":
         .          .    453:				l.emit(itemBool)
         .          .    454:			default:
ROUTINE ======================== text/template/parse.lexInsideAction in /home/isucon/.local/go/src/text/template/parse/lex.go
      10ms       20ms (flat, cum) 0.036% of Total
         .          .    359:// lexInsideAction scans the elements inside action delimiters.
         .          .    360:func lexInsideAction(l *lexer) stateFn {
         .          .    361:	// Either number, quoted string, or identifier.
         .          .    362:	// Spaces separate arguments; runs of spaces turn into itemSpace.
         .          .    363:	// Pipe symbols separate and are emitted.
         .       10ms    364:	delim, _ := l.atRightDelim()
         .          .    365:	if delim {
         .          .    366:		if l.parenDepth == 0 {
         .          .    367:			return lexRightDelim
         .          .    368:		}
         .          .    369:		return l.errorf("unclosed left paren")
         .          .    370:	}
      10ms       10ms    371:	switch r := l.next(); {
         .          .    372:	case r == eof || isEndOfLine(r):
         .          .    373:		return l.errorf("unclosed action")
         .          .    374:	case isSpace(r):
         .          .    375:		return lexSpace
         .          .    376:	case r == ':':
ROUTINE ======================== text/template/parse.lexLeftDelim in /home/isucon/.local/go/src/text/template/parse/lex.go
         0       20ms (flat, cum) 0.036% of Total
         .          .    303:	trimSpace := strings.HasPrefix(l.input[l.pos:], leftTrimMarker)
         .          .    304:	afterMarker := Pos(0)
         .          .    305:	if trimSpace {
         .          .    306:		afterMarker = trimMarkerLen
         .          .    307:	}
         .       10ms    308:	if strings.HasPrefix(l.input[l.pos+afterMarker:], leftComment) {
         .          .    309:		l.pos += afterMarker
         .          .    310:		l.ignore()
         .          .    311:		return lexComment
         .          .    312:	}
         .       10ms    313:	l.emit(itemLeftDelim)
         .          .    314:	l.pos += afterMarker
         .          .    315:	l.ignore()
         .          .    316:	l.parenDepth = 0
         .          .    317:	return lexInsideAction
         .          .    318:}
ROUTINE ======================== text/template/parse.lexNumber in /home/isucon/.local/go/src/text/template/parse/lex.go
         0       10ms (flat, cum) 0.018% of Total
         .          .    558:		if !l.scanNumber() || l.input[l.pos-1] != 'i' {
         .          .    559:			return l.errorf("bad number syntax: %q", l.input[l.start:l.pos])
         .          .    560:		}
         .          .    561:		l.emit(itemComplex)
         .          .    562:	} else {
         .       10ms    563:		l.emit(itemNumber)
         .          .    564:	}
         .          .    565:	return lexInsideAction
         .          .    566:}
         .          .    567:
         .          .    568:func (l *lexer) scanNumber() bool {
ROUTINE ======================== text/template/parse.lexText in /home/isucon/.local/go/src/text/template/parse/lex.go
      50ms      110ms (flat, cum)   0.2% of Total
         .          .    235:)
         .          .    236:
         .          .    237:// lexText scans until an opening action delimiter, "{{".
         .          .    238:func lexText(l *lexer) stateFn {
         .          .    239:	for {
      40ms       50ms    240:		delim, trimSpace := l.atLeftDelim()
         .          .    241:		if delim {
         .          .    242:			trimLength := Pos(0)
         .          .    243:			if trimSpace {
         .          .    244:				trimLength = rightTrimLength(l.input[l.start:l.pos])
         .          .    245:			}
         .          .    246:			l.pos -= trimLength
         .          .    247:			if l.pos > l.start {
         .          .    248:				l.emit(itemText)
         .          .    249:			}
         .          .    250:			l.pos += trimLength
         .          .    251:			l.ignore()
         .          .    252:			return lexLeftDelim
         .          .    253:		}
      10ms       60ms    254:		if l.next() == eof {
         .          .    255:			break
         .          .    256:		}
         .          .    257:	}
         .          .    258:	// Correctly reached EOF.
         .          .    259:	if l.pos > l.start {
ROUTINE ======================== time.(*Location).get in /home/isucon/.local/go/src/time/zoneinfo.go
      60ms      190ms (flat, cum)  0.34% of Total
         .          .     66:// localLoc is separate so that initLocal can initialize
         .          .     67:// it even if a client has changed Local.
         .          .     68:var localLoc Location
         .          .     69:var localOnce sync.Once
         .          .     70:
      30ms       30ms     71:func (l *Location) get() *Location {
         .          .     72:	if l == nil {
         .          .     73:		return &utcLoc
         .          .     74:	}
         .          .     75:	if l == &localLoc {
         .      130ms     76:		localOnce.Do(initLocal)
         .          .     77:	}
      30ms       30ms     78:	return l
         .          .     79:}
         .          .     80:
         .          .     81:// String returns a descriptive name for the time zone information,
         .          .     82:// corresponding to the argument to LoadLocation.
         .          .     83:func (l *Location) String() string {
ROUTINE ======================== time.(*Location).lookup in /home/isucon/.local/go/src/time/zoneinfo.go
     180ms      370ms (flat, cum)  0.66% of Total
         .          .    103://
         .          .    104:// The returned information gives the name of the zone (such as "CET"),
         .          .    105:// the start and end times bracketing sec when that zone is in effect,
         .          .    106:// the offset in seconds east of UTC (such as -5*60*60), and whether
         .          .    107:// the daylight savings is being observed at that time.
      30ms       30ms    108:func (l *Location) lookup(sec int64) (name string, offset int, isDST bool, start, end int64) {
      20ms      210ms    109:	l = l.get()
         .          .    110:
      50ms       50ms    111:	if len(l.zone) == 0 {
         .          .    112:		name = "UTC"
         .          .    113:		offset = 0
         .          .    114:		isDST = false
         .          .    115:		start = alpha
         .          .    116:		end = omega
         .          .    117:		return
         .          .    118:	}
         .          .    119:
      40ms       40ms    120:	if zone := l.cacheZone; zone != nil && l.cacheStart <= sec && sec < l.cacheEnd {
      20ms       20ms    121:		name = zone.name
      10ms       10ms    122:		offset = zone.offset
         .          .    123:		isDST = zone.isDST
         .          .    124:		start = l.cacheStart
         .          .    125:		end = l.cacheEnd
      10ms       10ms    126:		return
         .          .    127:	}
         .          .    128:
         .          .    129:	if len(l.tx) == 0 || sec < l.tx[0].when {
         .          .    130:		zone := &l.zone[l.lookupFirstZone()]
         .          .    131:		name = zone.name
ROUTINE ======================== time.(*Time).Format in <autogenerated>
         0       50ms (flat, cum)  0.09% of Total
 Error: open <autogenerated>: no such file or directory
ROUTINE ======================== time.Date in /home/isucon/.local/go/src/time/time.go
     470ms      840ms (flat, cum)  1.51% of Total
         .          .   1023:// choice of time zone, and therefore the time, is not well-defined.
         .          .   1024:// Date returns a time that is correct in one of the two zones involved
         .          .   1025:// in the transition, but it does not guarantee which.
         .          .   1026://
         .          .   1027:// Date panics if loc is nil.
      40ms       40ms   1028:func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time {
         .          .   1029:	if loc == nil {
         .          .   1030:		panic("time: missing Location in call to Date")
         .          .   1031:	}
         .          .   1032:
         .          .   1033:	// Normalize month, overflowing into year.
         .          .   1034:	m := int(month) - 1
         .          .   1035:	year, m = norm(year, m, 12)
         .          .   1036:	month = Month(m) + 1
         .          .   1037:
         .          .   1038:	// Normalize nsec, sec, min, hour, overflowing into day.
      20ms       20ms   1039:	sec, nsec = norm(sec, nsec, 1e9)
      50ms       50ms   1040:	min, sec = norm(min, sec, 60)
      20ms       20ms   1041:	hour, min = norm(hour, min, 60)
      20ms       20ms   1042:	day, hour = norm(day, hour, 24)
         .          .   1043:
      10ms       10ms   1044:	y := uint64(int64(year) - absoluteZeroYear)
         .          .   1045:
         .          .   1046:	// Compute days since the absolute epoch.
         .          .   1047:
         .          .   1048:	// Add in days from 400-year cycles.
      30ms       30ms   1049:	n := y / 400
      10ms       10ms   1050:	y -= 400 * n
         .          .   1051:	d := daysPer400Years * n
         .          .   1052:
         .          .   1053:	// Add in 100-year cycles.
      20ms       20ms   1054:	n = y / 100
         .          .   1055:	y -= 100 * n
         .          .   1056:	d += daysPer100Years * n
         .          .   1057:
         .          .   1058:	// Add in 4-year cycles.
         .          .   1059:	n = y / 4
      20ms       20ms   1060:	y -= 4 * n
         .          .   1061:	d += daysPer4Years * n
         .          .   1062:
         .          .   1063:	// Add in non-leap years.
         .          .   1064:	n = y
      10ms       10ms   1065:	d += 365 * n
         .          .   1066:
         .          .   1067:	// Add in days before this month.
      50ms       50ms   1068:	d += uint64(daysBefore[month-1])
      50ms       50ms   1069:	if isLeap(year) && month >= March {
         .          .   1070:		d++ // February 29
         .          .   1071:	}
         .          .   1072:
         .          .   1073:	// Add in days before today.
      30ms       30ms   1074:	d += uint64(day - 1)
         .          .   1075:
         .          .   1076:	// Add in time elapsed today.
      10ms       10ms   1077:	abs := d * secondsPerDay
      10ms       10ms   1078:	abs += uint64(hour*secondsPerHour + min*secondsPerMinute + sec)
         .          .   1079:
         .          .   1080:	unix := int64(abs) + (absoluteToInternal + internalToUnix)
         .          .   1081:
         .          .   1082:	// Look for zone offset for t, so we can adjust to UTC.
         .          .   1083:	// The lookup function expects UTC, so we pass t in the
         .          .   1084:	// hope that it will not be too close to a zone transition,
         .          .   1085:	// and then adjust if it is.
      40ms      410ms   1086:	_, offset, _, start, end := loc.lookup(unix)
         .          .   1087:	if offset != 0 {
         .          .   1088:		switch utc := unix - int64(offset); {
         .          .   1089:		case utc < start:
         .          .   1090:			_, offset, _, _, _ = loc.lookup(start - 1)
      10ms       10ms   1091:		case utc >= end:
         .          .   1092:			_, offset, _, _, _ = loc.lookup(end)
         .          .   1093:		}
         .          .   1094:		unix -= int64(offset)
         .          .   1095:	}
         .          .   1096:
      20ms       20ms   1097:	return Time{unix + unixToInternal, int32(nsec), loc}
         .          .   1098:}
         .          .   1099:
         .          .   1100:// Truncate returns the result of rounding t down to a multiple of d (since the zero time).
         .          .   1101:// If d <= 0, Truncate returns t unchanged.
         .          .   1102:func (t Time) Truncate(d Duration) Time {
ROUTINE ======================== time.Parse in /home/isucon/.local/go/src/time/format.go
      90ms      4.52s (flat, cum)  8.12% of Total
         .          .    727:// in a fabricated location with the given zone abbreviation and a zero offset.
         .          .    728:// This choice means that such a time can be parsed and reformatted with the
         .          .    729:// same layout losslessly, but the exact instant used in the representation will
         .          .    730:// differ by the actual zone offset. To avoid such problems, prefer time layouts
         .          .    731:// that use a numeric zone offset, or use ParseInLocation.
      30ms       30ms    732:func Parse(layout, value string) (Time, error) {
      60ms      4.49s    733:	return parse(layout, value, UTC, Local)
         .          .    734:}
         .          .    735:
         .          .    736:// ParseInLocation is like Parse but differs in two important ways.
         .          .    737:// First, in the absence of time zone information, Parse interprets a time as UTC;
         .          .    738:// ParseInLocation interprets the time as in the given location.
ROUTINE ======================== time.Time.AppendFormat in /home/isucon/.local/go/src/time/format.go
         0       50ms (flat, cum)  0.09% of Total
         .          .    450:
         .          .    451:// AppendFormat is like Format but appends the textual
         .          .    452:// representation to b and returns the extended buffer.
         .          .    453:func (t Time) AppendFormat(b []byte, layout string) []byte {
         .          .    454:	var (
         .       10ms    455:		name, offset, abs = t.locabs()
         .          .    456:
         .          .    457:		year  int = -1
         .          .    458:		month Month
         .          .    459:		day   int
         .          .    460:		hour  int = -1
         .          .    461:		min   int
         .          .    462:		sec   int
         .          .    463:	)
         .          .    464:	// Each iteration generates one std value.
         .          .    465:	for layout != "" {
         .       30ms    466:		prefix, std, suffix := nextStdChunk(layout)
         .          .    467:		if prefix != "" {
         .       10ms    468:			b = append(b, prefix...)
         .          .    469:		}
         .          .    470:		if std == 0 {
         .          .    471:			break
         .          .    472:		}
         .          .    473:		layout = suffix
ROUTINE ======================== time.Time.Clock in /home/isucon/.local/go/src/time/time.go
      80ms      110ms (flat, cum)   0.2% of Total
         .          .    380:
         .          .    381:	return
         .          .    382:}
         .          .    383:
         .          .    384:// Clock returns the hour, minute, and second within the day specified by t.
      10ms       10ms    385:func (t Time) Clock() (hour, min, sec int) {
      70ms      100ms    386:	return absClock(t.abs())
         .          .    387:}
         .          .    388:
         .          .    389:// absClock is like clock but operates on an absolute time.
         .          .    390:func absClock(abs uint64) (hour, min, sec int) {
         .          .    391:	sec = int(abs % secondsPerDay)
ROUTINE ======================== time.Time.Date in /home/isucon/.local/go/src/time/time.go
      70ms      390ms (flat, cum)   0.7% of Total
         .          .    285:	abs = uint64(sec + (unixToInternal + internalToAbsolute))
         .          .    286:	return
         .          .    287:}
         .          .    288:
         .          .    289:// Date returns the year, month, and day in which t occurs.
      50ms       50ms    290:func (t Time) Date() (year int, month Month, day int) {
      20ms      340ms    291:	year, month, day, _ = t.date(true)
         .          .    292:	return
         .          .    293:}
         .          .    294:
         .          .    295:// Year returns the year in which t occurs.
         .          .    296:func (t Time) Year() int {
ROUTINE ======================== time.Time.Format in /home/isucon/.local/go/src/time/format.go
         0       50ms (flat, cum)  0.09% of Total
         .          .    442:		var buf [bufSize]byte
         .          .    443:		b = buf[:0]
         .          .    444:	} else {
         .          .    445:		b = make([]byte, 0, max)
         .          .    446:	}
         .       50ms    447:	b = t.AppendFormat(b, layout)
         .          .    448:	return string(b)
         .          .    449:}
         .          .    450:
         .          .    451:// AppendFormat is like Format but appends the textual
         .          .    452:// representation to b and returns the extended buffer.
ROUTINE ======================== time.Time.abs in /home/isucon/.local/go/src/time/time.go
      30ms       30ms (flat, cum) 0.054% of Total
         .          .    242:	return t.sec == 0 && t.nsec == 0
         .          .    243:}
         .          .    244:
         .          .    245:// abs returns the time t as an absolute time, adjusted by the zone offset.
         .          .    246:// It is called when computing a presentation property like Month or Hour.
      20ms       20ms    247:func (t Time) abs() uint64 {
         .          .    248:	l := t.loc
         .          .    249:	// Avoid function calls when possible.
         .          .    250:	if l == nil || l == &localLoc {
         .          .    251:		l = l.get()
         .          .    252:	}
         .          .    253:	sec := t.sec + internalToUnix
         .          .    254:	if l != &utcLoc {
         .          .    255:		if l.cacheZone != nil && l.cacheStart <= sec && sec < l.cacheEnd {
         .          .    256:			sec += int64(l.cacheZone.offset)
         .          .    257:		} else {
         .          .    258:			_, offset, _, _, _ := l.lookup(sec)
         .          .    259:			sec += int64(offset)
         .          .    260:		}
         .          .    261:	}
      10ms       10ms    262:	return uint64(sec + (unixToInternal + internalToAbsolute))
         .          .    263:}
         .          .    264:
         .          .    265:// locabs is a combination of the Zone and abs methods,
         .          .    266:// extracting both return values from a single zone lookup.
         .          .    267:func (t Time) locabs() (name string, offset int, abs uint64) {
ROUTINE ======================== time.Time.date in /home/isucon/.local/go/src/time/time.go
      80ms      320ms (flat, cum)  0.58% of Total
         .          .    668:	daysPer4Years    = 365*4 + 1
         .          .    669:)
         .          .    670:
         .          .    671:// date computes the year, day of year, and when full=true,
         .          .    672:// the month and day in which t occurs.
      40ms       40ms    673:func (t Time) date(full bool) (year int, month Month, day int, yday int) {
      40ms      280ms    674:	return absDate(t.abs(), full)
         .          .    675:}
         .          .    676:
         .          .    677:// absDate is like date but operates on an absolute time.
         .          .    678:func absDate(abs uint64, full bool) (year int, month Month, day int, yday int) {
         .          .    679:	// Split into time and day.
ROUTINE ======================== time.Time.locabs in /home/isucon/.local/go/src/time/time.go
      10ms       10ms (flat, cum) 0.018% of Total
         .          .    271:	}
         .          .    272:	// Avoid function call if we hit the local time cache.
         .          .    273:	sec := t.sec + internalToUnix
         .          .    274:	if l != &utcLoc {
         .          .    275:		if l.cacheZone != nil && l.cacheStart <= sec && sec < l.cacheEnd {
      10ms       10ms    276:			name = l.cacheZone.name
         .          .    277:			offset = l.cacheZone.offset
         .          .    278:		} else {
         .          .    279:			name, offset, _, _, _ = l.lookup(sec)
         .          .    280:		}
         .          .    281:		sec += int64(offset)
ROUTINE ======================== time.absDate in /home/isucon/.local/go/src/time/time.go
     240ms      240ms (flat, cum)  0.43% of Total
         .          .    673:func (t Time) date(full bool) (year int, month Month, day int, yday int) {
         .          .    674:	return absDate(t.abs(), full)
         .          .    675:}
         .          .    676:
         .          .    677:// absDate is like date but operates on an absolute time.
      20ms       20ms    678:func absDate(abs uint64, full bool) (year int, month Month, day int, yday int) {
         .          .    679:	// Split into time and day.
         .          .    680:	d := abs / secondsPerDay
         .          .    681:
         .          .    682:	// Account for 400 year cycles.
      10ms       10ms    683:	n := d / daysPer400Years
      10ms       10ms    684:	y := 400 * n
         .          .    685:	d -= daysPer400Years * n
         .          .    686:
         .          .    687:	// Cut off 100-year cycles.
         .          .    688:	// The last cycle has one extra leap year, so on the last day
         .          .    689:	// of that year, day / daysPer100Years will be 4 instead of 3.
         .          .    690:	// Cut it back down to 3 by subtracting n>>2.
      20ms       20ms    691:	n = d / daysPer100Years
      10ms       10ms    692:	n -= n >> 2
         .          .    693:	y += 100 * n
      10ms       10ms    694:	d -= daysPer100Years * n
         .          .    695:
         .          .    696:	// Cut off 4-year cycles.
         .          .    697:	// The last cycle has a missing leap year, which does not
         .          .    698:	// affect the computation.
         .          .    699:	n = d / daysPer4Years
         .          .    700:	y += 4 * n
         .          .    701:	d -= daysPer4Years * n
         .          .    702:
         .          .    703:	// Cut off years within a 4-year cycle.
         .          .    704:	// The last year is a leap year, so on the last day of that year,
         .          .    705:	// day / 365 will be 4 instead of 3.  Cut it back down to 3
         .          .    706:	// by subtracting n>>2.
      30ms       30ms    707:	n = d / 365
         .          .    708:	n -= n >> 2
         .          .    709:	y += n
      10ms       10ms    710:	d -= 365 * n
         .          .    711:
         .          .    712:	year = int(int64(y) + absoluteZeroYear)
         .          .    713:	yday = int(d)
         .          .    714:
         .          .    715:	if !full {
         .          .    716:		return
         .          .    717:	}
         .          .    718:
         .          .    719:	day = yday
      60ms       60ms    720:	if isLeap(year) {
         .          .    721:		// Leap year
         .          .    722:		switch {
         .          .    723:		case day > 31+29-1:
         .          .    724:			// After leap day; pretend it wasn't there.
         .          .    725:			day--
         .          .    726:		case day == 31+29-1:
         .          .    727:			// Leap day.
         .          .    728:			month = February
         .          .    729:			day = 29
         .          .    730:			return
         .          .    731:		}
         .          .    732:	}
         .          .    733:
         .          .    734:	// Estimate month on assumption that every month has 31 days.
         .          .    735:	// The estimate may be too low by at most one month, so adjust.
         .          .    736:	month = Month(day / 31)
      10ms       10ms    737:	end := int(daysBefore[month+1])
         .          .    738:	var begin int
         .          .    739:	if day >= end {
         .          .    740:		month++
         .          .    741:		begin = end
         .          .    742:	} else {
      20ms       20ms    743:		begin = int(daysBefore[month])
         .          .    744:	}
         .          .    745:
      20ms       20ms    746:	month++ // because January is 1
         .          .    747:	day = day - begin + 1
      10ms       10ms    748:	return
         .          .    749:}
         .          .    750:
         .          .    751:// daysBefore[m] counts the number of days in a non-leap year
         .          .    752:// before month m begins.  There is an entry for m=12, counting
         .          .    753:// the number of days before January of next year (365).
ROUTINE ======================== time.atoi in /home/isucon/.local/go/src/time/format.go
     100ms      420ms (flat, cum)  0.75% of Total
         .          .    367:
         .          .    368:// Never printed, just needs to be non-nil for return by atoi.
         .          .    369:var atoiError = errors.New("time: invalid number")
         .          .    370:
         .          .    371:// Duplicates functionality in strconv, but avoids dependency.
      40ms       40ms    372:func atoi(s string) (x int, err error) {
         .          .    373:	neg := false
      20ms       20ms    374:	if s != "" && (s[0] == '-' || s[0] == '+') {
         .          .    375:		neg = s[0] == '-'
         .          .    376:		s = s[1:]
         .          .    377:	}
      30ms      350ms    378:	q, rem, err := leadingInt(s)
         .          .    379:	x = int(q)
         .          .    380:	if err != nil || rem != "" {
         .          .    381:		return 0, atoiError
         .          .    382:	}
         .          .    383:	if neg {
         .          .    384:		x = -x
         .          .    385:	}
      10ms       10ms    386:	return x, nil
         .          .    387:}
         .          .    388:
         .          .    389:// formatNano appends a fractional second, as nanoseconds, to b
         .          .    390:// and returns the result.
         .          .    391:func formatNano(b []byte, nanosec uint, n int, trim bool) []byte {
ROUTINE ======================== time.cutspace in /home/isucon/.local/go/src/time/format.go
      60ms       60ms (flat, cum)  0.11% of Total
         .          .    656:		return int(s[0] - '0'), s[1:], nil
         .          .    657:	}
         .          .    658:	return int(s[0]-'0')*10 + int(s[1]-'0'), s[2:], nil
         .          .    659:}
         .          .    660:
      50ms       50ms    661:func cutspace(s string) string {
         .          .    662:	for len(s) > 0 && s[0] == ' ' {
         .          .    663:		s = s[1:]
         .          .    664:	}
      10ms       10ms    665:	return s
         .          .    666:}
         .          .    667:
         .          .    668:// skip removes the given prefix from value,
         .          .    669:// treating runs of space characters as equivalent.
         .          .    670:func skip(value, prefix string) (string, error) {
ROUTINE ======================== time.getnum in /home/isucon/.local/go/src/time/format.go
     450ms      450ms (flat, cum)  0.81% of Total
         .          .    643:}
         .          .    644:
         .          .    645:// getnum parses s[0:1] or s[0:2] (fixed forces the latter)
         .          .    646:// as a decimal integer and returns the integer and the
         .          .    647:// remainder of the string.
      60ms       60ms    648:func getnum(s string, fixed bool) (int, string, error) {
      90ms       90ms    649:	if !isDigit(s, 0) {
         .          .    650:		return 0, s, errBad
         .          .    651:	}
      70ms       70ms    652:	if !isDigit(s, 1) {
         .          .    653:		if fixed {
         .          .    654:			return 0, s, errBad
         .          .    655:		}
         .          .    656:		return int(s[0] - '0'), s[1:], nil
         .          .    657:	}
     230ms      230ms    658:	return int(s[0]-'0')*10 + int(s[1]-'0'), s[2:], nil
         .          .    659:}
         .          .    660:
         .          .    661:func cutspace(s string) string {
         .          .    662:	for len(s) > 0 && s[0] == ' ' {
         .          .    663:		s = s[1:]
ROUTINE ======================== time.leadingInt in /home/isucon/.local/go/src/time/format.go
     320ms      320ms (flat, cum)  0.58% of Total
         .          .   1148:}
         .          .   1149:
         .          .   1150:var errLeadingInt = errors.New("time: bad [0-9]*") // never printed
         .          .   1151:
         .          .   1152:// leadingInt consumes the leading [0-9]* from s.
      30ms       30ms   1153:func leadingInt(s string) (x int64, rem string, err error) {
      10ms       10ms   1154:	i := 0
         .          .   1155:	for ; i < len(s); i++ {
      50ms       50ms   1156:		c := s[i]
      10ms       10ms   1157:		if c < '0' || c > '9' {
         .          .   1158:			break
         .          .   1159:		}
      20ms       20ms   1160:		if x > (1<<63-1)/10 {
         .          .   1161:			// overflow
         .          .   1162:			return 0, "", errLeadingInt
         .          .   1163:		}
      50ms       50ms   1164:		x = x*10 + int64(c) - '0'
      50ms       50ms   1165:		if x < 0 {
         .          .   1166:			// overflow
         .          .   1167:			return 0, "", errLeadingInt
         .          .   1168:		}
         .          .   1169:	}
     100ms      100ms   1170:	return x, s[i:], nil
         .          .   1171:}
         .          .   1172:
         .          .   1173:var unitMap = map[string]int64{
         .          .   1174:	"ns": int64(Nanosecond),
         .          .   1175:	"us": int64(Microsecond),
ROUTINE ======================== time.nextStdChunk in /home/isucon/.local/go/src/time/format.go
     950ms      1.34s (flat, cum)  2.41% of Total
         .          .    125:	return 'a' <= c && c <= 'z'
         .          .    126:}
         .          .    127:
         .          .    128:// nextStdChunk finds the first occurrence of a std string in
         .          .    129:// layout and returns the text before, the std string, and the text after.
      60ms       60ms    130:func nextStdChunk(layout string) (prefix string, std int, suffix string) {
      20ms       20ms    131:	for i := 0; i < len(layout); i++ {
      50ms       50ms    132:		switch c := int(layout[i]); c {
      10ms       10ms    133:		case 'J': // January, Jan
         .          .    134:			if len(layout) >= i+3 && layout[i:i+3] == "Jan" {
         .          .    135:				if len(layout) >= i+7 && layout[i:i+7] == "January" {
         .          .    136:					return layout[0:i], stdLongMonth, layout[i+7:]
         .          .    137:				}
         .          .    138:				if !startsWithLowerCase(layout[i+3:]) {
         .          .    139:					return layout[0:i], stdMonth, layout[i+3:]
         .          .    140:				}
         .          .    141:			}
         .          .    142:
      10ms       10ms    143:		case 'M': // Monday, Mon, MST
         .          .    144:			if len(layout) >= i+3 {
         .          .    145:				if layout[i:i+3] == "Mon" {
         .          .    146:					if len(layout) >= i+6 && layout[i:i+6] == "Monday" {
         .          .    147:						return layout[0:i], stdLongWeekDay, layout[i+6:]
         .          .    148:					}
         .          .    149:					if !startsWithLowerCase(layout[i+3:]) {
         .          .    150:						return layout[0:i], stdWeekDay, layout[i+3:]
         .          .    151:					}
         .          .    152:				}
         .          .    153:				if layout[i:i+3] == "MST" {
         .          .    154:					return layout[0:i], stdTZ, layout[i+3:]
         .          .    155:				}
         .          .    156:			}
         .          .    157:
         .          .    158:		case '0': // 01, 02, 03, 04, 05, 06
     170ms      170ms    159:			if len(layout) >= i+2 && '1' <= layout[i+1] && layout[i+1] <= '6' {
     140ms      140ms    160:				return layout[0:i], std0x[layout[i+1]-'1'], layout[i+2:]
         .          .    161:			}
         .          .    162:
         .          .    163:		case '1': // 15, 1
      20ms       20ms    164:			if len(layout) >= i+2 && layout[i+1] == '5' {
      20ms       20ms    165:				return layout[0:i], stdHour, layout[i+2:]
         .          .    166:			}
         .          .    167:			return layout[0:i], stdNumMonth, layout[i+1:]
         .          .    168:
         .          .    169:		case '2': // 2006, 2
      60ms       90ms    170:			if len(layout) >= i+4 && layout[i:i+4] == "2006" {
         .          .    171:				return layout[0:i], stdLongYear, layout[i+4:]
         .          .    172:			}
         .          .    173:			return layout[0:i], stdDay, layout[i+1:]
         .          .    174:
         .          .    175:		case '_': // _2, _2006
         .          .    176:			if len(layout) >= i+2 && layout[i+1] == '2' {
         .          .    177:				//_2006 is really a literal _, followed by stdLongYear
         .          .    178:				if len(layout) >= i+5 && layout[i+1:i+5] == "2006" {
         .          .    179:					return layout[0 : i+1], stdLongYear, layout[i+5:]
         .          .    180:				}
         .          .    181:				return layout[0:i], stdUnderDay, layout[i+2:]
         .          .    182:			}
         .          .    183:
         .          .    184:		case '3':
         .          .    185:			return layout[0:i], stdHour12, layout[i+1:]
         .          .    186:
         .          .    187:		case '4':
         .          .    188:			return layout[0:i], stdMinute, layout[i+1:]
         .          .    189:
      40ms       40ms    190:		case '5':
         .          .    191:			return layout[0:i], stdSecond, layout[i+1:]
         .          .    192:
         .          .    193:		case 'P': // PM
         .          .    194:			if len(layout) >= i+2 && layout[i+1] == 'M' {
         .          .    195:				return layout[0:i], stdPM, layout[i+2:]
         .          .    196:			}
         .          .    197:
         .          .    198:		case 'p': // pm
         .          .    199:			if len(layout) >= i+2 && layout[i+1] == 'm' {
         .          .    200:				return layout[0:i], stdpm, layout[i+2:]
         .          .    201:			}
         .          .    202:
         .          .    203:		case '-': // -070000, -07:00:00, -0700, -07:00, -07
      80ms      170ms    204:			if len(layout) >= i+7 && layout[i:i+7] == "-070000" {
         .          .    205:				return layout[0:i], stdNumSecondsTz, layout[i+7:]
         .          .    206:			}
      70ms      130ms    207:			if len(layout) >= i+9 && layout[i:i+9] == "-07:00:00" {
         .          .    208:				return layout[0:i], stdNumColonSecondsTZ, layout[i+9:]
         .          .    209:			}
      70ms      140ms    210:			if len(layout) >= i+5 && layout[i:i+5] == "-0700" {
         .          .    211:				return layout[0:i], stdNumTZ, layout[i+5:]
         .          .    212:			}
      90ms      210ms    213:			if len(layout) >= i+6 && layout[i:i+6] == "-07:00" {
         .          .    214:				return layout[0:i], stdNumColonTZ, layout[i+6:]
         .          .    215:			}
      20ms       40ms    216:			if len(layout) >= i+3 && layout[i:i+3] == "-07" {
         .          .    217:				return layout[0:i], stdNumShortTZ, layout[i+3:]
         .          .    218:			}
         .          .    219:
         .          .    220:		case 'Z': // Z070000, Z07:00:00, Z0700, Z07:00,
         .          .    221:			if len(layout) >= i+7 && layout[i:i+7] == "Z070000" {
         .          .    222:				return layout[0:i], stdISO8601SecondsTZ, layout[i+7:]
         .          .    223:			}
         .          .    224:			if len(layout) >= i+9 && layout[i:i+9] == "Z07:00:00" {
         .          .    225:				return layout[0:i], stdISO8601ColonSecondsTZ, layout[i+9:]
         .          .    226:			}
         .          .    227:			if len(layout) >= i+5 && layout[i:i+5] == "Z0700" {
         .          .    228:				return layout[0:i], stdISO8601TZ, layout[i+5:]
         .          .    229:			}
         .          .    230:			if len(layout) >= i+6 && layout[i:i+6] == "Z07:00" {
         .          .    231:				return layout[0:i], stdISO8601ColonTZ, layout[i+6:]
         .          .    232:			}
         .          .    233:			if len(layout) >= i+3 && layout[i:i+3] == "Z07" {
         .          .    234:				return layout[0:i], stdISO8601ShortTZ, layout[i+3:]
         .          .    235:			}
         .          .    236:
         .          .    237:		case '.': // .000 or .999 - repeated digits for fractional seconds.
         .          .    238:			if i+1 < len(layout) && (layout[i+1] == '0' || layout[i+1] == '9') {
         .          .    239:				ch := layout[i+1]
         .          .    240:				j := i + 1
         .          .    241:				for j < len(layout) && layout[j] == ch {
         .          .    242:					j++
         .          .    243:				}
         .          .    244:				// String of digits must end here - only fractional second is all digits.
         .          .    245:				if !isDigit(layout, j) {
         .          .    246:					std := stdFracSecond0
         .          .    247:					if layout[i+1] == '9' {
         .          .    248:						std = stdFracSecond9
         .          .    249:					}
         .          .    250:					std |= (j - (i + 1)) << stdArgShift
         .          .    251:					return layout[0:i], std, layout[j:]
         .          .    252:				}
         .          .    253:			}
         .          .    254:		}
         .          .    255:	}
      20ms       20ms    256:	return layout, 0, ""
         .          .    257:}
         .          .    258:
         .          .    259:var longDayNames = []string{
         .          .    260:	"Sunday",
         .          .    261:	"Monday",
ROUTINE ======================== time.parse in /home/isucon/.local/go/src/time/format.go
     1.39s      4.43s (flat, cum)  7.96% of Total
         .          .    740:// against the Local location; ParseInLocation uses the given location.
         .          .    741:func ParseInLocation(layout, value string, loc *Location) (Time, error) {
         .          .    742:	return parse(layout, value, loc, loc)
         .          .    743:}
         .          .    744:
      10ms       10ms    745:func parse(layout, value string, defaultLocation, local *Location) (Time, error) {
      10ms       10ms    746:	alayout, avalue := layout, value
      30ms       30ms    747:	rangeErrString := "" // set if a value is out of range
         .          .    748:	amSet := false       // do we need to subtract 12 from the hour for midnight?
      20ms       20ms    749:	pmSet := false       // do we need to add 12 to the hour?
         .          .    750:
         .          .    751:	// Time being constructed.
         .          .    752:	var (
         .          .    753:		year       int
      10ms       10ms    754:		month      int = 1 // January
         .          .    755:		day        int = 1
      10ms       10ms    756:		hour       int
      10ms       10ms    757:		min        int
         .          .    758:		sec        int
         .          .    759:		nsec       int
      20ms       20ms    760:		z          *Location
      10ms       10ms    761:		zoneOffset int = -1
         .          .    762:		zoneName   string
         .          .    763:	)
         .          .    764:
         .          .    765:	// Each iteration processes one std value.
         .          .    766:	for {
      60ms       60ms    767:		var err error
     130ms      1.44s    768:		prefix, std, suffix := nextStdChunk(layout)
      70ms       70ms    769:		stdstr := layout[len(prefix) : len(layout)-len(suffix)]
     190ms      710ms    770:		value, err = skip(value, prefix)
      90ms       90ms    771:		if err != nil {
         .          .    772:			return Time{}, &ParseError{alayout, avalue, prefix, value, ""}
         .          .    773:		}
      10ms       10ms    774:		if std == 0 {
         .          .    775:			if len(value) != 0 {
         .          .    776:				return Time{}, &ParseError{alayout, avalue, "", value, ": extra text: " + value}
         .          .    777:			}
         .          .    778:			break
         .          .    779:		}
      30ms       30ms    780:		layout = suffix
      80ms       80ms    781:		var p string
      50ms       50ms    782:		switch std & stdMask {
         .          .    783:		case stdYear:
         .          .    784:			if len(value) < 2 {
         .          .    785:				err = errBad
         .          .    786:				break
         .          .    787:			}
         .          .    788:			p, value = value[0:2], value[2:]
         .          .    789:			year, err = atoi(p)
         .          .    790:			if year >= 69 { // Unix time starts Dec 31 1969 in some time zones
         .          .    791:				year += 1900
         .          .    792:			} else {
         .          .    793:				year += 2000
         .          .    794:			}
      10ms       10ms    795:		case stdLongYear:
      60ms       60ms    796:			if len(value) < 4 || !isDigit(value, 0) {
         .          .    797:				err = errBad
         .          .    798:				break
         .          .    799:			}
      50ms       50ms    800:			p, value = value[0:4], value[4:]
      20ms      440ms    801:			year, err = atoi(p)
         .          .    802:		case stdMonth:
         .          .    803:			month, value, err = lookup(shortMonthNames, value)
         .          .    804:		case stdLongMonth:
         .          .    805:			month, value, err = lookup(longMonthNames, value)
         .          .    806:		case stdNumMonth, stdZeroMonth:
      90ms      210ms    807:			month, value, err = getnum(value, std == stdZeroMonth)
         .          .    808:			if month <= 0 || 12 < month {
         .          .    809:				rangeErrString = "month"
         .          .    810:			}
         .          .    811:		case stdWeekDay:
         .          .    812:			// Ignore weekday except for error checking.
         .          .    813:			_, value, err = lookup(shortDayNames, value)
         .          .    814:		case stdLongWeekDay:
         .          .    815:			_, value, err = lookup(longDayNames, value)
         .          .    816:		case stdDay, stdUnderDay, stdZeroDay:
         .          .    817:			if std == stdUnderDay && len(value) > 0 && value[0] == ' ' {
         .          .    818:				value = value[1:]
         .          .    819:			}
      30ms      100ms    820:			day, value, err = getnum(value, std == stdZeroDay)
         .          .    821:			if day < 0 {
         .          .    822:				// Note that we allow any one- or two-digit day here.
         .          .    823:				rangeErrString = "day"
         .          .    824:			}
      10ms       10ms    825:		case stdHour:
      20ms       90ms    826:			hour, value, err = getnum(value, false)
         .          .    827:			if hour < 0 || 24 <= hour {
         .          .    828:				rangeErrString = "hour"
         .          .    829:			}
         .          .    830:		case stdHour12, stdZeroHour12:
         .          .    831:			hour, value, err = getnum(value, std == stdZeroHour12)
         .          .    832:			if hour < 0 || 12 < hour {
         .          .    833:				rangeErrString = "hour"
         .          .    834:			}
         .          .    835:		case stdMinute, stdZeroMinute:
      30ms      110ms    836:			min, value, err = getnum(value, std == stdZeroMinute)
         .          .    837:			if min < 0 || 60 <= min {
         .          .    838:				rangeErrString = "minute"
         .          .    839:			}
      10ms       10ms    840:		case stdSecond, stdZeroSecond:
      60ms      170ms    841:			sec, value, err = getnum(value, std == stdZeroSecond)
         .          .    842:			if sec < 0 || 60 <= sec {
         .          .    843:				rangeErrString = "second"
         .          .    844:			}
         .          .    845:			// Special case: do we have a fractional second but no
         .          .    846:			// fractional second in the format?
         .          .    847:			if len(value) >= 2 && value[0] == '.' && isDigit(value, 1) {
         .          .    848:				_, std, _ = nextStdChunk(layout)
         .          .    849:				std &= stdMask
         .          .    850:				if std == stdFracSecond0 || std == stdFracSecond9 {
         .          .    851:					// Fractional second in the layout; proceed normally
         .          .    852:					break
         .          .    853:				}
         .          .    854:				// No fractional second in the layout but we have one in the input.
         .          .    855:				n := 2
         .          .    856:				for ; n < len(value) && isDigit(value, n); n++ {
         .          .    857:				}
         .          .    858:				nsec, rangeErrString, err = parseNanoseconds(value, n)
         .          .    859:				value = value[n:]
         .          .    860:			}
         .          .    861:		case stdPM:
         .          .    862:			if len(value) < 2 {
         .          .    863:				err = errBad
         .          .    864:				break
         .          .    865:			}
         .          .    866:			p, value = value[0:2], value[2:]
         .          .    867:			switch p {
         .          .    868:			case "PM":
         .          .    869:				pmSet = true
         .          .    870:			case "AM":
         .          .    871:				amSet = true
         .          .    872:			default:
         .          .    873:				err = errBad
         .          .    874:			}
         .          .    875:		case stdpm:
         .          .    876:			if len(value) < 2 {
         .          .    877:				err = errBad
         .          .    878:				break
         .          .    879:			}
         .          .    880:			p, value = value[0:2], value[2:]
         .          .    881:			switch p {
         .          .    882:			case "pm":
         .          .    883:				pmSet = true
         .          .    884:			case "am":
         .          .    885:				amSet = true
         .          .    886:			default:
         .          .    887:				err = errBad
         .          .    888:			}
         .          .    889:		case stdISO8601TZ, stdISO8601ColonTZ, stdISO8601SecondsTZ, stdISO8601ShortTZ, stdISO8601ColonSecondsTZ, stdNumTZ, stdNumShortTZ, stdNumColonTZ, stdNumSecondsTz, stdNumColonSecondsTZ:
         .          .    890:			if (std == stdISO8601TZ || std == stdISO8601ShortTZ || std == stdISO8601ColonTZ) && len(value) >= 1 && value[0] == 'Z' {
         .          .    891:				value = value[1:]
         .          .    892:				z = UTC
         .          .    893:				break
         .          .    894:			}
         .          .    895:			var sign, hour, min, seconds string
         .          .    896:			if std == stdISO8601ColonTZ || std == stdNumColonTZ {
         .          .    897:				if len(value) < 6 {
         .          .    898:					err = errBad
         .          .    899:					break
         .          .    900:				}
         .          .    901:				if value[3] != ':' {
         .          .    902:					err = errBad
         .          .    903:					break
         .          .    904:				}
         .          .    905:				sign, hour, min, seconds, value = value[0:1], value[1:3], value[4:6], "00", value[6:]
         .          .    906:			} else if std == stdNumShortTZ || std == stdISO8601ShortTZ {
         .          .    907:				if len(value) < 3 {
         .          .    908:					err = errBad
         .          .    909:					break
         .          .    910:				}
         .          .    911:				sign, hour, min, seconds, value = value[0:1], value[1:3], "00", "00", value[3:]
         .          .    912:			} else if std == stdISO8601ColonSecondsTZ || std == stdNumColonSecondsTZ {
         .          .    913:				if len(value) < 9 {
         .          .    914:					err = errBad
         .          .    915:					break
         .          .    916:				}
         .          .    917:				if value[3] != ':' || value[6] != ':' {
         .          .    918:					err = errBad
         .          .    919:					break
         .          .    920:				}
         .          .    921:				sign, hour, min, seconds, value = value[0:1], value[1:3], value[4:6], value[7:9], value[9:]
         .          .    922:			} else if std == stdISO8601SecondsTZ || std == stdNumSecondsTz {
         .          .    923:				if len(value) < 7 {
         .          .    924:					err = errBad
         .          .    925:					break
         .          .    926:				}
         .          .    927:				sign, hour, min, seconds, value = value[0:1], value[1:3], value[3:5], value[5:7], value[7:]
         .          .    928:			} else {
         .          .    929:				if len(value) < 5 {
         .          .    930:					err = errBad
         .          .    931:					break
         .          .    932:				}
         .          .    933:				sign, hour, min, seconds, value = value[0:1], value[1:3], value[3:5], "00", value[5:]
         .          .    934:			}
         .          .    935:			var hr, mm, ss int
         .          .    936:			hr, err = atoi(hour)
         .          .    937:			if err == nil {
         .          .    938:				mm, err = atoi(min)
         .          .    939:			}
         .          .    940:			if err == nil {
         .          .    941:				ss, err = atoi(seconds)
         .          .    942:			}
         .          .    943:			zoneOffset = (hr*60+mm)*60 + ss // offset is in seconds
         .          .    944:			switch sign[0] {
         .          .    945:			case '+':
         .          .    946:			case '-':
         .          .    947:				zoneOffset = -zoneOffset
         .          .    948:			default:
         .          .    949:				err = errBad
         .          .    950:			}
         .          .    951:		case stdTZ:
         .          .    952:			// Does it look like a time zone?
         .          .    953:			if len(value) >= 3 && value[0:3] == "UTC" {
         .          .    954:				z = UTC
         .          .    955:				value = value[3:]
         .          .    956:				break
         .          .    957:			}
         .          .    958:			n, ok := parseTimeZone(value)
         .          .    959:			if !ok {
         .          .    960:				err = errBad
         .          .    961:				break
         .          .    962:			}
         .          .    963:			zoneName, value = value[:n], value[n:]
         .          .    964:
         .          .    965:		case stdFracSecond0:
         .          .    966:			// stdFracSecond0 requires the exact number of digits as specified in
         .          .    967:			// the layout.
         .          .    968:			ndigit := 1 + (std >> stdArgShift)
         .          .    969:			if len(value) < ndigit {
         .          .    970:				err = errBad
         .          .    971:				break
         .          .    972:			}
         .          .    973:			nsec, rangeErrString, err = parseNanoseconds(value, ndigit)
         .          .    974:			value = value[ndigit:]
         .          .    975:
         .          .    976:		case stdFracSecond9:
         .          .    977:			if len(value) < 2 || value[0] != '.' || value[1] < '0' || '9' < value[1] {
         .          .    978:				// Fractional second omitted.
         .          .    979:				break
         .          .    980:			}
         .          .    981:			// Take any number of digits, even more than asked for,
         .          .    982:			// because it is what the stdSecond case would do.
         .          .    983:			i := 0
         .          .    984:			for i < 9 && i+1 < len(value) && '0' <= value[i+1] && value[i+1] <= '9' {
         .          .    985:				i++
         .          .    986:			}
         .          .    987:			nsec, rangeErrString, err = parseNanoseconds(value, 1+i)
         .          .    988:			value = value[1+i:]
         .          .    989:		}
      20ms       20ms    990:		if rangeErrString != "" {
         .          .    991:			return Time{}, &ParseError{alayout, avalue, stdstr, value, ": " + rangeErrString + " out of range"}
         .          .    992:		}
      20ms       20ms    993:		if err != nil {
         .          .    994:			return Time{}, &ParseError{alayout, avalue, stdstr, value, ""}
         .          .    995:		}
         .          .    996:	}
         .          .    997:	if pmSet && hour < 12 {
         .          .    998:		hour += 12
         .          .    999:	} else if amSet && hour == 12 {
         .          .   1000:		hour = 0
         .          .   1001:	}
         .          .   1002:
         .          .   1003:	// Validate the day of the month.
      20ms       20ms   1004:	if day > daysIn(Month(month), year) {
         .          .   1005:		return Time{}, &ParseError{alayout, avalue, "", value, ": day out of range"}
         .          .   1006:	}
         .          .   1007:
      10ms       10ms   1008:	if z != nil {
         .          .   1009:		return Date(year, Month(month), day, hour, min, sec, nsec, z), nil
         .          .   1010:	}
         .          .   1011:
      10ms       10ms   1012:	if zoneOffset != -1 {
         .          .   1013:		t := Date(year, Month(month), day, hour, min, sec, nsec, UTC)
         .          .   1014:		t.sec -= int64(zoneOffset)
         .          .   1015:
         .          .   1016:		// Look for local zone with the given offset.
         .          .   1017:		// If that zone was in effect at the given time, use it.
         .          .   1018:		name, offset, _, _, _ := local.lookup(t.sec + internalToUnix)
         .          .   1019:		if offset == zoneOffset && (zoneName == "" || name == zoneName) {
         .          .   1020:			t.loc = local
         .          .   1021:			return t, nil
         .          .   1022:		}
         .          .   1023:
         .          .   1024:		// Otherwise create fake zone to record offset.
         .          .   1025:		t.loc = FixedZone(zoneName, zoneOffset)
         .          .   1026:		return t, nil
         .          .   1027:	}
         .          .   1028:
      10ms       10ms   1029:	if zoneName != "" {
         .          .   1030:		t := Date(year, Month(month), day, hour, min, sec, nsec, UTC)
         .          .   1031:		// Look for local zone with the given offset.
         .          .   1032:		// If that zone was in effect at the given time, use it.
         .          .   1033:		offset, _, ok := local.lookupName(zoneName, t.sec+internalToUnix)
         .          .   1034:		if ok {
         .          .   1035:			t.sec -= int64(offset)
         .          .   1036:			t.loc = local
         .          .   1037:			return t, nil
         .          .   1038:		}
         .          .   1039:
         .          .   1040:		// Otherwise, create fake zone with unknown offset.
         .          .   1041:		if len(zoneName) > 3 && zoneName[:3] == "GMT" {
         .          .   1042:			offset, _ = atoi(zoneName[3:]) // Guaranteed OK by parseGMT.
         .          .   1043:			offset *= 3600
         .          .   1044:		}
         .          .   1045:		t.loc = FixedZone(zoneName, offset)
         .          .   1046:		return t, nil
         .          .   1047:	}
         .          .   1048:
         .          .   1049:	// Otherwise, fall back to default.
      70ms      410ms   1050:	return Date(year, Month(month), day, hour, min, sec, nsec, defaultLocation), nil
         .          .   1051:}
         .          .   1052:
         .          .   1053:// parseTimeZone parses a time zone string and returns its length. Time zones
         .          .   1054:// are human-generated and unpredictable. We can't do precise error checking.
         .          .   1055:// On the other hand, for a correct parse there must be a time zone at the
ROUTINE ======================== time.skip in /home/isucon/.local/go/src/time/format.go
     460ms      520ms (flat, cum)  0.93% of Total
         .          .    665:	return s
         .          .    666:}
         .          .    667:
         .          .    668:// skip removes the given prefix from value,
         .          .    669:// treating runs of space characters as equivalent.
     140ms      140ms    670:func skip(value, prefix string) (string, error) {
      50ms       50ms    671:	for len(prefix) > 0 {
      30ms       30ms    672:		if prefix[0] == ' ' {
         .          .    673:			if len(value) > 0 && value[0] != ' ' {
         .          .    674:				return value, errBad
         .          .    675:			}
      10ms       30ms    676:			prefix = cutspace(prefix)
      10ms       50ms    677:			value = cutspace(value)
         .          .    678:			continue
         .          .    679:		}
         .          .    680:		if len(value) == 0 || value[0] != prefix[0] {
         .          .    681:			return value, errBad
         .          .    682:		}
      40ms       40ms    683:		prefix = prefix[1:]
      80ms       80ms    684:		value = value[1:]
         .          .    685:	}
     100ms      100ms    686:	return value, nil
         .          .    687:}
         .          .    688:
         .          .    689:// Parse parses a formatted string and returns the time value it represents.
         .          .    690:// The layout  defines the format by showing how the reference time,
         .          .    691:// defined to be
ROUTINE ======================== unicode/utf8.DecodeRuneInString in /home/isucon/.local/go/src/unicode/utf8/utf8.go
      60ms       60ms (flat, cum)  0.11% of Total
         .          .    196:// UTF-8.
         .          .    197://
         .          .    198:// An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
         .          .    199:// out of range, or is not the shortest possible UTF-8 encoding for the
         .          .    200:// value. No other validation is performed.
      20ms       20ms    201:func DecodeRuneInString(s string) (r rune, size int) {
         .          .    202:	n := len(s)
         .          .    203:	if n < 1 {
         .          .    204:		return RuneError, 0
         .          .    205:	}
      20ms       20ms    206:	s0 := s[0]
         .          .    207:	x := first[s0]
      10ms       10ms    208:	if x >= as {
         .          .    209:		// The following code simulates an additional check for x == xx and
         .          .    210:		// handling the ASCII and invalid cases accordingly. This mask-and-or
         .          .    211:		// approach prevents an additional branch.
         .          .    212:		mask := rune(x) << 31 >> 31 // Create 0x0000 or 0xFFFF.
         .          .    213:		return rune(s[0])&^mask | RuneError&mask, 1
         .          .    214:	}
      10ms       10ms    215:	sz := x & 7
         .          .    216:	accept := acceptRanges[x>>4]
         .          .    217:	if n < int(sz) {
         .          .    218:		return RuneError, 1
         .          .    219:	}
         .          .    220:	s1 := s[1]
